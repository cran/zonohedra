<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Glenn Davis" />

<meta name="date" content="2025-08-27" />

<title>zonohedra User Guide</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>
<script>(function() {
  // If window.HTMLWidgets is already defined, then use it; otherwise create a
  // new object. This allows preceding code to set options that affect the
  // initialization process (though none currently exist).
  window.HTMLWidgets = window.HTMLWidgets || {};

  // See if we're running in a viewer pane. If not, we're in a web browser.
  var viewerMode = window.HTMLWidgets.viewerMode =
      /\bviewer_pane=1\b/.test(window.location);

  // See if we're running in Shiny mode. If not, it's a static document.
  // Note that static widgets can appear in both Shiny and static modes, but
  // obviously, Shiny widgets can only appear in Shiny apps/documents.
  var shinyMode = window.HTMLWidgets.shinyMode =
      typeof(window.Shiny) !== "undefined" && !!window.Shiny.outputBindings;

  // We can't count on jQuery being available, so we implement our own
  // version if necessary.
  function querySelectorAll(scope, selector) {
    if (typeof(jQuery) !== "undefined" && scope instanceof jQuery) {
      return scope.find(selector);
    }
    if (scope.querySelectorAll) {
      return scope.querySelectorAll(selector);
    }
  }

  function asArray(value) {
    if (value === null)
      return [];
    if ($.isArray(value))
      return value;
    return [value];
  }

  // Implement jQuery's extend
  function extend(target /*, ... */) {
    if (arguments.length == 1) {
      return target;
    }
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          target[prop] = source[prop];
        }
      }
    }
    return target;
  }

  // IE8 doesn't support Array.forEach.
  function forEach(values, callback, thisArg) {
    if (values.forEach) {
      values.forEach(callback, thisArg);
    } else {
      for (var i = 0; i < values.length; i++) {
        callback.call(thisArg, values[i], i, values);
      }
    }
  }

  // Replaces the specified method with the return value of funcSource.
  //
  // Note that funcSource should not BE the new method, it should be a function
  // that RETURNS the new method. funcSource receives a single argument that is
  // the overridden method, it can be called from the new method. The overridden
  // method can be called like a regular function, it has the target permanently
  // bound to it so "this" will work correctly.
  function overrideMethod(target, methodName, funcSource) {
    var superFunc = target[methodName] || function() {};
    var superFuncBound = function() {
      return superFunc.apply(target, arguments);
    };
    target[methodName] = funcSource(superFuncBound);
  }

  // Add a method to delegator that, when invoked, calls
  // delegatee.methodName. If there is no such method on
  // the delegatee, but there was one on delegator before
  // delegateMethod was called, then the original version
  // is invoked instead.
  // For example:
  //
  // var a = {
  //   method1: function() { console.log('a1'); }
  //   method2: function() { console.log('a2'); }
  // };
  // var b = {
  //   method1: function() { console.log('b1'); }
  // };
  // delegateMethod(a, b, "method1");
  // delegateMethod(a, b, "method2");
  // a.method1();
  // a.method2();
  //
  // The output would be "b1", "a2".
  function delegateMethod(delegator, delegatee, methodName) {
    var inherited = delegator[methodName];
    delegator[methodName] = function() {
      var target = delegatee;
      var method = delegatee[methodName];

      // The method doesn't exist on the delegatee. Instead,
      // call the method on the delegator, if it exists.
      if (!method) {
        target = delegator;
        method = inherited;
      }

      if (method) {
        return method.apply(target, arguments);
      }
    };
  }

  // Implement a vague facsimilie of jQuery's data method
  function elementData(el, name, value) {
    if (arguments.length == 2) {
      return el["htmlwidget_data_" + name];
    } else if (arguments.length == 3) {
      el["htmlwidget_data_" + name] = value;
      return el;
    } else {
      throw new Error("Wrong number of arguments for elementData: " +
        arguments.length);
    }
  }

  // http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
  function escapeRegExp(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  }

  function hasClass(el, className) {
    var re = new RegExp("\\b" + escapeRegExp(className) + "\\b");
    return re.test(el.className);
  }

  // elements - array (or array-like object) of HTML elements
  // className - class name to test for
  // include - if true, only return elements with given className;
  //   if false, only return elements *without* given className
  function filterByClass(elements, className, include) {
    var results = [];
    for (var i = 0; i < elements.length; i++) {
      if (hasClass(elements[i], className) == include)
        results.push(elements[i]);
    }
    return results;
  }

  function on(obj, eventName, func) {
    if (obj.addEventListener) {
      obj.addEventListener(eventName, func, false);
    } else if (obj.attachEvent) {
      obj.attachEvent(eventName, func);
    }
  }

  function off(obj, eventName, func) {
    if (obj.removeEventListener)
      obj.removeEventListener(eventName, func, false);
    else if (obj.detachEvent) {
      obj.detachEvent(eventName, func);
    }
  }

  // Translate array of values to top/right/bottom/left, as usual with
  // the "padding" CSS property
  // https://developer.mozilla.org/en-US/docs/Web/CSS/padding
  function unpackPadding(value) {
    if (typeof(value) === "number")
      value = [value];
    if (value.length === 1) {
      return {top: value[0], right: value[0], bottom: value[0], left: value[0]};
    }
    if (value.length === 2) {
      return {top: value[0], right: value[1], bottom: value[0], left: value[1]};
    }
    if (value.length === 3) {
      return {top: value[0], right: value[1], bottom: value[2], left: value[1]};
    }
    if (value.length === 4) {
      return {top: value[0], right: value[1], bottom: value[2], left: value[3]};
    }
  }

  // Convert an unpacked padding object to a CSS value
  function paddingToCss(paddingObj) {
    return paddingObj.top + "px " + paddingObj.right + "px " + paddingObj.bottom + "px " + paddingObj.left + "px";
  }

  // Makes a number suitable for CSS
  function px(x) {
    if (typeof(x) === "number")
      return x + "px";
    else
      return x;
  }

  // Retrieves runtime widget sizing information for an element.
  // The return value is either null, or an object with fill, padding,
  // defaultWidth, defaultHeight fields.
  function sizingPolicy(el) {
    var sizingEl = document.querySelector("script[data-for='" + el.id + "'][type='application/htmlwidget-sizing']");
    if (!sizingEl)
      return null;
    var sp = JSON.parse(sizingEl.textContent || sizingEl.text || "{}");
    if (viewerMode) {
      return sp.viewer;
    } else {
      return sp.browser;
    }
  }

  // @param tasks Array of strings (or falsy value, in which case no-op).
  //   Each element must be a valid JavaScript expression that yields a
  //   function. Or, can be an array of objects with "code" and "data"
  //   properties; in this case, the "code" property should be a string
  //   of JS that's an expr that yields a function, and "data" should be
  //   an object that will be added as an additional argument when that
  //   function is called.
  // @param target The object that will be "this" for each function
  //   execution.
  // @param args Array of arguments to be passed to the functions. (The
  //   same arguments will be passed to all functions.)
  function evalAndRun(tasks, target, args) {
    if (tasks) {
      forEach(tasks, function(task) {
        var theseArgs = args;
        if (typeof(task) === "object") {
          theseArgs = theseArgs.concat([task.data]);
          task = task.code;
        }
        var taskFunc = tryEval(task);
        if (typeof(taskFunc) !== "function") {
          throw new Error("Task must be a function! Source:\n" + task);
        }
        taskFunc.apply(target, theseArgs);
      });
    }
  }

  // Attempt eval() both with and without enclosing in parentheses.
  // Note that enclosing coerces a function declaration into
  // an expression that eval() can parse
  // (otherwise, a SyntaxError is thrown)
  function tryEval(code) {
    var result = null;
    try {
      result = eval("(" + code + ")");
    } catch(error) {
      if (!(error instanceof SyntaxError)) {
        throw error;
      }
      try {
        result = eval(code);
      } catch(e) {
        if (e instanceof SyntaxError) {
          throw error;
        } else {
          throw e;
        }
      }
    }
    return result;
  }

  function initSizing(el) {
    var sizing = sizingPolicy(el);
    if (!sizing)
      return;

    var cel = document.getElementById("htmlwidget_container");
    if (!cel)
      return;

    if (typeof(sizing.padding) !== "undefined") {
      document.body.style.margin = "0";
      document.body.style.padding = paddingToCss(unpackPadding(sizing.padding));
    }

    if (sizing.fill) {
      document.body.style.overflow = "hidden";
      document.body.style.width = "100%";
      document.body.style.height = "100%";
      document.documentElement.style.width = "100%";
      document.documentElement.style.height = "100%";
      cel.style.position = "absolute";
      var pad = unpackPadding(sizing.padding);
      cel.style.top = pad.top + "px";
      cel.style.right = pad.right + "px";
      cel.style.bottom = pad.bottom + "px";
      cel.style.left = pad.left + "px";
      el.style.width = "100%";
      el.style.height = "100%";

      return {
        getWidth: function() { return cel.getBoundingClientRect().width; },
        getHeight: function() { return cel.getBoundingClientRect().height; }
      };

    } else {
      el.style.width = px(sizing.width);
      el.style.height = px(sizing.height);

      return {
        getWidth: function() { return cel.getBoundingClientRect().width; },
        getHeight: function() { return cel.getBoundingClientRect().height; }
      };
    }
  }

  // Default implementations for methods
  var defaults = {
    find: function(scope) {
      return querySelectorAll(scope, "." + this.name);
    },
    renderError: function(el, err) {
      var $el = $(el);

      this.clearError(el);

      // Add all these error classes, as Shiny does
      var errClass = "shiny-output-error";
      if (err.type !== null) {
        // use the classes of the error condition as CSS class names
        errClass = errClass + " " + $.map(asArray(err.type), function(type) {
          return errClass + "-" + type;
        }).join(" ");
      }
      errClass = errClass + " htmlwidgets-error";

      // Is el inline or block? If inline or inline-block, just display:none it
      // and add an inline error.
      var display = $el.css("display");
      $el.data("restore-display-mode", display);

      if (display === "inline" || display === "inline-block") {
        $el.hide();
        if (err.message !== "") {
          var errorSpan = $("<span>").addClass(errClass);
          errorSpan.text(err.message);
          $el.after(errorSpan);
        }
      } else if (display === "block") {
        // If block, add an error just after the el, set visibility:none on the
        // el, and position the error to be on top of the el.
        // Mark it with a unique ID and CSS class so we can remove it later.
        $el.css("visibility", "hidden");
        if (err.message !== "") {
          var errorDiv = $("<div>").addClass(errClass).css("position", "absolute")
            .css("top", el.offsetTop)
            .css("left", el.offsetLeft)
            // setting width can push out the page size, forcing otherwise
            // unnecessary scrollbars to appear and making it impossible for
            // the element to shrink; so use max-width instead
            .css("maxWidth", el.offsetWidth)
            .css("height", el.offsetHeight);
          errorDiv.text(err.message);
          $el.after(errorDiv);

          // Really dumb way to keep the size/position of the error in sync with
          // the parent element as the window is resized or whatever.
          var intId = setInterval(function() {
            if (!errorDiv[0].parentElement) {
              clearInterval(intId);
              return;
            }
            errorDiv
              .css("top", el.offsetTop)
              .css("left", el.offsetLeft)
              .css("maxWidth", el.offsetWidth)
              .css("height", el.offsetHeight);
          }, 500);
        }
      }
    },
    clearError: function(el) {
      var $el = $(el);
      var display = $el.data("restore-display-mode");
      $el.data("restore-display-mode", null);

      if (display === "inline" || display === "inline-block") {
        if (display)
          $el.css("display", display);
        $(el.nextSibling).filter(".htmlwidgets-error").remove();
      } else if (display === "block"){
        $el.css("visibility", "inherit");
        $(el.nextSibling).filter(".htmlwidgets-error").remove();
      }
    },
    sizing: {}
  };

  // Called by widget bindings to register a new type of widget. The definition
  // object can contain the following properties:
  // - name (required) - A string indicating the binding name, which will be
  //   used by default as the CSS classname to look for.
  // - initialize (optional) - A function(el) that will be called once per
  //   widget element; if a value is returned, it will be passed as the third
  //   value to renderValue.
  // - renderValue (required) - A function(el, data, initValue) that will be
  //   called with data. Static contexts will cause this to be called once per
  //   element; Shiny apps will cause this to be called multiple times per
  //   element, as the data changes.
  window.HTMLWidgets.widget = function(definition) {
    if (!definition.name) {
      throw new Error("Widget must have a name");
    }
    if (!definition.type) {
      throw new Error("Widget must have a type");
    }
    // Currently we only support output widgets
    if (definition.type !== "output") {
      throw new Error("Unrecognized widget type '" + definition.type + "'");
    }
    // TODO: Verify that .name is a valid CSS classname

    // Support new-style instance-bound definitions. Old-style class-bound
    // definitions have one widget "object" per widget per type/class of
    // widget; the renderValue and resize methods on such widget objects
    // take el and instance arguments, because the widget object can't
    // store them. New-style instance-bound definitions have one widget
    // object per widget instance; the definition that's passed in doesn't
    // provide renderValue or resize methods at all, just the single method
    //   factory(el, width, height)
    // which returns an object that has renderValue(x) and resize(w, h).
    // This enables a far more natural programming style for the widget
    // author, who can store per-instance state using either OO-style
    // instance fields or functional-style closure variables (I guess this
    // is in contrast to what can only be called C-style pseudo-OO which is
    // what we required before).
    if (definition.factory) {
      definition = createLegacyDefinitionAdapter(definition);
    }

    if (!definition.renderValue) {
      throw new Error("Widget must have a renderValue function");
    }

    // For static rendering (non-Shiny), use a simple widget registration
    // scheme. We also use this scheme for Shiny apps/documents that also
    // contain static widgets.
    window.HTMLWidgets.widgets = window.HTMLWidgets.widgets || [];
    // Merge defaults into the definition; don't mutate the original definition.
    var staticBinding = extend({}, defaults, definition);
    overrideMethod(staticBinding, "find", function(superfunc) {
      return function(scope) {
        var results = superfunc(scope);
        // Filter out Shiny outputs, we only want the static kind
        return filterByClass(results, "html-widget-output", false);
      };
    });
    window.HTMLWidgets.widgets.push(staticBinding);

    if (shinyMode) {
      // Shiny is running. Register the definition with an output binding.
      // The definition itself will not be the output binding, instead
      // we will make an output binding object that delegates to the
      // definition. This is because we foolishly used the same method
      // name (renderValue) for htmlwidgets definition and Shiny bindings
      // but they actually have quite different semantics (the Shiny
      // bindings receive data that includes lots of metadata that it
      // strips off before calling htmlwidgets renderValue). We can't
      // just ignore the difference because in some widgets it's helpful
      // to call this.renderValue() from inside of resize(), and if
      // we're not delegating, then that call will go to the Shiny
      // version instead of the htmlwidgets version.

      // Merge defaults with definition, without mutating either.
      var bindingDef = extend({}, defaults, definition);

      // This object will be our actual Shiny binding.
      var shinyBinding = new Shiny.OutputBinding();

      // With a few exceptions, we'll want to simply use the bindingDef's
      // version of methods if they are available, otherwise fall back to
      // Shiny's defaults. NOTE: If Shiny's output bindings gain additional
      // methods in the future, and we want them to be overrideable by
      // HTMLWidget binding definitions, then we'll need to add them to this
      // list.
      delegateMethod(shinyBinding, bindingDef, "getId");
      delegateMethod(shinyBinding, bindingDef, "onValueChange");
      delegateMethod(shinyBinding, bindingDef, "onValueError");
      delegateMethod(shinyBinding, bindingDef, "renderError");
      delegateMethod(shinyBinding, bindingDef, "clearError");
      delegateMethod(shinyBinding, bindingDef, "showProgress");

      // The find, renderValue, and resize are handled differently, because we
      // want to actually decorate the behavior of the bindingDef methods.

      shinyBinding.find = function(scope) {
        var results = bindingDef.find(scope);

        // Only return elements that are Shiny outputs, not static ones
        var dynamicResults = results.filter(".html-widget-output");

        // It's possible that whatever caused Shiny to think there might be
        // new dynamic outputs, also caused there to be new static outputs.
        // Since there might be lots of different htmlwidgets bindings, we
        // schedule execution for later--no need to staticRender multiple
        // times.
        if (results.length !== dynamicResults.length)
          scheduleStaticRender();

        return dynamicResults;
      };

      // Wrap renderValue to handle initialization, which unfortunately isn't
      // supported natively by Shiny at the time of this writing.

      shinyBinding.renderValue = function(el, data) {
        Shiny.renderDependencies(data.deps);
        // Resolve strings marked as javascript literals to objects
        if (!(data.evals instanceof Array)) data.evals = [data.evals];
        for (var i = 0; data.evals && i < data.evals.length; i++) {
          window.HTMLWidgets.evaluateStringMember(data.x, data.evals[i]);
        }
        if (!bindingDef.renderOnNullValue) {
          if (data.x === null) {
            el.style.visibility = "hidden";
            return;
          } else {
            el.style.visibility = "inherit";
          }
        }
        if (!elementData(el, "initialized")) {
          initSizing(el);

          elementData(el, "initialized", true);
          if (bindingDef.initialize) {
            var rect = el.getBoundingClientRect();
            var result = bindingDef.initialize(el, rect.width, rect.height);
            elementData(el, "init_result", result);
          }
        }
        bindingDef.renderValue(el, data.x, elementData(el, "init_result"));
        evalAndRun(data.jsHooks.render, elementData(el, "init_result"), [el, data.x]);
      };

      // Only override resize if bindingDef implements it
      if (bindingDef.resize) {
        shinyBinding.resize = function(el, width, height) {
          // Shiny can call resize before initialize/renderValue have been
          // called, which doesn't make sense for widgets.
          if (elementData(el, "initialized")) {
            bindingDef.resize(el, width, height, elementData(el, "init_result"));
          }
        };
      }

      Shiny.outputBindings.register(shinyBinding, bindingDef.name);
    }
  };

  var scheduleStaticRenderTimerId = null;
  function scheduleStaticRender() {
    if (!scheduleStaticRenderTimerId) {
      scheduleStaticRenderTimerId = setTimeout(function() {
        scheduleStaticRenderTimerId = null;
        window.HTMLWidgets.staticRender();
      }, 1);
    }
  }

  // Render static widgets after the document finishes loading
  // Statically render all elements that are of this widget's class
  window.HTMLWidgets.staticRender = function() {
    var bindings = window.HTMLWidgets.widgets || [];
    forEach(bindings, function(binding) {
      var matches = binding.find(document.documentElement);
      forEach(matches, function(el) {
        var sizeObj = initSizing(el, binding);

        var getSize = function(el) {
          if (sizeObj) {
            return {w: sizeObj.getWidth(), h: sizeObj.getHeight()}
          } else {
            var rect = el.getBoundingClientRect();
            return {w: rect.width, h: rect.height}
          }
        };

        if (hasClass(el, "html-widget-static-bound"))
          return;
        el.className = el.className + " html-widget-static-bound";

        var initResult;
        if (binding.initialize) {
          var size = getSize(el);
          initResult = binding.initialize(el, size.w, size.h);
          elementData(el, "init_result", initResult);
        }

        if (binding.resize) {
          var lastSize = getSize(el);
          var resizeHandler = function(e) {
            var size = getSize(el);
            if (size.w === 0 && size.h === 0)
              return;
            if (size.w === lastSize.w && size.h === lastSize.h)
              return;
            lastSize = size;
            binding.resize(el, size.w, size.h, initResult);
          };

          on(window, "resize", resizeHandler);

          // This is needed for cases where we're running in a Shiny
          // app, but the widget itself is not a Shiny output, but
          // rather a simple static widget. One example of this is
          // an rmarkdown document that has runtime:shiny and widget
          // that isn't in a render function. Shiny only knows to
          // call resize handlers for Shiny outputs, not for static
          // widgets, so we do it ourselves.
          if (window.jQuery) {
            window.jQuery(document).on(
              "shown.htmlwidgets shown.bs.tab.htmlwidgets shown.bs.collapse.htmlwidgets",
              resizeHandler
            );
            window.jQuery(document).on(
              "hidden.htmlwidgets hidden.bs.tab.htmlwidgets hidden.bs.collapse.htmlwidgets",
              resizeHandler
            );
          }

          // This is needed for the specific case of ioslides, which
          // flips slides between display:none and display:block.
          // Ideally we would not have to have ioslide-specific code
          // here, but rather have ioslides raise a generic event,
          // but the rmarkdown package just went to CRAN so the
          // window to getting that fixed may be long.
          if (window.addEventListener) {
            // It's OK to limit this to window.addEventListener
            // browsers because ioslides itself only supports
            // such browsers.
            on(document, "slideenter", resizeHandler);
            on(document, "slideleave", resizeHandler);
          }
        }

        var scriptData = document.querySelector("script[data-for='" + el.id + "'][type='application/json']");
        if (scriptData) {
          var data = JSON.parse(scriptData.textContent || scriptData.text);
          // Resolve strings marked as javascript literals to objects
          if (!(data.evals instanceof Array)) data.evals = [data.evals];
          for (var k = 0; data.evals && k < data.evals.length; k++) {
            window.HTMLWidgets.evaluateStringMember(data.x, data.evals[k]);
          }
          binding.renderValue(el, data.x, initResult);
          evalAndRun(data.jsHooks.render, initResult, [el, data.x]);
        }
      });
    });

    invokePostRenderHandlers();
  }


  function has_jQuery3() {
    if (!window.jQuery) {
      return false;
    }
    var $version = window.jQuery.fn.jquery;
    var $major_version = parseInt($version.split(".")[0]);
    return $major_version >= 3;
  }

  /*
  / Shiny 1.4 bumped jQuery from 1.x to 3.x which means jQuery's
  / on-ready handler (i.e., $(fn)) is now asyncronous (i.e., it now
  / really means $(setTimeout(fn)).
  / https://jquery.com/upgrade-guide/3.0/#breaking-change-document-ready-handlers-are-now-asynchronous
  /
  / Since Shiny uses $() to schedule initShiny, shiny>=1.4 calls initShiny
  / one tick later than it did before, which means staticRender() is
  / called renderValue() earlier than (advanced) widget authors might be expecting.
  / https://github.com/rstudio/shiny/issues/2630
  /
  / For a concrete example, leaflet has some methods (e.g., updateBounds)
  / which reference Shiny methods registered in initShiny (e.g., setInputValue).
  / Since leaflet is privy to this life-cycle, it knows to use setTimeout() to
  / delay execution of those methods (until Shiny methods are ready)
  / https://github.com/rstudio/leaflet/blob/18ec981/javascript/src/index.js#L266-L268
  /
  / Ideally widget authors wouldn't need to use this setTimeout() hack that
  / leaflet uses to call Shiny methods on a staticRender(). In the long run,
  / the logic initShiny should be broken up so that method registration happens
  / right away, but binding happens later.
  */
  function maybeStaticRenderLater() {
    if (shinyMode && has_jQuery3()) {
      window.jQuery(window.HTMLWidgets.staticRender);
    } else {
      window.HTMLWidgets.staticRender();
    }
  }

  if (document.addEventListener) {
    document.addEventListener("DOMContentLoaded", function() {
      document.removeEventListener("DOMContentLoaded", arguments.callee, false);
      maybeStaticRenderLater();
    }, false);
  } else if (document.attachEvent) {
    document.attachEvent("onreadystatechange", function() {
      if (document.readyState === "complete") {
        document.detachEvent("onreadystatechange", arguments.callee);
        maybeStaticRenderLater();
      }
    });
  }


  window.HTMLWidgets.getAttachmentUrl = function(depname, key) {
    // If no key, default to the first item
    if (typeof(key) === "undefined")
      key = 1;

    var link = document.getElementById(depname + "-" + key + "-attachment");
    if (!link) {
      throw new Error("Attachment " + depname + "/" + key + " not found in document");
    }
    return link.getAttribute("href");
  };

  window.HTMLWidgets.dataframeToD3 = function(df) {
    var names = [];
    var length;
    for (var name in df) {
        if (df.hasOwnProperty(name))
            names.push(name);
        if (typeof(df[name]) !== "object" || typeof(df[name].length) === "undefined") {
            throw new Error("All fields must be arrays");
        } else if (typeof(length) !== "undefined" && length !== df[name].length) {
            throw new Error("All fields must be arrays of the same length");
        }
        length = df[name].length;
    }
    var results = [];
    var item;
    for (var row = 0; row < length; row++) {
        item = {};
        for (var col = 0; col < names.length; col++) {
            item[names[col]] = df[names[col]][row];
        }
        results.push(item);
    }
    return results;
  };

  window.HTMLWidgets.transposeArray2D = function(array) {
      if (array.length === 0) return array;
      var newArray = array[0].map(function(col, i) {
          return array.map(function(row) {
              return row[i]
          })
      });
      return newArray;
  };
  // Split value at splitChar, but allow splitChar to be escaped
  // using escapeChar. Any other characters escaped by escapeChar
  // will be included as usual (including escapeChar itself).
  function splitWithEscape(value, splitChar, escapeChar) {
    var results = [];
    var escapeMode = false;
    var currentResult = "";
    for (var pos = 0; pos < value.length; pos++) {
      if (!escapeMode) {
        if (value[pos] === splitChar) {
          results.push(currentResult);
          currentResult = "";
        } else if (value[pos] === escapeChar) {
          escapeMode = true;
        } else {
          currentResult += value[pos];
        }
      } else {
        currentResult += value[pos];
        escapeMode = false;
      }
    }
    if (currentResult !== "") {
      results.push(currentResult);
    }
    return results;
  }
  // Function authored by Yihui/JJ Allaire
  window.HTMLWidgets.evaluateStringMember = function(o, member) {
    var parts = splitWithEscape(member, '.', '\\');
    for (var i = 0, l = parts.length; i < l; i++) {
      var part = parts[i];
      // part may be a character or 'numeric' member name
      if (o !== null && typeof o === "object" && part in o) {
        if (i == (l - 1)) { // if we are at the end of the line then evalulate
          if (typeof o[part] === "string")
            o[part] = tryEval(o[part]);
        } else { // otherwise continue to next embedded object
          o = o[part];
        }
      }
    }
  };

  // Retrieve the HTMLWidget instance (i.e. the return value of an
  // HTMLWidget binding's initialize() or factory() function)
  // associated with an element, or null if none.
  window.HTMLWidgets.getInstance = function(el) {
    return elementData(el, "init_result");
  };

  // Finds the first element in the scope that matches the selector,
  // and returns the HTMLWidget instance (i.e. the return value of
  // an HTMLWidget binding's initialize() or factory() function)
  // associated with that element, if any. If no element matches the
  // selector, or the first matching element has no HTMLWidget
  // instance associated with it, then null is returned.
  //
  // The scope argument is optional, and defaults to window.document.
  window.HTMLWidgets.find = function(scope, selector) {
    if (arguments.length == 1) {
      selector = scope;
      scope = document;
    }

    var el = scope.querySelector(selector);
    if (el === null) {
      return null;
    } else {
      return window.HTMLWidgets.getInstance(el);
    }
  };

  // Finds all elements in the scope that match the selector, and
  // returns the HTMLWidget instances (i.e. the return values of
  // an HTMLWidget binding's initialize() or factory() function)
  // associated with the elements, in an array. If elements that
  // match the selector don't have an associated HTMLWidget
  // instance, the returned array will contain nulls.
  //
  // The scope argument is optional, and defaults to window.document.
  window.HTMLWidgets.findAll = function(scope, selector) {
    if (arguments.length == 1) {
      selector = scope;
      scope = document;
    }

    var nodes = scope.querySelectorAll(selector);
    var results = [];
    for (var i = 0; i < nodes.length; i++) {
      results.push(window.HTMLWidgets.getInstance(nodes[i]));
    }
    return results;
  };

  var postRenderHandlers = [];
  function invokePostRenderHandlers() {
    while (postRenderHandlers.length) {
      var handler = postRenderHandlers.shift();
      if (handler) {
        handler();
      }
    }
  }

  // Register the given callback function to be invoked after the
  // next time static widgets are rendered.
  window.HTMLWidgets.addPostRenderHandler = function(callback) {
    postRenderHandlers.push(callback);
  };

  // Takes a new-style instance-bound definition, and returns an
  // old-style class-bound definition. This saves us from having
  // to rewrite all the logic in this file to accomodate both
  // types of definitions.
  function createLegacyDefinitionAdapter(defn) {
    var result = {
      name: defn.name,
      type: defn.type,
      initialize: function(el, width, height) {
        return defn.factory(el, width, height);
      },
      renderValue: function(el, x, instance) {
        return instance.renderValue(x);
      },
      resize: function(el, width, height, instance) {
        return instance.resize(width, height);
      }
    };

    if (defn.find)
      result.find = defn.find;
    if (defn.renderError)
      result.renderError = defn.renderError;
    if (defn.clearError)
      result.clearError = defn.clearError;

    return result;
  }
})();
</script>
<script>/* el is the div, holding the rgl object as el.rglinstance,
     which holds x as el.rglinstance.scene
   x is the JSON encoded rglwidget.
*/


HTMLWidgets.widget({

  name: 'rglWebGL',

  type: 'output',

  factory: function(el, width, height) {
    el.width = width;
    el.height = height;
    var rgl = new rglwidgetClass(),
        onchangeselection = function(e) {
          for (var i = 0; i < rgl.scene.crosstalk.sel_handle.length; i++)
            rgl.clearBrush(except = e.rglSubsceneId);
          rgl.selection(e, false);
        },
        onchangefilter = function(e) {
          rgl.selection(e, true);
        };
    
    return { 
      renderValue: function(x) {
        var i, pel, player, groups,
            inShiny = (typeof Shiny !== "undefined");
      
        x.crosstalk.group = groups = [].concat(x.crosstalk.group);
        x.crosstalk.id = [].concat(x.crosstalk.id);
        x.crosstalk.key = [].concat(x.crosstalk.key);
        x.crosstalk.sel_handle = new Array(groups.length);
        x.crosstalk.fil_handle = new Array(groups.length);
        x.crosstalk.selection = [];
        for (i = 0; i < groups.length; i++) {
          x.crosstalk.sel_handle[i] = new crosstalk.SelectionHandle(groups[i], {sharedId: x.crosstalk.id[i]});
          x.crosstalk.sel_handle[i].on("change", onchangeselection);
          x.crosstalk.fil_handle[i] = new crosstalk.FilterHandle(groups[i], {sharedId: x.crosstalk.id[i]});
          x.crosstalk.fil_handle[i].on("change", onchangefilter);
        }
        if (inShiny) {
          // Shiny calls this multiple times, so we need extra cleanup
          // between
          rgl.sphere = undefined;
        }
        rgl.initialize(el, x);
        rgl.initGL();
  
  /* We might have been called after (some of) the players were rendered.
     We need to make sure we respond to their initial values. */

        if (typeof x.players !== "undefined") {
          var players = [].concat(x.players);
          for (i = 0; i < players.length; i++) {
            pel = document.getElementById(players[i]);
            if (pel) {
              player = pel.rglPlayer;
              if (player && (!player.initialized || inShiny)) {
                rgl.Player(pel, player);
                player.initialized = true;
              }
            }
          }
        }
        rgl.drag = 0;
        rgl.drawScene();
      },

      resize: function(width, height) {
        el.width = width;
        el.height = height;
        el.rglinstance.resize(el);
        el.rglinstance.drawScene();
      }
    };
  }
});
</script>
<style type="text/css">.rglPlayer {
width: auto;
height: auto;
}
.rglPlayer .rgl-button {
width: auto;
display: inline-block;
font-size: 75%;
}
.rglPlayer .rgl-slider {
display: inline-block;
width: 30%;
}
.rglPlayer .rgl-label {
display: inline;
padding-left: 6px;
padding-right: 6px;
}
</style>
<script>//// To generate the help pages for this library, use

// jsdoc --template /usr/local/lib/node_modules/foodoc/template *.src.js -R README.md -c JSDoc.json

// To test, set environment variable RGL_DEBUGGING=true
// before building.

/* globals rglwidgetClass: true */

/**
 * The class of an rgl widget
 * @class
*/
rglwidgetClass = function() {
    this.canvas = null;
    this.userMatrix = new CanvasMatrix4();
    this.types = [];
    this.prMatrix = new CanvasMatrix4();
    this.mvMatrix = new CanvasMatrix4();
    this.vp = null;
    this.prmvMatrix = null;
    this.origs = null;
    this.gl = null;
    this.scene = null;
    this.select = {state: "inactive", subscene: null, region: {p1: {x:0, y:0}, p2: {x:0, y:0}}};
    this.drawing = false;
};

    rglwidgetClass.f_is_lit = 1;
    rglwidgetClass.f_is_smooth = 2;
    rglwidgetClass.f_has_texture = 4;
    rglwidgetClass.f_depth_sort = 8;
    rglwidgetClass.f_fixed_quads = 16;
    rglwidgetClass.f_is_transparent = 32;
    rglwidgetClass.f_is_lines = 64;
    rglwidgetClass.f_sprites_3d = 128;
    rglwidgetClass.f_is_subscene = 256;
    rglwidgetClass.f_is_clipplanes = 512;
    rglwidgetClass.f_fixed_size = 1024;
    rglwidgetClass.f_is_points = 2048;
    rglwidgetClass.f_is_twosided = 4096;
    rglwidgetClass.f_fat_lines = 8192;
    rglwidgetClass.f_is_brush = 16384;
    rglwidgetClass.f_has_fog = 32768;
    rglwidgetClass.f_rotating = 65536;
    
    rglwidgetClass.prototype.fogNone = 0;
    rglwidgetClass.prototype.fogLinear = 1;
    rglwidgetClass.prototype.fogExp = 2;
    rglwidgetClass.prototype.fogExp2 = 3;

    /**
     * Methods related to obsolete approaches.
     * @name ___OBSOLETE_METHODS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Start the writeWebGL scene. This is only used by writeWebGL; rglwidget has
       no debug element.
     */
    rglwidgetClass.prototype.start = function() {
      if (typeof this.prefix !== "undefined") {
        this.debugelement = document.getElementById(this.prefix + "debug");
        this.debug("");
      }
      this.drag = 0;
      this.drawScene();
    };
</script>
<script>    /**
     * Utility methods
     * @name ___UTILITY_METHODS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Multiply matrix by vector
     * @returns {number[]}
     * @param M {number[][]} Left operand
     * @param v {number[]} Right operand
     */
    rglwidgetClass.multMV = function(M, v) {
        return [ M.m11 * v[0] + M.m12 * v[1] + M.m13 * v[2] + M.m14 * v[3],
                 M.m21 * v[0] + M.m22 * v[1] + M.m23 * v[2] + M.m24 * v[3],
                 M.m31 * v[0] + M.m32 * v[1] + M.m33 * v[2] + M.m34 * v[3],
                 M.m41 * v[0] + M.m42 * v[1] + M.m43 * v[2] + M.m44 * v[3]
               ];
    };
    
    /**
     * Multiply row vector by Matrix
     * @returns {number[]}
     * @param v {number[]} left operand
     * @param M {number[][]} right operand
     */
    rglwidgetClass.multVM = function(v, M) {
        return [ M.m11 * v[0] + M.m21 * v[1] + M.m31 * v[2] + M.m41 * v[3],
                 M.m12 * v[0] + M.m22 * v[1] + M.m32 * v[2] + M.m42 * v[3],
                 M.m13 * v[0] + M.m23 * v[1] + M.m33 * v[2] + M.m43 * v[3],
                 M.m14 * v[0] + M.m24 * v[1] + M.m34 * v[2] + M.m44 * v[3]
               ];
    };
    
    /**
     * Euclidean length of a vector
     * @returns {number}
     * @param v {number[]}
     */
    rglwidgetClass.vlen = function(v) {
      return Math.sqrt(rglwidgetClass.dotprod(v, v));
    };

    /**
     * Dot product of two vectors
     * @instance rglwidgetClass
     * @returns {number}
     * @param a {number[]}
     * @param b {number[]}
     */
    rglwidgetClass.dotprod = function(a, b) {
      return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
    };

    /**
     * Cross product of two vectors
     * @returns {number[]}
     * @param a {number[]}
     * @param b {number[]}
     */
    rglwidgetClass.xprod = function(a, b) {
      return [a[1]*b[2] - a[2]*b[1],
          a[2]*b[0] - a[0]*b[2],
          a[0]*b[1] - a[1]*b[0]];
    };

    /**
     * Bind vectors or matrices by columns
     * @returns {number[][]}
     * @param a {number[][]}
     * @param b {number[]|number[][]}
     */
    rglwidgetClass.cbind = function(a, b) {
      if (b.length < a.length)
        b = rglwidgetClass.repeatToLen(b, a.length);
      else if (a.length < b.length)
        a = rglwidgetClass.repeatToLen(a, b.length);
      return a.map(function(currentValue, index) {
            return [].concat(currentValue).concat(b[index]);
      });
    };

    /**
     * Swap elements
     * @returns {any[]}
     * @param a {any[]}
     * @param i {number} Element to swap
     * @param j {number} Other element to swap
     */
    rglwidgetClass.swap = function(a, i, j) {
      var temp = a[i];
      a[i] = a[j];
      a[j] = temp;
    };

    /**
     * Flatten a matrix into a vector
     * @returns {any[]}
     * @param a {any[][]}
     */
    rglwidgetClass.flatten = function(arr, result) {
      var value;
      if (typeof result === "undefined") result = [];
      for (var i = 0, length = arr.length; i < length; i++) {
        value = arr[i];
        if (Array.isArray(value)) {
          rglwidgetClass.flatten(value, result);
        } else {
          result.push(value);
        }
      }
      return result;
    };

    /**
     * set element of 1d or 2d array as if it was flattened.
     * Column major, zero based!
     * @returns {any[]|any[][]}
     * @param {any[]|any[][]} a - array
     * @param {number} i - element
     * @param {any} value
     */
    rglwidgetClass.prototype.setElement = function(a, i, value) {
      if (Array.isArray(a[0])) {
        var dim = a.length,
            col = Math.floor(i/dim),
            row = i % dim;
        a[row][col] = value;
      } else {
        a[i] = value;
      }
    };

    /**
     * Transpose an array
     * @returns {any[][]}
     * @param {any[][]} a
     */
    rglwidgetClass.prototype.transpose = function(a) {
      var newArray = [],
          n = a.length,
          m = a[0].length,
          i;
      for(i = 0; i < m; i++){
        newArray.push([]);
      }

      for(i = 0; i < n; i++){
        for(var j = 0; j < m; j++){
          newArray[j].push(a[i][j]);
        }
      }
      return newArray;
    };

    /**
     * Calculate sum of squares of a numeric vector
     * @returns {number}
     * @param {number[]} x
     */
    rglwidgetClass.prototype.sumsq = function(x) {
      var result = 0, i;
      for (i=0; i < x.length; i++)
        result += x[i]*x[i];
      return result;
    };

    /**
     * Convert a matrix to a CanvasMatrix4
     * @returns {CanvasMatrix4}
     * @param {number[][]|number[]} mat
     */
    rglwidgetClass.prototype.toCanvasMatrix4 = function(mat) {
      if (mat instanceof CanvasMatrix4)
        return mat;
      var result = new CanvasMatrix4();
      mat = rglwidgetClass.flatten(this.transpose(mat));
      result.load(mat);
      return result;
    };

    /**
     * Convert an R-style numeric colour string to an rgb vector
     * @returns {number[]}
     * @param {string} s
     */
    /* jshint bitwise:false */ 
    rglwidgetClass.prototype.stringToRgb = function(s) {
      s = s.replace("#", "");
      var bigint = parseInt(s, 16);
      return [((bigint >> 16) & 255)/255,
              ((bigint >> 8) & 255)/255,
               (bigint & 255)/255];
    };
    /* jshint bitwise:true */
    /**
     * Which list does a particular id come from?
     * @returns { string }
     * @param {number} id The id to look up.
     */
    rglwidgetClass.prototype.whichList = function(id) {
      var obj = this.getObj(id),
          flags = obj.flags;
        if (obj.type === "light")
          return "lights";
        if (rglwidgetClass.isSet(flags, rglwidgetClass.f_is_subscene))
            return "subscenes";
        if (rglwidgetClass.isSet(flags, rglwidgetClass.f_is_clipplanes))
            return "clipplanes";
        if (rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent))
            return "transparent";
        return "opaque";
    };
    
    /**
     * Take a component-by-component product of two 3 vectors
     * @returns {number[]}
     * @param {number[]} x
     * @param {number[]} y
     */
    rglwidgetClass.prototype.componentProduct = function(x, y) {
      if (typeof y === "undefined") {
        this.alertOnce("Bad arg to componentProduct");
      }
      var result = new Float32Array(3), i;
      for (i = 0; i<3; i++)
        result[i] = x[i]*y[i];
      return result;
    };

    /**
     * Get next higher power of two
     * @returns { number }
     * @param { number } value - input value
     */
    rglwidgetClass.prototype.getPowerOfTwo = function(value) {
      var pow = 1;
      while(pow<value) {
        pow *= 2;
      }
      return pow;
    };

    /**
     * Unique entries
     * @returns { any[] }
     * @param { any[] } arr - An array
     */
    rglwidgetClass.prototype.unique = function(arr) {
      arr = [].concat(arr);
      return arr.filter(function(value, index, self) {
        return self.indexOf(value) === index;
      });
    };

    /**
     * Shallow compare of arrays
     * @returns { boolean }
     * @param { any[] } a - An array
     * @param { any[] } b - Another array
     */
    rglwidgetClass.prototype.equalArrays = function(a, b) {
      return a === b || (a && b &&
                      a.length === b.length &&
                      a.every(function(v, i) {return v === b[i];}));
    };
    
    /**
     * Repeat an array to a desired length
     * @returns {any[]}
     * @param {any | any[]} arr The input array
     * @param {number} len The desired output length
     */
    rglwidgetClass.repeatToLen = function(arr, len) {
      arr = [].concat(arr);
      if (!arr.length) 
        throw new RangeError("array is length 0");
      while (arr.length < len/2)
        arr = arr.concat(arr);
      return arr.concat(arr.slice(0, len - arr.length));
    };

    /**
     * Give a single alert message, not to be repeated.
     * @param {string} msg  The message to give.
     */
    rglwidgetClass.prototype.alertOnce = function(msg) {
      // debugger;
      if (typeof this.alerted !== "undefined")
        return;
      this.alerted = true;
      alert(msg);
    };

    /**
     * Get an object by id number.
     * @returns { Object }
     * @param {number} id
     */
    rglwidgetClass.prototype.getObj = function(id) {
      if (typeof id !== "number") {
        this.alertOnce("getObj id is "+typeof id);
      }
      return this.scene.objects[id];
    };

    /**
     * Get ids of a particular type from a subscene or the whole scene
     * @returns { number[] }
     * @param {string} type What type of object?
     * @param {number} subscene  Which subscene?  If not given, find in the whole scene
     */
    rglwidgetClass.prototype.getIdsByType = function(type, subscene) {
      var
        result = [], i, self = this, ids;
      if (typeof subscene === "undefined") {
        Object.keys(this.scene.objects).forEach(
          function(key) {
            key = parseInt(key, 10);
            if (self.getObj(key).type === type)
              result.push(key);
          });
      } else {
        ids = this.getObj(subscene).objects;
        for (i=0; i < ids.length; i++) {
          if (this.getObj(ids[i]).type === type) {
            result.push(ids[i]);
          }
        }
      }
      return result;
    };

    /**
     * Get a particular material property for an obj
     * @returns { any }
     * @param {object} obj  Which object?
     * @param {string} property Which material property?
     */
    rglwidgetClass.prototype.getMaterial = function(obj, property) {
      var mat;
      if (typeof obj.material === "undefined")
        console.error("material undefined");
      mat = obj.material[property];
      if (typeof mat === "undefined")
          mat = this.scene.material[property];
      return mat;
    };
    
   /**
     * Get a particular material property for an id
     * @returns { any }
     * @param {number} id  Which object?
     * @param {string} property Which material property?
     */
    rglwidgetClass.prototype.getMaterialId = function(id, property) {
      var obj = this.getObj(id);
      return this.getMaterial(obj, property);
    };

    rglwidgetClass.prototype.getAdj = function (obj, index, offset, text) {
      var len, pos;
      if (typeof obj.pos === "undefined")
        return rglwidgetClass.flatten(obj.adj);
      pos = obj.pos[index % obj.pos.length];
      switch(pos) {
        case 0: return [0.5, 0.5, 0.5];
        case 1: return [0.5, 1 + offset, 0.5];
        case 3: return [0.5, -offset, 0.5];
        case 5: return [0.5, 0.5, -offset];
        case 6: return [0.5, 0.5, 1 + offset];
        case 2: 
        case 4: if (typeof text === "undefined")
                  len = 1;
                else
                  len = text.length;
                if (pos === 2)
                  return [1 + offset/len, 0.5, 0.5];
                else
                  return [-offset/len, 0.5, 0.5];
      }
    };

    /**
     * Count clipping planes in a scene
     * @returns {number}
     */
    rglwidgetClass.prototype.countClipplanes = function() {
      var self = this,
          bound = 0;
      
      Object.keys(this.scene.objects).forEach(
        function(key) {
          var obj = self.getObj(parseInt(key, 10));
          if (obj.type === "clipplanes")
            bound = bound + obj.offsets.length;
        });
      return bound;
    };

    /**
     * Count clipping plane objects in a scene
     * @returns {number}
     */
    rglwidgetClass.prototype.countClipplaneObjs = function() {
      return this.countObjs("clipplanes");
    };

    /**
     * Count lights in a scene
     * @returns { number }
     */
    rglwidgetClass.prototype.countLights = function() {
      return this.countObjs("light");
    };

    /**
     * Count objects of specific type in a scene
     * @returns { number }
     * @param { string } type - Type of object to count
     */
    rglwidgetClass.prototype.countObjs = function(type) {
      var self = this,
          bound = 0;

      Object.keys(this.scene.objects).forEach(
        function(key) {
          if (self.getObj(parseInt(key, 10)).type === type)
            bound = bound + 1;
        });
      return bound;
    };

    /**
     * Display a debug message
     * @param { string } msg - The message to display
     * @param { Object } [img] - Image to insert before message
     */
    rglwidgetClass.prototype.debug = function(msg, img) {
      if (typeof this.debugelement !== "undefined" && this.debugelement !== null) {
        this.debugelement.innerHTML = msg;
        if (typeof img !== "undefined") {
          this.debugelement.insertBefore(img, this.debugelement.firstChild);
        }
      } else if (msg !== "")
        alert(msg);
    };

    /**
     * If we are in an ioslides or slidy presentation, get the
     * DOM element of the current slide
     * @returns { Object }
     */
    rglwidgetClass.prototype.getSlide = function() {
      var result = this.el, done = false;
      while (result && !done && this.scene.context.rmarkdown) {
      	switch(this.scene.context.rmarkdown) {
          case "ioslides_presentation":
            if (result.tagName === "SLIDE") return result;
            break;
          case "slidy_presentation":
            if (result.tagName === "DIV" && result.classList.contains("slide"))
              return result;
            break;
          default: return null;
      	}
      	result = result.parentElement;
      }
      return null;
    };

    /**
     * Is this scene visible in the browser?
     * @returns { boolean }
     */
    rglwidgetClass.prototype.isInBrowserViewport = function() {
      var rect = this.canvas.getBoundingClientRect(),
          windHeight = (window.innerHeight || document.documentElement.clientHeight),
          windWidth = (window.innerWidth || document.documentElement.clientWidth);
      if (this.scene.context && this.scene.context.rmarkdown !== null) {
      	if (this.slide)
      	  return (this.scene.context.rmarkdown === "ioslides_presentation" &&
      	          this.slide.classList.contains("current")) ||
      	         (this.scene.context.rmarkdown === "slidy_presentation" &&
      	          !this.slide.classList.contains("hidden"));
      }
      return (
      	rect.top >= -windHeight &&
      	rect.left >= -windWidth &&
      	rect.bottom <= 2*windHeight &&
      	rect.right <= 2*windWidth);
    };
    
    rglwidgetClass.keydiff = function(obj1, obj2) {
      var keys = Object.keys(obj1), i, result = [];
      for (i=0;i<keys.length;i++) {
        if (typeof obj1[keys[i]] !== "undefined" &&
            typeof obj2[keys[i]] === "undefined")
          result.push(keys[i]);
      }
      return result;
    };

    rglwidgetClass.isSet = function(flags, flag) {
      /* jshint bitwise: false */
      return (flags & flag) !== 0;
      /* jshint bitwise: true */
    };
    
    rglwidgetClass.prototype.user2window = function(p, subid) {
      var m, v = [].concat(p);
      
      this.setmvMatrix(subid);
      m = new CanvasMatrix4(this.mvMatrix);
      v = rglwidgetClass.multVM(v, m);
      this.setprMatrix(subid);
      m = new CanvasMatrix4(this.prMatrix);
      v = rglwidgetClass.multVM(v, m);
      this.getViewport(subid);
      v[0] = v[0]*0.5/v[3] + 0.5 + this.vp.x/this.vp.width;
      v[1] = v[1]*0.5/v[3] + 0.5 + this.vp.y/this.vp.height;
      v[2] = (1 + v[2]/v[3])*0.5;
      return v.slice(0, 3);
    };

    /**
     * Andrew's convex hull algorithm. 
     * From Wikipedia, used under Creative Commons Attribution-ShareAlike License
     * @returns { Array } Indices of convex hull points
     */
    rglwidgetClass.chull = function(points) {
      function cross(a, b, o) {
        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
      }
        
      points.sort(function(a, b) {
        return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
      });

      var lower = [], upper = [];
      for (var i = 0; i < points.length; i++) {
        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {
          lower.pop();
        }
        lower.push(points[i]);
      }

      for (i = points.length - 1; i >= 0; i--) {
        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {
          upper.pop();
        }
        upper.push(points[i]);
      }

      upper.pop();
      lower.pop();
      return lower.concat(upper);
    };
    
    /**
     * Round number to given precision
     * @param { number } x
     * @param { number } digits
     * @returns { number } 
     */
    rglwidgetClass.signif = function(x, digits) { 
      return parseFloat(x.toPrecision(digits));
    };
      
    /**
     * Check for NA, NaN, undefined, or null
     * @param x
     * @returns { bool }
     */
    rglwidgetClass.missing = function(x) {
      return x !== "-Inf" && x !== "Inf" &&
             (isNaN(x) || x === null || typeof(x) === "undefined");
    };

    /**
     * Write matrix to log
     * @param M
     */
    rglwidgetClass.logMatrix = function(M) {
      console.log("matrix(c("+M.m11+","+M.m12+","+M.m13+","+M.m14+",\n"+
                              M.m21+","+M.m22+","+M.m23+","+M.m24+",\n"+
                              M.m31+","+M.m32+","+M.m33+","+M.m34+",\n"+
                              M.m41+","+M.m42+","+M.m43+","+M.m44+"), byrow=TRUE, ncol=4)");
    };
    
    /**
     * Write vector to log
     * @param {vector} v
     */
     
    rglwidgetClass.logVec3 = function(v) {
      console.log("c("+v[0]+","+v[1]+","+v[2]+")");
    };
    
    /**
     * Sum two vectors
     * @param {vector} x
     * @param {vector} y
     */
     rglwidgetClass.vsum = function(x, y) {
       var i, result = [].concat(x);
       for (i = 0; i < y.length; i++)
         result[i] += y[i];
        return result;
     };
     
    /**
     * difference of two vectors
     * @param {vector} x
     * @param {vector} y
     */
     rglwidgetClass.vdiff = function(x, y) {
        return rglwidgetClass.vsum(x, rglwidgetClass.vscale(y, -1));
     };

    /**
     * Scale a vector
     * @param {number} s
     * @param {vector} x
     */
     rglwidgetClass.vscale = function(x, s) {
       var i, result = [].concat(x);
       for (i = 0; i < x.length; i++)
         result[i] *= s;
        return result;
     };
    
    /**
     * Normalize a vector
     * @param {vector} v
     */
    rglwidgetClass.normalize = function(v) {
      return rglwidgetClass.vscale(v, 1/rglwidgetClass.vlen(v));
    };
    
    /**
     * Compute the dimensions of a regular array
     * without checking that it is regular
     */ 
    rglwidgetClass.arrayDim = function(arr) {
      var result = [];
      while (typeof arr.length !== "undefined") {
        result = result.concat(arr.length);
        arr = arr[0];
      }
      return result;
    };
</script>
<script>/**
     * Methods related to buffered data
     * @name ___METHODS_FOR_BUFFERS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
    /**
     * Detect rglBuffered object
     * @param { Object } obj - vertices or similar 
     */
    rglwidgetClass.prototype.isBuffered = function(obj) {
      return typeof obj === "string";
    };

    /* The next two functions are taken from 
     
     https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding
     
     They were written by Mozilla Contributors and dedicated
     to the public domain under CC0. */
     
    /* Array of bytes to Base64 string decoding */
    rglwidgetClass.prototype.b64ToUint6 = function(nChr) {
      return nChr > 64 && nChr < 91 ? nChr - 65 : 
             nChr > 96 && nChr < 123 ? nChr - 71 : 
             nChr > 47 && nChr < 58 ? nChr + 4 : 
             nChr === 43 ? 62 : 
             nChr === 47 ? 63 : 
             0;
    };

    /* jshint bitwise:false */
    rglwidgetClass.prototype.base64DecToArr = function(sBase64, nBlocksSize) {
      var sB64Enc = sBase64.replace(/[^A-Za-z0-9\+\/]/g, ""),
        nInLen = sB64Enc.length, 
        nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2, 
        taBytes = new Uint8Array(nOutLen);
      for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
        nMod4 = nInIdx & 3;
        nUint24 |= this.b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 6 * (3 - nMod4);
        if (nMod4 === 3 || nInLen - nInIdx === 1) {
          for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
            taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
          }
          nUint24 = 0;
        }
      }
      return taBytes;
    };
    /* jshint bitwise:true */
    
    rglwidgetClass.prototype.getArrayBuffer = function(base64) {
      return this.base64DecToArr(base64, 4).buffer;
    };

    rglwidgetClass.prototype.getBufferedData = function(v) {
      return this.readAccessor(parseInt(v, 10), this.scene.buffer);
    };
    
    rglwidgetClass.prototype.readAccessor = function(acc, buf) {
      var typeSignedByte = 5120, 
          typeUnsignedByte = 5121, 
          typeSignedShort = 5122, 
          typeUnsignedShort = 5123, 
          typeSignedInt = 5124, 
          typeUnsignedInt = 5125, 
          typeFloat = 5126, 
          typeDouble = 5130, 
          accessor = buf.accessors[acc], 
          bufferView = buf.bufferViews[accessor.bufferView], 
          buffer = buf.buffers[bufferView.buffer], 
          bytes, 
          lens = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
          }, 
          rowsizes = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 2,
            MAT3: 3,
            MAT4: 4
          }, 
          offset = 0, 
          len = lens[accessor.type], 
          rowsize = rowsizes[accessor.type], 
          count = len * accessor.count, 
          nrows = count / rowsize, 
          values, arr = [], row, i, j, k;
          
      if (typeof buffer.bytes === "string") 
        buffer.bytes = this.getArrayBuffer(buffer.bytes);
        
      bytes = buffer.bytes;
      
      if (typeof accessor.byteOffset !== "undefined") 
        offset += accessor.byteOffset;
        
      if (typeof bufferView.byteOffset !== "undefined") 
        offset += bufferView.byteOffset;
        
      switch (accessor.componentType) {
       case typeSignedByte:
        values = new Int8Array(buffer.bytes, offset, count);
        break;

       case typeUnsignedByte:
        values = new Uint8Array(buffer.bytes, offset, count);
        break;

       case typeSignedShort:
        values = new Int16Array(buffer.bytes, offset, count);
        break;

       case typeUnsignedShort:
        values = new Uint16Array(buffer.bytes, offset, count);
        break;

       case typeSignedInt:
        values = new Int32Array(buffer.bytes, offset, count);
        break;

       case typeUnsignedInt:
        values = new Uint32Array(buffer.bytes, offset, count);
        break;

       case typeFloat:
        values = new Float32Array(buffer.bytes, offset, count);
        break;

       case typeDouble:
        values = new Float64Array(buffer.bytes, offset, count);
        break;
      }

      /* This is all very inefficient, but is convenient
             to work with the old code. */
      k = 0;
      for (i = 0; i < nrows; i++) {
        row = [];
        for (j = 0; j < rowsize; j++) {
          if (accessor.normalized) {
            switch(accessor.componentType) {
              case typeSignedByte:
                row.push(Math.max(values[k++]/127, -1.0));
                break;
              case typeSignedShort:
                row.push(Math.max(values[k++]/32767, -1.0));
                break;
              case typeUnsignedByte:
                row.push(values[k++]/255);
                break;
              case typeUnsignedShort:
                row.push(values[k++]/65535);
                break;
            }
          } else
            row.push(values[k++]);
        }
        arr.push(row);
      }
      return arr;
    };
    
    rglwidgetClass.prototype.expandBufferedFields = function(obj) {
      /* this list needs to match the one in convertScene.R */
      var fields = ["vertices", "normals", "indices", 
                    "texcoords", "colors", "centers"], i, field;
      for (i = 0; i < fields.length; i++) {
        field = obj[fields[i]];
        if (this.isBuffered(field))
          obj[fields[i]] = this.getBufferedData(field);
      }
    };
</script>
<script>    /**
     * Methods related to subscenes
     * @name ___METHODS_FOR_SUBSCENES___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */

    /**
     * Is a particular id in a subscene?
     * @returns { boolean }
     * @param {number} id Which id?
     * @param {number} subscene Which subscene id?
     */
    rglwidgetClass.prototype.inSubscene = function(id, subscene) {
      return this.getObj(subscene).objects.indexOf(id) > -1;
    };

    /**
     * Translate from window coordinates to viewport coordinates
     * @returns { Object } translated coordinates
     * @param { number } subsceneid - which subscene to use?
     * @param { Object } coords - point to translate
     */
    rglwidgetClass.prototype.translateCoords = function(subsceneid, coords) {
      var viewport = this.getObj(subsceneid).par3d.viewport;
      return {x: coords.x - viewport.x*this.canvas.width,
              y: coords.y - viewport.y*this.canvas.height};
    };

    /**
     * Check whether point is in viewport of subscene
     * @returns {boolean}
     * @param { Object } coords - screen coordinates of point
     * @param { number } subsceneid - subscene to check
     */
    rglwidgetClass.prototype.inViewport = function(coords, subsceneid) {
      var viewport = this.getObj(subsceneid).par3d.viewport,
        x0 = coords.x - viewport.x*this.canvas.width,
        y0 = coords.y - viewport.y*this.canvas.height;
      return 0 <= x0 && x0 <= viewport.width*this.canvas.width &&
             0 <= y0 && y0 <= viewport.height*this.canvas.height;
    };

    /**
     * Find which subscene contains a point
     * @returns { number } subscene id
     * @param { Object } coords - coordinates of point
     */
    rglwidgetClass.prototype.whichSubscene = function(coords) {
      var self = this,
          recurse = function(subsceneid) {
            var subscenes = self.getChildSubscenes(subsceneid), i, id;
            for (i=0; i < subscenes.length; i++) {
              id = recurse(subscenes[i]);
              if (typeof(id) !== "undefined")
                return(id);
            }
            if (self.inViewport(coords, subsceneid))
              return(subsceneid);
            else
              return undefined;
          },
          rootid = this.scene.rootSubscene,
          result = recurse(rootid);
      if (typeof(result) === "undefined")
        result = rootid;
      return result;
    };

    /**
     * Add an id to a subscene.
     * @param {number} id Which id?
     * @param {number} subscene Which subscene id?
     */
    rglwidgetClass.prototype.addToSubscene = function(id, subscene) {
      var thelist,
          thesub = this.getObj(subscene),
          ids = [id],
          obj = this.getObj(id), i;
      if (typeof obj !== "undefined" && typeof (obj.newIds) !== "undefined") {
        ids = ids.concat(obj.newIds);
      }
      thesub.objects = [].concat(thesub.objects);
      for (i = 0; i < ids.length; i++) {
        id = ids[i];
        if (thesub.objects.indexOf(id) === -1) {
          thelist = this.whichList(id);
          thesub.objects.push(id);
          thesub[thelist].push(id);
        }
      }
    };

    /**
     * Delete an id from a subscene
     * @param { number } id - the id to add
     * @param { number } subscene - the id of the subscene
     */
    rglwidgetClass.prototype.delFromSubscene = function(id, subscene) {
      var thelist,
          thesub = this.getObj(subscene),
          obj = this.getObj(id),
          ids = [id], i, j;
      if (typeof obj !== "undefined" && typeof (obj.newIds) !== "undefined")
        ids = ids.concat(obj.newIds);
      thesub.objects = [].concat(thesub.objects); // It might be a scalar
      for (j=0; j<ids.length;j++) {
        id = ids[j];
        i = thesub.objects.indexOf(id);
        if (i > -1) {
          thesub.objects.splice(i, 1);
          thelist = this.whichList(id);
          i = thesub[thelist].indexOf(id);
          thesub[thelist].splice(i, 1);
        }
      }
    };

    /**
     * Set the ids in a subscene
     * @param { number[] } ids - the ids to set
     * @param { number } subsceneid - the id of the subscene
     */
    rglwidgetClass.prototype.setSubsceneEntries = function(ids, subsceneid) {
      var sub = this.getObj(subsceneid);
      sub.objects = ids;
      this.initSubscene(subsceneid);
    };

    /**
     * Get the ids in a subscene
     * @returns {number[]}
     * @param { number } subscene - the id of the subscene
     */
    rglwidgetClass.prototype.getSubsceneEntries = function(subscene) {
      return this.getObj(subscene).objects;
    };

    /**
     * Get the ids of the subscenes within a subscene
     * @returns { number[] }
     * @param { number } subscene - the id of the subscene
     */
    rglwidgetClass.prototype.getChildSubscenes = function(subscene) {
      return this.getObj(subscene).subscenes;
    };

    /**
     * Find a particular subscene by inheritance
     * @returns { number } id of subscene to use
     * @param { number } subsceneid - child subscene
     * @param { string } type - type of inheritance:  "projection" or "model"
     */
    rglwidgetClass.prototype.useid = function(subsceneid, type) {
      var sub = this.getObj(subsceneid);
      if (sub.embeddings[type] === "inherit")
        return(this.useid(sub.parent, type));
      else
        return subsceneid;
    };

    /**
     * Find bboxdeco for a subscene
     * @returns { number } id of bboxdeco, or undefined if none
     * @param { number } sub- subscene
     */
    rglwidgetClass.prototype.getBBoxDeco = function(sub) {
      var objects = sub.objects, i, obj;
      for (i = 0; i < objects.length; i++) {
        obj = this.getObj(objects[i]);
        if (obj.type === "bboxdeco")
          return obj;
      }
      if (sub.parent) 
        return this.getBBoxDeco(this.getObj(sub.parent));
      else
        return undefined;
    };
</script>
<script>    /**
     * Methods related to shaders
     * @name ___METHODS_FOR_SHADERS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Get flags that will end up as shader defines.
     * Static method so it can be called from R
     */
    rglwidgetClass.getDefFlags = function(flags, type, normals, round_points) {
      var f = {};
      f.fat_lines = rglwidgetClass.isSet(flags, rglwidgetClass.f_fat_lines);
      f.fixed_quads = rglwidgetClass.isSet(flags, rglwidgetClass.f_fixed_quads);
      f.fixed_size = rglwidgetClass.isSet(flags, rglwidgetClass.f_fixed_size);
      f.has_fog = rglwidgetClass.isSet(flags, rglwidgetClass.f_has_fog);
      f.has_normals = (typeof normals !== "undefined") ||
                        type === "spheres";
      f.has_texture = rglwidgetClass.isSet(flags, rglwidgetClass.f_has_texture);
      f.is_brush = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_brush);
      f.is_lines = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_lines);
      f.is_lit = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_lit);
      f.is_points = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_points);
      f.is_transparent = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent);
      f.is_twosided = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_twosided);
      f.needs_vnormal = !rglwidgetClass.isSet(flags, rglwidgetClass.f_sprites_3d) &&
        (f.is_lit && !f.fixed_quads && !f.is_brush) || (f.is_twosided && f.has_normals);
      f.rotating = rglwidgetClass.isSet(flags, rglwidgetClass.f_rotating);
      f.round_points = round_points;
      return f;
    };
     
    
    /**
     * Generate the defines for the shader code for an object.
     * 
     * This is a static method so it can be called from R.
     * 
     * @returns {string}
     * @param  id - id of object
     * @param  type - type of object
     * @param  flags - object flags
     * @param  nclipplanes - number of clipping planes in scene 
     *         (may not all be active)
     * @param  nlights - number of lights in scene (ditto)
     * @param  normals - normals for object
     * @param  pointSize - point size for object 
     * @param  textype - texture type for object 
     * @param  antialias - use antialiasing?
     */
    rglwidgetClass.getDefines = function(id, type, flags,
      nclipplanes, nlights, normals, pointSize, textype,
      texmode, texenvmap, antialias, fl) {
      var
        title, defines;
      
      if (typeof fl === "undefined")
        fl = rglwidgetClass.getDefFlags(flags, type, normals, antialias);
        
      title = "  /* ****** "+type+" object "+id+" shader ****** */\n";
      
      defines = "#define NCLIPPLANES " + nclipplanes + "\n"+
                "#define NLIGHTS " + nlights + "\n";
      
      if (fl.fat_lines)
        defines = defines + "#define FAT_LINES 1\n";
      
      if (fl.fixed_quads)
        defines = defines + "#define FIXED_QUADS 1\n";

      if (fl.fixed_size)
        defines = defines + "#define FIXED_SIZE 1\n";

      if (fl.has_fog)
        defines = defines + "#define HAS_FOG 1\n";
        
      if (fl.has_normals)
        defines = defines + "#define HAS_NORMALS 1\n";
        
      if (fl.has_texture) {
        defines = defines + "#define HAS_TEXTURE 1\n";
        defines = defines + "#define TEXTURE_" + textype + "\n";
        defines = defines + "#define TEXMODE_" + texmode + "\n";
        if (texenvmap)
          defines = defines + "#define USE_ENVMAP 1\n";
      }
      
      if (fl.is_brush)
        defines = defines + "#define IS_BRUSH 1\n";  

      if (type === "linestrip")
        defines = defines + "#define IS_LINESTRIP 1\n";         

      if (fl.is_lit)
        defines = defines + "#define IS_LIT 1\n"; 
      
      if (fl.is_points) {
        defines = defines + "#define IS_POINTS 1\n";
        defines = defines + "#define POINTSIZE " + Number.parseFloat(pointSize).toFixed(1) + "\n";
      }
        
      if (type === "sprites")
        defines = defines + "#define IS_SPRITES 1\n";
        
      if (type === "text")
        defines = defines + "#define IS_TEXT 1\n";

      if (fl.is_transparent)
        defines = defines + "#define IS_TRANSPARENT 1\n"; 
        
      if (fl.is_twosided)
        defines = defines + "#define IS_TWOSIDED 1\n";
        
      if (fl.needs_vnormal)
        defines = defines + "#define NEEDS_VNORMAL 1\n";

      if (fl.rotating)
        defines = defines + "#define ROTATING 1\n";
        
      if (fl.round_points)        
        defines = defines + "#define ROUND_POINTS 1\n";   

      // console.log(result);
      return title + defines;
    };

    /**
     * Create code for vertex and fragment shaders
     * @returns {Object}
     * @param { number } shaderType - gl code for shader type
     * @param { string } code - code for the shader
     */
    rglwidgetClass.prototype.getShaders = function(obj) {
      var header, 
        vertex = obj.userVertexShader, 
        fragment = obj.userFragmentShader;
      
      header = rglwidgetClass.getDefines(
        obj.id, obj.type, obj.flags, 
        this.countClipplanes(), this.countLights(), 
        obj.normals, 
        this.getMaterial(obj, "size"), 
        this.getMaterial(obj, "textype"),
        this.getMaterial(obj, "texmode"),
        this.getMaterial(obj, "texenvmap"),
        this.getMaterial(obj, "point_antialias"),
        obj.defFlags
      );

      if (typeof vertex === "undefined")
        vertex = rglwidgetClass.rgl_vertex_shader();
        
      if (typeof fragment === "undefined") 
        fragment = rglwidgetClass.rgl_fragment_shader();

//      console.log("vertex:");
//      console.log(header + vertex);
//      console.log("fragment:");
//      console.log(header + fragment);
      
      return {vertex: header + vertex,
              fragment: header + fragment};
    };
    
    
    /**
     * Call gl functions to create and compile shader from code
     * @returns {Object}
     * @param { number } shaderType - gl code for shader type
     * @param { string } code - code for the shader
     */
    rglwidgetClass.prototype.getShader = function(shaderType, code) {
        var gl = this.gl, shader;
        shader = gl.createShader(shaderType);
        gl.shaderSource(shader, code);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS) && !gl.isContextLost())
            alert(gl.getShaderInfoLog(shader));
        return shader;
    };

</script>
<script>rglwidgetClass.rgl_vertex_shader = function() {
return  "#line 2 1\n"+
"// File 1 is the vertex shader\n"+
"#ifdef GL_ES\n"+
"#ifdef GL_FRAGMENT_PRECISION_HIGH\n"+
"precision highp float;\n"+
"#else\n"+
"precision mediump float;\n"+
"#endif\n"+
"#endif\n"+
"\n"+
"attribute vec3 aPos;\n"+
"attribute vec4 aCol;\n"+
"uniform mat4 mvMatrix;\n"+
"uniform mat4 prMatrix;\n"+
"varying vec4 vCol;\n"+
"varying vec4 vPosition;\n"+
"\n"+
"#ifdef NEEDS_VNORMAL\n"+
"attribute vec3 aNorm;\n"+
"uniform mat4 normMatrix;\n"+
"varying vec4 vNormal;\n"+
"#endif\n"+
"\n"+
"#if defined(HAS_TEXTURE) || defined (IS_TEXT)\n"+
"attribute vec2 aTexcoord;\n"+
"varying vec2 vTexcoord;\n"+
"#endif\n"+
"\n"+
"#ifdef FIXED_SIZE\n"+
"uniform vec3 textScale;\n"+
"#endif\n"+
"\n"+
"#ifdef FIXED_QUADS\n"+
"attribute vec3 aOfs;\n"+
"#endif\n"+
"\n"+
"#ifdef IS_TWOSIDED\n"+
"#ifdef HAS_NORMALS\n"+
"varying float normz;\n"+
"uniform mat4 invPrMatrix;\n"+
"#else\n"+
"attribute vec3 aPos1;\n"+
"attribute vec3 aPos2;\n"+
"varying float normz;\n"+
"#endif\n"+
"#endif // IS_TWOSIDED\n"+
"\n"+
"#ifdef FAT_LINES\n"+
"attribute vec3 aNext;\n"+
"attribute vec2 aPoint;\n"+
"varying vec2 vPoint;\n"+
"varying float vLength;\n"+
"uniform float uAspect;\n"+
"uniform float uLwd;\n"+
"#endif\n"+
"\n"+
"#ifdef USE_ENVMAP\n"+
"varying vec3 vReflection;\n"+
"#endif\n"+
"\n"+
"void main(void) {\n"+
"  \n"+
"#ifndef IS_BRUSH\n"+
"#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG) || defined(USE_ENVMAP)\n"+
"  vPosition = mvMatrix * vec4(aPos, 1.);\n"+
"#endif\n"+
"  \n"+
"#ifndef FIXED_QUADS\n"+
"  gl_Position = prMatrix * vPosition;\n"+
"#endif\n"+
"#endif // !IS_BRUSH\n"+
"  \n"+
"#ifdef IS_POINTS\n"+
"  gl_PointSize = POINTSIZE;\n"+
"#endif\n"+
"  \n"+
"  vCol = aCol;\n"+
"  \n"+
"// USE_ENVMAP implies NEEDS_VNORMAL\n"+
"\n"+
"#ifdef NEEDS_VNORMAL\n"+
"  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\n"+
"#endif\n"+
"\n"+
"#ifdef USE_ENVMAP\n"+
"  vReflection = normalize(reflect(vPosition.xyz/vPosition.w, \n"+
"                        normalize(vNormal.xyz/vNormal.w)));\n"+
"#endif\n"+
"  \n"+
"#ifdef IS_TWOSIDED\n"+
"#ifdef HAS_NORMALS\n"+
"  /* normz should be calculated *after* projection */\n"+
"  normz = (invPrMatrix*vNormal).z;\n"+
"#else\n"+
"  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\n"+
"  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\n"+
"  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\n"+
"  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\n"+
"  normz = pos1.x*pos2.y - pos1.y*pos2.x;\n"+
"#endif\n"+
"#endif // IS_TWOSIDED\n"+
"  \n"+
"#ifdef NEEDS_VNORMAL\n"+
"  vNormal = vec4(normalize(vNormal.xyz), 1);\n"+
"#endif\n"+
"  \n"+
"#if defined(HAS_TEXTURE) || defined(IS_TEXT)\n"+
"  vTexcoord = aTexcoord;\n"+
"#endif\n"+
"  \n"+
"#if defined(FIXED_SIZE) && !defined(ROTATING)\n"+
"  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\n"+
"  pos = pos/pos.w;\n"+
"  gl_Position = pos + vec4(aOfs*textScale, 0.);\n"+
"#endif\n"+
"  \n"+
"#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\n"+
"  vec4 pos = mvMatrix * vec4(aPos, 1.);\n"+
"  pos = pos/pos.w + vec4(aOfs,  0.);\n"+
"  gl_Position = prMatrix*pos;\n"+
"#endif\n"+
"  \n"+
"#ifdef FAT_LINES\n"+
"  /* This code was inspired by Matt Deslauriers' code in \n"+
"   https://mattdesl.svbtle.com/drawing-lines-is-hard */\n"+
"  vec2 aspectVec = vec2(uAspect, 1.0);\n"+
"  mat4 projViewModel = prMatrix * mvMatrix;\n"+
"  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\n"+
"  currentProjected = currentProjected/currentProjected.w;\n"+
"  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\n"+
"  vec2 currentScreen = currentProjected.xy * aspectVec;\n"+
"  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\n"+
"  float len = uLwd;\n"+
"  vec2 dir = vec2(1.0, 0.0);\n"+
"  vPoint = aPoint;\n"+
"  vLength = length(nextScreen - currentScreen)/2.0;\n"+
"  vLength = vLength/(vLength + len);\n"+
"  if (vLength > 0.0) {\n"+
"    dir = normalize(nextScreen - currentScreen);\n"+
"  }\n"+
"  vec2 normal = vec2(-dir.y, dir.x);\n"+
"  dir.x /= uAspect;\n"+
"  normal.x /= uAspect;\n"+
"  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\n"+
"  gl_Position = currentProjected + offset;\n"+
"#endif\n"+
"  \n"+
"#ifdef IS_BRUSH\n"+
"  gl_Position = vec4(aPos, 1.);\n"+
"#endif\n"+
"}\n" ;};
rglwidgetClass.rgl_fragment_shader = function() {
return  "#line 2 2\n"+
"// File 2 is the fragment shader\n"+
"#ifdef GL_ES\n"+
"#ifdef GL_FRAGMENT_PRECISION_HIGH\n"+
"precision highp float;\n"+
"#else\n"+
"precision mediump float;\n"+
"#endif\n"+
"#endif\n"+
"varying vec4 vCol; // carries alpha\n"+
"varying vec4 vPosition;\n"+
"#if defined(HAS_TEXTURE) || defined (IS_TEXT)\n"+
"varying vec2 vTexcoord;\n"+
"uniform sampler2D uSampler;\n"+
"#endif\n"+
"\n"+
"#ifdef HAS_FOG\n"+
"uniform int uFogMode;\n"+
"uniform vec3 uFogColor;\n"+
"uniform vec4 uFogParms;\n"+
"#endif\n"+
"\n"+
"#if defined(IS_LIT) && !defined(FIXED_QUADS)\n"+
"varying vec4 vNormal;\n"+
"#endif\n"+
"\n"+
"#if NCLIPPLANES > 0\n"+
"uniform vec4 vClipplane[NCLIPPLANES];\n"+
"#endif\n"+
"\n"+
"#if NLIGHTS > 0\n"+
"uniform mat4 mvMatrix;\n"+
"#endif\n"+
"\n"+
"#ifdef IS_LIT\n"+
"uniform vec3 emission;\n"+
"uniform float shininess;\n"+
"#if NLIGHTS > 0\n"+
"uniform vec3 ambient[NLIGHTS];\n"+
"uniform vec3 specular[NLIGHTS]; // light*material\n"+
"uniform vec3 diffuse[NLIGHTS];\n"+
"uniform vec3 lightDir[NLIGHTS];\n"+
"uniform bool viewpoint[NLIGHTS];\n"+
"uniform bool finite[NLIGHTS];\n"+
"#endif\n"+
"#endif // IS_LIT\n"+
"\n"+
"#ifdef IS_TWOSIDED\n"+
"uniform bool front;\n"+
"varying float normz;\n"+
"#endif\n"+
"\n"+
"#ifdef FAT_LINES\n"+
"varying vec2 vPoint;\n"+
"varying float vLength;\n"+
"#endif\n"+
"\n"+
"#ifdef USE_ENVMAP\n"+
"varying vec3 vReflection;\n"+
"#endif\n"+
"\n"+
"void main(void) {\n"+
"  vec4 fragColor;\n"+
"#ifdef FAT_LINES\n"+
"  vec2 point = vPoint;\n"+
"  bool neg = point.y < 0.0;\n"+
"  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :\n"+
"                 -(point.y - vLength)/(1.0 - vLength);\n"+
"#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\n"+
"  if (neg && length(point) <= 1.0) discard;\n"+
"#endif\n"+
"  point.y = min(point.y, 0.0);\n"+
"  if (length(point) > 1.0) discard;\n"+
"#endif // FAT_LINES\n"+
"  \n"+
"#ifdef ROUND_POINTS\n"+
"  vec2 coord = gl_PointCoord - vec2(0.5);\n"+
"  if (length(coord) > 0.5) discard;\n"+
"#endif\n"+
"  \n"+
"#if NCLIPPLANES > 0\n"+
"  for (int i = 0; i < NCLIPPLANES; i++)\n"+
"    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\n"+
"#endif\n"+
"    \n"+
"#ifdef FIXED_QUADS\n"+
"    vec3 n = vec3(0., 0., 1.);\n"+
"#elif defined(IS_LIT)\n"+
"    vec3 n = normalize(vNormal.xyz);\n"+
"#endif\n"+
"    \n"+
"#ifdef IS_TWOSIDED\n"+
"    if ((normz <= 0.) != front) discard;\n"+
"#endif\n"+
"\n"+
"#ifdef IS_LIT\n"+
"    vec3 eye = normalize(-vPosition.xyz/vPosition.w);\n"+
"    vec3 lightdir;\n"+
"    vec4 colDiff;\n"+
"    vec3 halfVec;\n"+
"    vec4 lighteffect = vec4(emission, 0.);\n"+
"    vec3 col;\n"+
"    float nDotL;\n"+
"#ifdef FIXED_QUADS\n"+
"    n = -faceforward(n, n, eye);\n"+
"#endif\n"+
"    \n"+
"#if NLIGHTS > 0\n"+
"    // Simulate two-sided lighting\n"+
"    if (n.z < 0.0)\n"+
"      n = -n;\n"+
"    for (int i=0;i<NLIGHTS;i++) {\n"+
"      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\n"+
"      lightdir = lightDir[i];\n"+
"      if (!viewpoint[i]) {\n"+
"        if (finite[i]) {\n"+
"          lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\n"+
"        } else {\n"+
"          lightdir = (mvMatrix * vec4(lightdir, 0.)).xyz;\n"+
"        }\n"+
"      }\n"+
"      if (!finite[i]) {\n"+
"        halfVec = normalize(lightdir + eye);\n"+
"      } else {\n"+
"        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);\n"+
"        halfVec = normalize(lightdir + eye);\n"+
"      }\n"+
"      col = ambient[i];\n"+
"      nDotL = dot(n, lightdir);\n"+
"      col = col + max(nDotL, 0.) * colDiff.rgb;\n"+
"      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\n"+
"      lighteffect = lighteffect + vec4(col, colDiff.a);\n"+
"    }\n"+
"#endif\n"+
"    \n"+
"#else // not IS_LIT\n"+
"    vec4 colDiff = vCol;\n"+
"    vec4 lighteffect = colDiff;\n"+
"#endif\n"+
"    \n"+
"#ifdef IS_TEXT\n"+
"    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n"+
"#endif\n"+
"    \n"+
"#ifdef HAS_TEXTURE\n"+
"\n"+
"// These calculations use the definitions from \n"+
"// https://docs.gl/gl3/glTexEnv\n"+
"\n"+
"#ifdef USE_ENVMAP\n"+
"    float m = 2.0 * sqrt(dot(vReflection, vReflection) + 2.0*vReflection.z + 1.0);\n"+
"    vec4 textureColor = texture2D(uSampler, vReflection.xy / m + vec2(0.5, 0.5));\n"+
"#else\n"+
"    vec4 textureColor = texture2D(uSampler, vTexcoord);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXTURE_rgb\n"+
"\n"+
"#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n"+
"    textureColor = vec4(textureColor.rgb, lighteffect.a);\n"+
"#endif \n"+
"\n"+
"#ifdef TEXMODE_modulate\n"+
"    textureColor = lighteffect*vec4(textureColor.rgb, 1.);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_blend\n"+
"    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb, lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_add\n"+
"    textureColor = vec4(lighteffect.rgb + textureColor.rgb, lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#endif //TEXTURE_rgb\n"+
"        \n"+
"#ifdef TEXTURE_rgba\n"+
"\n"+
"#ifdef TEXMODE_replace\n"+
"// already done\n"+
"#endif \n"+
"\n"+
"#ifdef TEXMODE_modulate\n"+
"    textureColor = lighteffect*textureColor;\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_decal\n"+
"    textureColor = vec4((1. - textureColor.a)*lighteffect.rgb) +\n"+
"                     textureColor.a*textureColor.rgb, \n"+
"                     lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_blend\n"+
"    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb,\n"+
"                    lighteffect.a*textureColor.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_add\n"+
"    textureColor = vec4(lighteffect.rgb + textureColor.rgb,\n"+
"                    lighteffect.a*textureColor.a);\n"+
"#endif\n"+
"    \n"+
"#endif //TEXTURE_rgba\n"+
"    \n"+
"#ifdef TEXTURE_alpha\n"+
"    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n"+
"\n"+
"#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n"+
"    textureColor = vec4(lighteffect.rgb, luminance);\n"+
"#endif \n"+
"\n"+
"#if defined(TEXMODE_modulate) || defined(TEXMODE_blend) || defined(TEXMODE_add)\n"+
"    textureColor = vec4(lighteffect.rgb, lighteffect.a*luminance);\n"+
"#endif\n"+
" \n"+
"#endif // TEXTURE_alpha\n"+
"    \n"+
"// The TEXTURE_luminance values are not from that reference    \n"+
"#ifdef TEXTURE_luminance\n"+
"    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n"+
"\n"+
"#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n"+
"    textureColor = vec4(luminance, luminance, luminance, lighteffect.a);\n"+
"#endif \n"+
"\n"+
"#ifdef TEXMODE_modulate\n"+
"    textureColor = vec4(luminance*lighteffect.rgb, lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_blend\n"+
"    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n"+
"                        lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_add\n"+
"    textureColor = vec4(luminance + lighteffect.rgb, lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#endif // TEXTURE_luminance\n"+
" \n"+
"    \n"+
"#ifdef TEXTURE_luminance_alpha\n"+
"    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n"+
"\n"+
"#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n"+
"    textureColor = vec4(luminance, luminance, luminance, textureColor.a);\n"+
"#endif \n"+
"\n"+
"#ifdef TEXMODE_modulate\n"+
"    textureColor = vec4(luminance*lighteffect.rgb, \n"+
"                        textureColor.a*lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_blend\n"+
"    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n"+
"                        textureColor.a*lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_add\n"+
"    textureColor = vec4(luminance + lighteffect.rgb, \n"+
"                        textureColor.a*lighteffect.a);\n"+
"\n"+
"#endif\n"+
"\n"+
"#endif // TEXTURE_luminance_alpha\n"+
"    \n"+
"    fragColor = textureColor;\n"+
"\n"+
"#elif defined(IS_TEXT)\n"+
"    if (textureColor.a < 0.1)\n"+
"      discard;\n"+
"    else\n"+
"      fragColor = textureColor;\n"+
"#else\n"+
"    fragColor = lighteffect;\n"+
"#endif // HAS_TEXTURE\n"+
"    \n"+
"#ifdef HAS_FOG\n"+
"    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))\n"+
"    // In Exp and Exp2: use density = density/far\n"+
"    // fogF will be the proportion of fog\n"+
"    // Initialize it to the linear value\n"+
"    float fogF;\n"+
"    if (uFogMode > 0) {\n"+
"      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);\n"+
"      if (uFogMode > 1)\n"+
"        fogF = mix(uFogParms.w, 1.0, fogF);\n"+
"      fogF = fogF*uFogParms.z;\n"+
"      if (uFogMode == 2)\n"+
"        fogF = 1.0 - exp(-fogF);\n"+
"      // Docs are wrong: use (density*c)^2, not density*c^2\n"+
"      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58\n"+
"      else if (uFogMode == 3)\n"+
"        fogF = 1.0 - exp(-fogF*fogF);\n"+
"      fogF = clamp(fogF, 0.0, 1.0);\n"+
"      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\n"+
"    } else gl_FragColor = fragColor;\n"+
"#else\n"+
"    gl_FragColor = fragColor;\n"+
"#endif // HAS_FOG\n"+
"    \n"+
"}\n" ;};
</script>
<script>    /**
     * Methods related to textures
     * @name ___METHODS_FOR_TEXTURES___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    rglwidgetClass.prototype.getTexFilter = function(filter) {
      var gl = this.gl || this.initGL();
      switch(filter) {
        case "nearest": return gl.NEAREST;
        case "linear": return gl.LINEAR;
        case "nearest.mipmap.nearest": return gl.NEAREST_MIPMAP_NEAREST;
        case "linear.mipmap.nearest": return gl.LINEAR_MIPMAP_NEAREST;
        case "nearest.mipmap.linear": return gl.NEAREST_MIPMAP_LINEAR;
        case "linear.mipmap.linear": return gl.LINEAR_MIPMAP_LINEAR;
        default: console.error("Unknown filter: "+filter);
      }
    };
     
    /**
     * Handle a texture after its image has been loaded
     * @param { Object } texture - the gl texture object
     * @param { Object } textureCanvas - the canvas holding the image
     */
    rglwidgetClass.prototype.handleLoadedTexture = function(texture, textureCanvas) {
      var gl = this.gl || this.initGL();
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureCanvas);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
      gl.generateMipmap(gl.TEXTURE_2D);

      gl.bindTexture(gl.TEXTURE_2D, null);
    };

    /**
     * Get maximum dimension of texture in current browser.
     * @returns {number}
     */
    rglwidgetClass.prototype.getMaxTexSize = function() {
      var gl = this.gl || this.initGL();	
      return Math.min(4096, gl.getParameter(gl.MAX_TEXTURE_SIZE));
    };
    
    /**
     * Load an image to a texture
     * @param { string } uri - The image location
     * @param { Object } texture - the gl texture object
     */
    rglwidgetClass.prototype.loadImageToTexture = function(uri, texture) {
      var canvas = this.textureCanvas,
          ctx = canvas.getContext("2d"),
          image = new Image(),
          self = this;

       image.onload = function() {

         var w = image.width,
             h = image.height,
             canvasX = self.getPowerOfTwo(w),
             canvasY = self.getPowerOfTwo(h),
             maxTexSize = self.getMaxTexSize();
         while (canvasX > 1 && canvasY > 1 && (canvasX > maxTexSize || canvasY > maxTexSize)) {
           canvasX /= 2;
           canvasY /= 2;
         }
         canvas.width = canvasX;
         canvas.height = canvasY;
         ctx.imageSmoothingEnabled = true;
         ctx.drawImage(image, 0, 0, canvasX, canvasY);
         self.handleLoadedTexture(texture, canvas);
         self.texturesLoading -= 1;
         if (!self.texturesLoading)
           self.drawScene();
       };
       if (!self.texturesLoading)
         self.texturesLoading = 0; // may have been undefined
       self.texturesLoading += 1;
       image.src = uri;
     };

    /**
     * Draw text to the texture canvas
     * @returns { Object } object with text measurements
     * @param { string } text - the text
     * @param { number } cex - expansion
     * @param { string } family - font family
     * @param { number } font - font number
     */
    rglwidgetClass.prototype.drawTextToCanvas = function(text, cex, family, font) {
       var canvasX, canvasY,
           scaling = 20,
           textColour = "white",

           backgroundColour = "rgba(0,0,0,0)",
           canvas = this.textureCanvas,
           ctx = canvas.getContext("2d"),
           i, textHeight = 0, textHeights = [], width, widths = [], 
           offsetx, offsety = 0, line, lines = [], offsetsx = [],
           offsetsy = [], lineoffsetsy = [], fontStrings = [],
           maxTexSize = this.getMaxTexSize(),
           getFontString = function(i) {
             textHeights[i] = scaling*cex[i];
             var fontString = textHeights[i] + "px",
                 family0 = family[i],
                 font0 = font[i];
             if (family0 === "sans")
               family0 = "sans-serif";
             else if (family0 === "mono")
               family0 = "monospace";
             fontString = fontString + " " + family0;
             if (font0 === 2 || font0 === 4)
               fontString = "bold " + fontString;
             if (font0 === 3 || font0 === 4)
               fontString = "italic " + fontString;
             return fontString;
           };
       cex = rglwidgetClass.repeatToLen(cex, text.length);
       family = rglwidgetClass.repeatToLen(family, text.length);
       font = rglwidgetClass.repeatToLen(font, text.length);

       canvasX = 1;
       line = -1;
       offsetx = maxTexSize;
       for (i = 0; i < text.length; i++)  {
         ctx.font = fontStrings[i] = getFontString(i);
         width = widths[i] = ctx.measureText(text[i]).width;
         if (offsetx + width > maxTexSize) {
           offsety = offsety + 2*textHeight;
           if (line >= 0)
             lineoffsetsy[line] = offsety;
           line += 1;
           if (offsety > maxTexSize)
             console.error("Too many strings for texture.");
           textHeight = 0;
           offsetx = 0;
         }
         textHeight = Math.max(textHeight, textHeights[i]);
         offsetsx[i] = offsetx;
         offsetx += width;
         canvasX = Math.max(canvasX, offsetx);
         lines[i] = line;
       }
       offsety = lineoffsetsy[line] = offsety + 2*textHeight;
       for (i = 0; i < text.length; i++) {
       	 offsetsy[i] = lineoffsetsy[lines[i]];
       }
       
       canvasX = this.getPowerOfTwo(canvasX);
       canvasY = this.getPowerOfTwo(offsety);

       canvas.width = canvasX;
       canvas.height = canvasY;

       ctx.fillStyle = backgroundColour;
       ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

       ctx.textBaseline = "alphabetic";
       for(i = 0; i < text.length; i++) {
         ctx.font = fontStrings[i];
         ctx.fillStyle = textColour;
         ctx.textAlign = "left";
         ctx.fillText(text[i], offsetsx[i],  offsetsy[i]);
       }
       return {canvasX:canvasX, canvasY:canvasY,
               widths:widths, textHeights:textHeights,
               offsetsx:offsetsx, offsetsy:offsetsy};
     };

</script>
<script>    /**
     * Methods related to projections
     * @name ___METHODS_FOR_PROJECTIONS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Get the viewport
     */
     
    rglwidgetClass.prototype.getViewport = function(id) {
      var vp = this.getObj(id).par3d.viewport,
         x = vp.x*this.canvas.width,
         y = vp.y*this.canvas.height,
         width = vp.width*this.canvas.width,
         height = vp.height*this.canvas.height;
       this.vp = {x:x, y:y, width:width, height:height};
    };
    
    /**
     * Set the gl viewport and scissor test
     * @param { number } id - id of subscene
     */
    rglwidgetClass.prototype.setViewport = function(id) {
       var gl = this.gl || this.initGL();
       this.getViewport(id);
       gl.viewport(this.vp.x, this.vp.y, this.vp.width, this.vp.height);
       gl.scissor(this.vp.x, this.vp.y, this.vp.width, this.vp.height);
       gl.enable(gl.SCISSOR_TEST);
     };

    /**
     * Set the projection matrix for a subscene
     * @param { number } id - id of subscene
     */
    rglwidgetClass.prototype.setprMatrix = function(id) {
       var subscene = this.getObj(id),
          embedding = subscene.embeddings.projection;
       if (embedding === "replace")
         this.prMatrix.makeIdentity();
       else
         this.setprMatrix(subscene.parent);
       if (embedding === "inherit")
         return;
       // This is based on the Frustum::enclose code from geom.cpp
       var bbox = subscene.par3d.bbox,
           scale = subscene.par3d.scale,
           ranges = [(bbox[1]-bbox[0])*scale[0]/2,
                     (bbox[3]-bbox[2])*scale[1]/2,
                     (bbox[5]-bbox[4])*scale[2]/2],
           radius = Math.sqrt(this.sumsq(ranges))*1.1; // A bit bigger to handle labels
       if (radius <= 0) radius = 1;
       var observer = subscene.par3d.observer,
           distance = observer[2],
           FOV = subscene.par3d.FOV, ortho = FOV === 0,
           t = ortho ? 1 : Math.tan(FOV*Math.PI/360),
           near = distance - radius,
           far = distance + radius,
           hlen,
           aspect = this.vp.width/this.vp.height,
           z = subscene.par3d.zoom,
           userProjection = subscene.par3d.userProjection;
       if (far < 0.0)
         far = 1.0;
       if (near < far/100.0)
         near = far/100.0;
       this.frustum = {near:near, far:far};
       hlen = t*near;
       if (ortho) {
         if (aspect > 1)
           this.prMatrix.ortho(-hlen*aspect*z, hlen*aspect*z,
                          -hlen*z, hlen*z, near, far);
         else
           this.prMatrix.ortho(-hlen*z, hlen*z,
                          -hlen*z/aspect, hlen*z/aspect,
                          near, far);
       } else {
         if (aspect > 1)
           this.prMatrix.frustum(-hlen*aspect*z, hlen*aspect*z,
                          -hlen*z, hlen*z, near, far);
         else
           this.prMatrix.frustum(-hlen*z, hlen*z,
                          -hlen*z/aspect, hlen*z/aspect,
                          near, far);
       }
       this.prMatrix.multRight(userProjection);
     };

    /**
     * Set the model-view matrix for a subscene
     * @param { number } id - id of the subscene
     */
    rglwidgetClass.prototype.setmvMatrix = function(id) {
       var observer = this.getObj(id).par3d.observer;
       this.mvMatrix.makeIdentity();
       this.setmodelMatrix(id);
       this.mvMatrix.translate(-observer[0], -observer[1], -observer[2]);

     };

    /**
     * Set the model matrix for a subscene
     * @param { number } id - id of the subscene
     */
    rglwidgetClass.prototype.setmodelMatrix = function(id) {
      var subscene = this.getObj(id),
          embedding = subscene.embeddings.model;
      if (embedding === "replace") {
        var bbox = subscene.par3d.bbox,
            center = [(bbox[0]+bbox[1])/2,
                      (bbox[2]+bbox[3])/2,
                      (bbox[4]+bbox[5])/2];
        this.mvMatrix.translate(-center[0], -center[1], -center[2]);
      }
      if (embedding !== "inherit") {
        var scale = subscene.par3d.scale;
        this.mvMatrix.scale(scale[0], scale[1], scale[2]);
        this.mvMatrix.multRight( subscene.par3d.userMatrix );
      }
      if (embedding !== "replace")
        this.setmodelMatrix(subscene.parent);
     };

    /**
     * Set the normals matrix for a subscene
     * @param { number } subsceneid - id of the subscene
     */
     rglwidgetClass.prototype.setnormMatrix2 = function() {
       this.normMatrix = new CanvasMatrix4(this.mvMatrix);
       this.normMatrix.invert();
       this.normMatrix.transpose();
     };

    /**
     * Set the combined projection-model-view matrix
     */
    rglwidgetClass.prototype.setprmvMatrix = function() {
       this.prmvMatrix = new CanvasMatrix4( this.mvMatrix );
       this.prmvMatrix.multRight( this.prMatrix );
     };

    rglwidgetClass.prototype.setInvPrMatrix = function() {
      this.invPrMatrix = new CanvasMatrix4( this.prMatrix );
      this.invPrMatrix.invert();
      this.invPrMatrix.transpose();
    };
</script>
<script>    /**
     * Methods related to mouse handling
     * @name ___METHODS_FOR_MOUSE_HANDLING___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    rglwidgetClass.prototype.getCursor = function(mode) {
      switch(mode) {
        case "none": 
          return "none";
        case "trackball":
        case "xAxis":
        case "yAxis":
        case "zAxis":
        case "polar":
          return "grab";
        case "selecting":
          return "crosshair";
        case "fov":
        case "zoom":
          return "zoom-in";
        case "user":
          return "default";
      }
      return "dragging";
    };
    
    /**
     * Set mouse mode for a subscene
     * @param { string } mode - name of mode
     * @param { number } button - button number (0 to 4)
     * @param { number } subscene - subscene id number
     * @param { number } stayActive - if truthy, don't clear brush
     */
    rglwidgetClass.prototype.setMouseMode = function(mode, button, subscene, stayActive) {
      var sub = this.getObj(subscene),
          which = ["none", "left", "right", "middle", "wheel"][button];
      if (!stayActive && sub.par3d.mouseMode[which] === "selecting")
        this.clearBrush(null);
      sub.par3d.mouseMode[which] = mode;
      if (button === 1 || (button === 0 && mode !== "none"))
        this.canvas.style.cursor = this.getCursor(mode);
      if (button === 0 && mode !== "none")
        sub.needsBegin = mode;
    };

    /**
     * Compute mouse coordinates relative to current canvas
     * @returns { Object }
     * @param { Object } event - event object from mouse click
     */
    rglwidgetClass.prototype.relMouseCoords = function(event) {
      var rect = this.canvas.getBoundingClientRect();
      return {x:event.clientX-rect.left, y:event.clientY-rect.top};
    };
    
    /**
     * Send mouse selection to Shiny
     */
    rglwidgetClass.prototype.recordSelection = function(subid) {
      var result = {};
      if (typeof this.select !== "undefined" && 
          typeof this.select.state !== "undefined" &&
          this.select.state !== "inactive") {
        result = { subscene: subid,
                   state: this.select.state,
                   region: this.select.region
                 };
        this.setmvMatrix(subid);
        result.model = this.mvMatrix;
        this.setprMatrix(subid);
        result.proj = this.prMatrix;
        this.getViewport(subid);
        result.view = this.vp;
      } else
        result.state = "inactive";
      Shiny.setInputValue(this.scene.selectionInput + ":shinyMouse3d", result);
    }; 

    /**
     * Set mouse handlers for the scene
     */
    rglwidgetClass.prototype.setMouseHandlers = function() {
      var self = this, activeSubscene, handler,
          handlers = {}, drag = 0;

      handlers.rotBase = 0;

      self.screenToVector = function(x, y) {
        var viewport = self.getObj(activeSubscene).par3d.viewport,
          width = viewport.width*self.canvas.width,
          height = viewport.height*self.canvas.height,
          radius = Math.max(width, height)/2.0,
          cx = width/2.0,
          cy = height/2.0,
          px = (x-cx)/radius,
          py = (y-cy)/radius,
          plen = Math.sqrt(px*px+py*py);
        if (plen > 1.e-6) {
          px = px/plen;
          py = py/plen;
        }
        var angle = (Math.SQRT2 - plen)/Math.SQRT2*Math.PI/2,
          z = Math.sin(angle),
          zlen = Math.sqrt(1.0 - z*z);
        px = px * zlen;
        py = py * zlen;
        return [px, py, z];
      };

      handlers.trackballdown = function(x,y) {
        var activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            i, l = activeModel.par3d.listeners;
        handlers.rotBase = self.screenToVector(x, y);
        self.saveMat = [];
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.saveMat = new CanvasMatrix4(activeSub.par3d.userMatrix);
        }
        self.canvas.style.cursor = "grabbing";
      };

      handlers.trackballmove = function(x,y) {
        var rotCurrent = self.screenToVector(x,y),
            rotBase = handlers.rotBase,
            dot = rotBase[0]*rotCurrent[0] +
                  rotBase[1]*rotCurrent[1] +
                  rotBase[2]*rotCurrent[2],
            angle = Math.acos( dot/rglwidgetClass.vlen(rotBase)/rglwidgetClass.vlen(rotCurrent) )*180.0/Math.PI,
            axis = rglwidgetClass.xprod(rotBase, rotCurrent),
            objects = self.scene.objects,
            activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            l = activeModel.par3d.listeners,
            i;
        if (angle === 0.0)
          return;    
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.userMatrix.load(objects[l[i]].saveMat);
          activeSub.par3d.userMatrix.rotate(angle, axis[0], axis[1], axis[2]);
        }
        self.drawScene();
      };
      handlers.trackballend = 0;

      self.clamp = function(x, lo, hi) {
      	return Math.max(lo, Math.min(x, hi));
      };

      self.screenToPolar = function(x,y) {
        var viewport = self.getObj(activeSubscene).par3d.viewport,
          width = viewport.width*self.canvas.width,
          height = viewport.height*self.canvas.height,
    	  r = Math.min(width, height)/2,
    	  dx = self.clamp(x - width/2, -r, r),
    	  dy = self.clamp(y - height/2, -r, r);
    	  return [Math.asin(dx/r), Math.asin(-dy/r)];
      };

      handlers.polardown = function(x,y) {
        var activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            i, l = activeModel.par3d.listeners;
        handlers.dragBase = self.screenToPolar(x, y);
        self.saveMat = [];
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.saveMat = new CanvasMatrix4(activeSub.par3d.userMatrix);
          activeSub.camBase = [-Math.atan2(activeSub.saveMat.m13, activeSub.saveMat.m11),
                               Math.atan2(activeSub.saveMat.m32, activeSub.saveMat.m22)];
        }
        self.canvas.style.cursor = "grabbing";
      };

      handlers.polarmove = function(x,y) {
        var dragCurrent = self.screenToPolar(x,y),
            activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            objects = self.scene.objects,
            l = activeModel.par3d.listeners,
            i, j, changepos = [];
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          for (j=0; j<2; j++)
            changepos[j] = -(dragCurrent[j] - handlers.dragBase[j]);
          activeSub.par3d.userMatrix.makeIdentity();
          activeSub.par3d.userMatrix.rotate(changepos[0]*180/Math.PI, 0,-1,0);
          activeSub.par3d.userMatrix.multRight(objects[l[i]].saveMat);
          activeSub.par3d.userMatrix.rotate(changepos[1]*180/Math.PI, -1,0,0);
        }
        self.drawScene();
      };
      handlers.polarend = 0;

      handlers.axisdown = function(x) {
        handlers.rotBase = self.screenToVector(x, self.canvas.height/2);
        var activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            i, l = activeModel.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.saveMat = new CanvasMatrix4(activeSub.par3d.userMatrix);
        }
        self.canvas.style.cursor = "grabbing";
      };

      handlers.axismove = function(x) {
        var rotCurrent = self.screenToVector(x, self.canvas.height/2),
            rotBase = handlers.rotBase,
            angle = (rotCurrent[0] - rotBase[0])*180/Math.PI,
            rotMat = new CanvasMatrix4();
        rotMat.rotate(angle, handlers.axis[0], handlers.axis[1], handlers.axis[2]);
        var activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            i, l = activeModel.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.userMatrix.load(activeSub.saveMat);
          activeSub.par3d.userMatrix.multLeft(rotMat);
        }
        self.drawScene();
      };
      handlers.axisend = 0;

      handlers.y0zoom = 0;
      handlers.zoomdown = function(x, y) {
        var activeSub = self.getObj(activeSubscene),
          activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
          i, l = activeProjection.par3d.listeners;
        handlers.y0zoom = y;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.zoom0 = Math.log(activeSub.par3d.zoom);
        }
        self.canvas.style.cursor = "zoom-in";
      };
      handlers.zoommove = function(x, y) {
        var activeSub = self.getObj(activeSubscene),
            activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
            i, l = activeProjection.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.zoom = Math.exp(activeSub.zoom0 + (y-handlers.y0zoom)/self.canvas.height);
        }
        self.drawScene();
      };
      handlers.zoomend = 0;

      handlers.y0fov = 0;
      handlers.fovdown = function(x, y) {
        handlers.y0fov = y;
        var activeSub = self.getObj(activeSubscene),
          activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
          i, l = activeProjection.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.fov0 = activeSub.par3d.FOV;
        }
        self.canvas.style.cursor = "zoom-in";
      };
      handlers.fovmove = function(x, y) {
        var activeSub = self.getObj(activeSubscene),
            activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
            i, l = activeProjection.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.FOV = Math.max(1, Math.min(179, activeSub.fov0 +
             180*(y-handlers.y0fov)/self.canvas.height));
        }
        self.drawScene();
      };
      handlers.fovend = 0;
      
      handlers.selectingdown = function(x, y) {
      	var viewport = self.getObj(activeSubscene).par3d.viewport,
      	  width = viewport.width*self.canvas.width,
      	  height = viewport.height*self.canvas.height, 
          p = {x: 2.0*x/width - 1.0, y: 2.0*y/height - 1.0};
      	self.select.region = {p1: p, p2: p};
      	if (self.select.subscene && self.select.subscene !== activeSubscene)
      	  self.delFromSubscene(self.scene.brushId, self.select.subscene);
      	self.select.subscene = activeSubscene;
      	self.addToSubscene(self.scene.brushId, activeSubscene);
      	self.select.state = "changing";
      	if (typeof self.scene.brushId !== "undefined")
      	  self.getObj(self.scene.brushId).initialized = false;
      	if (typeof self.scene.selectionInput !== "undefined")
      	  self.recordSelection(activeSubscene); 
      	self.drawScene();
      	self.canvas.style.cursor = "crosshair";
      };
      
      handlers.selectingmove = function(x, y) {
      	var viewport = self.getObj(activeSubscene).par3d.viewport,
      	  width = viewport.width*self.canvas.width,
      	  height = viewport.height*self.canvas.height;
      	if (self.select.state === "inactive") 
      	  return;
      	self.select.region.p2 = {x: 2.0*x/width - 1.0, y: 2.0*y/height - 1.0};
      	if (typeof self.scene.brushId !== "undefined")
      	  self.getObj(self.scene.brushId).initialized = false;
      	if (typeof self.scene.selectionInput !== "undefined")
      	  self.recordSelection(activeSubscene);
      	self.drawScene();
      };
      
      handlers.selectingend = 0;
      /* jshint evil:true */
      handlers.userdown = function(x, y) {
        var sub = self.getObj(activeSubscene),
            code = sub.callbacks[drag].begin;
        if (code) {
          var fn = Function('"use strict";return (' + code + ')')();
          fn.call(self, x, y);
        }
      };
      
      handlers.usermove = function(x, y) {
        var sub = self.getObj(activeSubscene),
            code = sub.callbacks[drag].update;
        if (code) {
          var fn = Function('"use strict";return (' + code + ')')();
          fn.call(self, x, y);
        }
      };
      
      handlers.userend = function() {
        var sub = self.getObj(activeSubscene),
            code = sub.callbacks[drag].end;
        if (code) {
          var fn = Function('"use strict";return (' + code + ')')();
          fn.call(self);
        }
      };

      self.canvas.onpointerdown = function ( ev ){
        // pointers and mice differ in capture rules; 
        // act like a mouse.
        if (ev.target.hasPointerCapture(ev.pointerId))
          ev.target.releasePointerCapture(ev.pointerId);
          
        if (!ev.which) // Use w3c defns in preference to MS
        switch (ev.button) {
          case 0: ev.which = 1; break;
          case 1:
          case 4: ev.which = 2; break;
          case 2: ev.which = 3;
        }
        drag = ["none", "left", "middle", "right", "wheel"][ev.which];
        var coords = self.relMouseCoords(ev);
        coords.y = self.canvas.height-coords.y;
        activeSubscene = self.whichSubscene(coords);
        var sub = self.getObj(activeSubscene), f;
        handler = sub.par3d.mouseMode[drag];
        switch (handler) {
        case "xAxis":
          handler = "axis";
          handlers.axis = [1.0, 0.0, 0.0];
          break;
        case "yAxis":
          handler = "axis";
          handlers.axis = [0.0, 1.0, 0.0];
          break;
        case "zAxis":
          handler = "axis";
          handlers.axis = [0.0, 0.0, 1.0];
          break;
        }
        f = handlers[handler + "down"];
        if (f) {
          coords = self.translateCoords(activeSubscene, coords);
          f.call(self, coords.x, coords.y);
          ev.preventDefault();
        } else
          console.warn("Mouse handler '" + handler + "' is not implemented.");

      };

      self.canvas.onpointerup = function ( ev ){
        if ( !drag ) return;
        var f = handlers[handler + "end"];
        if (f) {
          f.call(self);
          ev.preventDefault();
        }
        drag = 0;
        handlers.onpointermove( ev );
      };

      self.canvas.onpointerout = self.canvas.onpointerup;

      handlers.onpointermove = function ( ev ) {
        var coords = self.relMouseCoords(ev), sub, f;
        coords.y = self.canvas.height - coords.y;
        if (ev.buttons === 0) {
          activeSubscene = self.whichSubscene(coords);
          drag = "none";
          sub = self.getObj(activeSubscene);
          handler = sub.par3d.mouseMode.none;
          if (handler !== "none") {
            if (sub.needsBegin) {
              f = handlers[handler + "down"];
              if (f) {
                coords = self.translateCoords(activeSubscene, coords);
                f.call(self, coords.x, coords.y);
              }
              sub.needsBegin = 0;
            }
            self.canvas.style.cursor = self.getCursor(sub.par3d.mouseMode.none);
          } else {
            self.canvas.style.cursor = self.getCursor(sub.par3d.mouseMode.left);  
            return;
          }
        }
        f = handlers[handler + "move"];
        if (f) {
          coords = self.translateCoords(activeSubscene, coords);
          f.call(self, coords.x, coords.y);
        }
      };
      

      self.canvas.onpointerenter = function() {
        self.canvas.addEventListener("pointermove",               handlers.onpointermove);
      };
      
      self.canvas.onpointerleave = function() {
        self.canvas.removeEventListener("pointermove",
          handlers.onpointermove);
      };

      handlers.setZoom = function(ds) {
        var i;
        if (typeof activeSubscene === "undefined")
          activeSubscene = self.scene.rootSubscene;
        var activeSub = self.getObj(activeSubscene),
            activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
            l = activeProjection.par3d.listeners;

        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.zoom *= ds;
        }
        self.drawScene();
      };
      
      handlers.pushwheel = function(ev) {
        ev.deltaY = -ev.deltaY;
        handlers.pullwheel(ev);
      };
      
      handlers.pullwheel = function(ev) {
        var del = 1.05;
        if (ev.shiftKey) del = 1.005;
        var ds = ev.deltaY < 0 ? del : (1 / del);
        handlers.setZoom(ds);
      };
      
      handlers.user2wheel = function(ev) {
        var sub = self.getObj(activeSubscene),
            code = sub.callbacks.wheel.rotate;
        if (code) {
          var fn = Function('"use strict";return (' + code + ')')();
          /* jshint evil:false */
          fn.call(self, ev.deltaY < 0 ? 1 : 2);
        }        
      };
        
      handlers.wheelHandler = function(ev) {
        var coords = self.relMouseCoords(ev);
        coords.y = self.canvas.height - coords.y;
        activeSubscene = self.whichSubscene(coords);
        var sub = self.getObj(activeSubscene), f,
            handler = sub.par3d.mouseMode.wheel,
            evlocal;
            
        ev.deltaY = ev.deltaY || ev.detail || ev.deltaX || ev.wheelDelta;
                      
        switch(handler) {
          case "none": break;
          case "push":
          case "pull":
          case "user2":
            f = handlers[handler + "wheel"];
            if (f) {
              evlocal = {};
              evlocal.deltaY = ev.deltaY;
              evlocal.shiftKey = ev.shiftKey;
              evlocal.preventDefault = function() { ev.preventDefault(); };
              f.call(self, evlocal);
            }
            break;
          default: 
            evlocal = {};
            evlocal.preventDefault = function() { ev.preventDefault(); };
            evlocal.which = 4;
            evlocal.clientX = self.canvas.width/2;
            evlocal.clientY = self.canvas.height/2;
            self.canvas.onpointerdown(evlocal);
            evlocal.clientX += ev.deltaX;
            evlocal.clientY += ev.deltaY;
            handlers.onpointermove(evlocal);
            self.canvas.onpointerup(evlocal);
        }
        ev.preventDefault();
      };
      
      handlers.get_finger_dist = function(ev) {
        var diffX = ev.touches[0].clientX - ev.touches[1].clientX,
            diffY = ev.touches[0].clientY - ev.touches[1].clientY;
        return Math.sqrt(diffX * diffX + diffY * diffY); 
      };
      
      handlers.touchstart = function(ev) {
        var touch = ev.touches[0],
          mouseEvent = new MouseEvent("pointerdown",
            {
              clientX: touch.clientX,
              clientY: touch.clientY
            });
        ev.preventDefault();
        if (ev.touches.length === 2) {
          var coords = self.relMouseCoords(touch);
          coords.y = self.canvas.height-coords.y;
          activeSubscene = self.whichSubscene(coords);
          handlers.finger_dist0 = handlers.get_finger_dist(ev);
          handlers.zoomdown(coords.x, coords.y);
        }
        self.dispatchEvent(mouseEvent);
      };
      
      handlers.touchend = function(ev) {
        var mouseEvent;
        ev.preventDefault();
        if (ev.touches.length === 1) {
          mouseEvent = new MouseEvent("pointerup", {});
          self.dispatchEvent(mouseEvent);
        }
      };
      
      handlers.touchmove = function(ev) {
        var touch = ev.touches[0],
          mouseEvent;
        ev.preventDefault();
        if (ev.touches.length > 1) {
          var coords = self.relMouseCoords(touch),
              new_dist = handlers.get_finger_dist(ev);
          coords.y = self.canvas.height*Math.log(handlers.finger_dist0/new_dist) + handlers.y0zoom;
          handlers.zoommove(coords.x, coords.y);
        } else {
          mouseEvent = new MouseEvent("pointermove",
          {
            clientX: touch.clientX,
            clientY: touch.clientY
          });
          self.dispatchEvent(mouseEvent);
        }
      };

      self.canvas.addEventListener("DOMMouseScroll", handlers.wheelHandler, false);
      self.canvas.addEventListener("mousewheel", handlers.wheelHandler, false);
      self.canvas.addEventListener("touchstart", handlers.touchstart, {passive: false});
      self.canvas.addEventListener("touchend", handlers.touchend, {passive: false});
      self.canvas.addEventListener("touchmove", handlers.touchmove, {passive: false});
	  };
</script>
<script>    /**
     * Methods related to initialization
     * @name ___METHODS_FOR_INITIALIZATION___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Initial test for WebGL
     */
    rglwidgetClass.prototype.initGL0 = function() {
      if (!window.WebGLRenderingContext){
        this.alertOnce("Your browser does not support WebGL. See http://get.webgl.org");
        return;
      }
    };

    /**
     * Initialize WebGL
     * @returns { Object } the WebGL context
     */
    rglwidgetClass.prototype.initGL = function() {
      var self = this, success = false;
      if (this.gl) {
      	if (!this.drawing && this.gl.isContextLost())
          this.restartCanvas();
        else
          return this.gl;
      }
      // if (!this.isInBrowserViewport()) return; Return what??? At this point we know this.gl is null.
      this.canvas.addEventListener("webglcontextrestored",
        this.onContextRestored, false);
      this.canvas.addEventListener("webglcontextlost",
        this.onContextLost, false);
      this.gl = this.canvas.getContext("webgl", this.webGLoptions) ||
               this.canvas.getContext("experimental-webgl", this.webGLoptions);
      success = !!(this.gl && this.gl instanceof WebGLRenderingContext);
      if (!success)
        this.alertOnce("Your browser does not support WebGL. See http://get.webgl.org"); 
      this.index_uint = this.gl.getExtension("OES_element_index_uint");
      var save = this.startDrawing();
      Object.keys(this.scene.objects).forEach(function(key){
        self.initObjId(parseInt(key, 10));
        });
      this.stopDrawing(save);
      return this.gl;
    };

    /**
     * Resize the display to match element
     * @param { Object } el - DOM element to match
     */
    rglwidgetClass.prototype.resize = function(el) {
      this.canvas.width = el.width;
      this.canvas.height = el.height;
    };

    /**
     * Initialize the sphere object
     */
    rglwidgetClass.prototype.initSphere = function(sections, segments) {
      var v = [], phi = [], theta = [], it = [], centers = [],
           i, j, k, ind, result = {};
       
      for (i = 0; i <= sections; i++) {
        phi.push(i/sections - 0.5);
      }

      for (j = 0; j <= segments; j++) {
        theta.push(2*j/segments);
        for (i = 0; i <= sections; i++) {
          /* These are [x,y,z,s,t]: */
          v.push([Math.sin(Math.PI*theta[j]) * Math.cos(Math.PI*phi[i]),
                  Math.sin(Math.PI*phi[i]),
                  Math.cos(Math.PI*theta[j]) * Math.cos(Math.PI*phi[i]),                               
                  theta[j]/2,
                  phi[i] + 0.5]);
           // console.log("xyzst="+v[v.length-1]);
        }
      }
      result.values = new Float32Array(rglwidgetClass.flatten(v));
      result.vertexCount = v.length;
      
      for (j = 0; j < segments; j++) {
        for (i = 0; i < sections; i++) {
          ind = i + (sections + 1)*j;
          if (i > 0)                       // Not south pole
            it.push([ind, 
                     ind + sections + 1,
                     ind + 1]);
          if (i < sections - 1)             // Not north pole
            it.push([ind + sections + 1, 
                     ind + sections + 2,
                     ind + 1]);
        }
      }
      result.it = new Uint16Array(rglwidgetClass.flatten(it));
      
      for (i = 0; i < it.length; i++) {
        centers.push([0,0,0]);
        for (j = 0; j < 3; j++) { // x,y,z
          for (k = 0; k < 3; k++) {// vertices
            centers[i][j] += v[it[i][k]][j]/3;
          }
        }
      }
      result.centers = centers;
      
      result.vOffsets = {vofs:0, cofs:-1, nofs:0, radofs:-1, oofs:-1,
                         tofs:3, nextofs:-1, pointofs:-1, stride:5};

      result.f = [];
      result.indices = {};

      result.colorCount = 1;
      result.type = "sphere";
      this.sphere = result;
      this.initShapeGL(this.sphere);
    };

    /**
     * Initialize the cube object
     */
    rglwidgetClass.prototype.initCube = function() {
   var v = [[0, 0, 0], [1, 0, 0], 
            [0, 1, 0], [1, 1, 0], 
            [0, 0, 1], [1, 0, 1],
            [0, 1, 1], [1, 1, 1]],
          ib = [[0, 2, 3, 1], 
                [2, 6, 7, 3], 
                [1, 3, 7, 5], 
                [0, 4, 6, 2], 
                [0, 1, 5, 4], 
                [4, 5, 7, 6]], 
          centers = [], i, j, k, 
          i0, i1, i2,
          normal, result = {};
       
      for (i = 0; i < ib.length; i++) {
        centers.push([0,0,0]);
        for (j = 0; j < 3; j++) { // x,y,z
          for (k = 0; k < 4; k++) {// vertices
            centers[i][j] += v[ib[i][k]][j]/4;
          }
        }
      }
      result.centers = centers; 
      result.values = new Float32Array(6*4*3*2);
      result.vertexCount = 24;
      result.vertices = new Array(24);
      result.normals = new Array(24);
      for (i=0; i < 6; i++) {
        for (j=0; j < 4; j++) {
          i0 = ib[i][j];
          result.vertices[4*i + j] = v[i0];
          i1 = ib[i][(j + 1) % 4];
          i2 = ib[i][(j + 2) % 4];
          if (j === 0)
            normal = rglwidgetClass.normalize(rglwidgetClass.xprod(rglwidgetClass.vdiff(v[i1], v[i0]),
                                  rglwidgetClass.vdiff(v[i2], v[i0])));
          result.normals[4*i + j] = normal;
          for (k=0; k < 3; k++) {
            result.values[i*24 + j*6 + k] = v[i0][k];
            result.values[i*24 + j*6 + 3 + k] = normal[k];
          }
        }
        for (j=0; j<4; j++)
          ib[i][j] = 4*i + j;
      }
      result.ib = new Uint16Array(rglwidgetClass.flatten(ib));
      
      result.vOffsets = {vofs:0, cofs:-1, nofs:3, radofs:-1, oofs:-1,
                         tofs:-1, nextofs:-1, pointofs:-1, stride:6};

      result.f = [];
      result.indices = {};

      result.colorCount = 1;
      result.type = "quads";
      this.cube = result;
      this.initShapeGL(this.cube);
    };
    

    /**
     * Do the gl part of initializing the sphere and cube
     */
    rglwidgetClass.prototype.initShapeGL = function(shape) {
      var gl = this.gl || this.initGL();
      if (gl.isContextLost()) return;
      shape.buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, shape.buf);
      gl.bufferData(gl.ARRAY_BUFFER, shape.values, gl.STATIC_DRAW);
      shape.ibuf = [gl.createBuffer(), gl.createBuffer()];
      return;
    };

    /* Initialize common sphere object from spheres object
    */
    rglwidgetClass.prototype.initShapeFromObj = function(shape, obj) {
      var i, pass, f, mode, self = this,
        /* This function selects things that would be
           the back, ignoring perspective -- this is what 
           we want for the bounding box decoration. */
        is_back = function(i) {
                var normal = [].concat(shape.normals[i]),
                  pt = shape.vertices[i];
                normal.push(-rglwidgetClass.dotprod(normal, pt));
                normal = rglwidgetClass.multVM(normal, self.normMatrix);
                return normal[2] < 0 || (normal[2] === 0 && normal[0] < 0);
              }; 
      shape.ofsLoc = obj.ofsLoc;
      shape.texLoc = obj.texLoc;
      shape.texture = obj.texture;
      shape.sampler = obj.sampler;
      shape.uFogMode = obj.uFogMode;
      shape.uFogColor = obj.uFogColor;
      shape.uFogParms = obj.uFogParms;
      shape.userAttribLocations = obj.userAttribLocations;
      shape.userUniformLocations = obj.userUniformLocations;
      shape.normLoc = obj.normLoc;
      shape.invPrMatLoc = obj.invPrMatLoc;
      shape.clipLoc = obj.clipLoc;
      shape.nextLoc = obj.nextLoc;
      shape.pointLoc = obj.pointLoc;
      shape.aspectLoc = obj.aspectLoc;
      shape.lwdLoc = obj.lwdLoc;
      shape.prog = obj.prog;
      shape.material = obj.material;
      shape.flags = obj.flags;
      shape.defFlags = obj.defFlags;
      shape.someHidden = obj.someHidden;
      shape.fastTransparency = obj.fastTransparency;
      shape.nlights = obj.nlights;
      shape.emission = obj.emission;
      shape.emissionLoc = obj.emissionLoc;
      shape.shininess = obj.shininess;
      shape.shininessLoc = obj.shininessLoc;
      shape.ambient = obj.ambient;
      shape.ambientLoc = obj.ambientLoc;
      shape.specular = obj.specular;
      shape.specularLoc = obj.specularLoc;
      shape.diffuse = obj.diffuse;
      shape.diffuseLoc = obj.diffuseLoc;
      shape.lightDir = obj.lightDir;
      shape.lightDirLoc = obj.lightDirLoc;
      shape.viewpoint = obj.viewpoint;
      shape.viewpointLoc = obj.viewpointLoc;
      shape.finite = obj.finite;
      shape.finiteLoc = obj.finiteLoc;
      shape.prMatLoc = obj.prMatLoc;
      shape.mvMatLoc = obj.mvMatLoc;
      shape.normMatLoc = obj.normMatLoc;
      shape.frontLoc = obj.frontLoc;
      shape.index_uint = false;
      shape.is_transparent = obj.is_transparent;
      shape.ignoreExtent = obj.ignoreExtent;
      if (shape.passes !== obj.passes ||
          JSON.stringify( shape.pmode) !== JSON.stringify(obj.pmode)) {
        shape.passes = obj.passes;
        shape.pmode = obj.pmode;
        for (pass = 0; pass < obj.passes; pass++) {
          mode =  shape.pmode[pass];
          if (typeof  shape.indices[mode] === "undefined") {
            f = [];
            switch (mode) {
            case "culled": break;
            case "points":
              f.length =  shape.vertexCount;
              for (i=0; i < f.length; i++)
                f[i] = i;
              break;
            case "lines":
              if (typeof shape.it !== "undefined") {
                f.length = 2* shape.it.length;
      	        for (i=0; i <  shape.it.length/3; i++) {
      	          f[6*i] =  shape.it[3*i];
      	          f[6*i + 1] =  shape.it[3*i + 1];
      	          f[6*i + 2] =  shape.it[3*i + 1];
      	          f[6*i + 3] =  shape.it[3*i + 2];
      	          f[6*i + 4] =  shape.it[3*i + 2];
      	          f[6*i + 5] =  shape.it[3*i];
      	        }
              } else {
                f.length = 2*shape.ib.length;
                for (i=0; i < shape.ib.length/4; i++) {
                  f[8*i] = shape.ib[4*i];
                  f[8*i + 1] = shape.ib[4*i + 1];
                  f[8*i + 2] = shape.ib[4*i + 1];
                  f[8*i + 3] = shape.ib[4*i + 2];
                  f[8*i + 4] = shape.ib[4*i + 2];
                  f[8*i + 5] = shape.ib[4*i + 3];
                  f[8*i + 6] = shape.ib[4*i + 3];
                  f[8*i + 7] = shape.ib[4*i];
                }
              }
      	      break;
      	    case "filled":
      	      if (typeof shape.it !== "undefined")
      	        f =  shape.it;
      	      else if (typeof shape.ib !== "undefined") {
      	        f.length = 1.5*shape.ib.length;
                for (i=0; i < shape.ib.length/4; i++) {
                  f[6*i] = shape.ib[4*i];
                  f[6*i+1] = shape.ib[4*i + 1];
                  f[6*i+2] = shape.ib[4*i + 2];
                  f[6*i+3] = shape.ib[4*i];
                  f[6*i+4] = shape.ib[4*i + 2];
                  f[6*i+5] = shape.ib[4*i + 3];
                }      	        
      	      }
      	      break;
      	    }              
            shape.indices[mode] = new Uint16Array(f);
          }
        }
      }       
      for (pass = 0; pass < obj.passes; pass++) {
        mode =  shape.pmode[pass];
        shape.f[pass] =  shape.indices[mode];
        if (typeof obj.draw_front !== "undefined" &&
            !obj.draw_front) {
          shape.f[pass] = shape.f[pass].filter(is_back);   
        }
      }
      // console.log("Names in  shapes not in  shape:"+JSON.stringify(rglwidgetClass.keydiff(obj,  shape)));
       shape.initialized = true;
    };

    /**
     * Initialize a subscene
     * @param { number } id - id of subscene.
     */
    rglwidgetClass.prototype.initSubscene = function(id) {
      var sub = this.getObj(id),
          i, obj;

      if (sub.type !== "subscene")
        return;

      sub.par3d.userMatrix = this.toCanvasMatrix4(sub.par3d.userMatrix);
      sub.par3d.userProjection = this.toCanvasMatrix4(sub.par3d.userProjection);
      sub.par3d.userProjection.transpose();
      sub.par3d.listeners = [].concat(sub.par3d.listeners);
      sub.backgroundId = undefined;
      sub.subscenes = [];
      sub.clipplanes = [];
      sub.transparent = [];
      sub.opaque = [];
      sub.lights = [];
      sub.needsBegin = true;
      if (typeof sub.objects !== "undefined")
        sub.objects = [].concat(sub.objects); /* make sure it's an array */
      for (i=0; i < sub.objects.length; i++) {
        obj = this.getObj(sub.objects[i]);
        if (typeof obj === "undefined") {
          sub.objects.splice(i, 1);
          i--;
        } else if (obj.type === "background")
          sub.backgroundId = obj.id;
        else
          sub[this.whichList(obj.id)].push(obj.id);
      }
    };
    
    rglwidgetClass.prototype.initBBox = function(obj) {
      if (!this.cube)
        this.initCube();
      obj.cube = {id: obj.id + 0.1,
                    type: "quads",
                    flags: obj.flags,
                    material: obj.material,
                    colors: [obj.colors[0]],
                    vertices: this.cube.vertices,
                    normals: this.cube.normals,
                    draw_front: obj.draw_front,
                    initialized: false
        };
      if (this.getMaterial(obj.cube, "front") !==
          this.getMaterial(obj.cube, "back"))
        /* jshint bitwise: false */  
        obj.cube.flags |= rglwidgetClass.f_is_twosided;
        /* jshint bitwise: true */
      this.scene.objects[obj.cube.id] = obj.cube;
      obj.ticks = {id: obj.id + 0.2,
                     type: "lines",
                     flags: rglwidgetClass.f_has_fog,
                     material: obj.material,
                     colors: (obj.colors.length > 1 ? [obj.colors[1]] : [obj.colors[0]]),
                     axes: obj.axes,
                     initialized: false
      };
      this.scene.objects[obj.ticks.id] = obj.ticks;
      obj.labels = {id: obj.id + 0.3,
                     type: "text",
                     flags: rglwidgetClass.f_has_fog + 
                            rglwidgetClass.f_fixed_size + 
                            rglwidgetClass.f_fixed_quads,
                     material: {lit: false},
                     colors: (obj.colors.length > 1 ? [obj.colors[1]] : [obj.colors[0]]),
                     cex: [[1]],
                     family: [["sans"]],
                     font: [[1]],
                     adj: [[0.5, 0.5, 0.5]],
                     ignoreExtent: true,
                     initialized: false
      };
      this.scene.objects[obj.labels.id] = obj.labels;
      obj.initialized = true;
    };
    
    rglwidgetClass.prototype.initBackground = function(obj) {
      var material, fl = obj.defFlags;
      if (typeof obj.ids !== "undefined")
        obj.quad = rglwidgetClass.flatten([].concat(obj.ids));
      else if (obj.sphere) {
        fl.has_normals = true;
        fl.needs_vnormal = true;
        obj.defFlags = fl;
        material = obj.material;
        material.front = "culled";
        obj.vertices = [[0,0,0]];
        obj.texcoords = [[0,0]];
      }  
    };

    /**
     * Initialize object for display
     * @param { number } id - id of object to initialize
     */
    rglwidgetClass.prototype.initObjId = function(id) {
      if (typeof id !== "number") {
        this.alertOnce("initObj id is "+typeof id);
      }
      return this.initObj(this.getObj(id));
    };

    /**
     * Initialize object for display
     * @param { Object } obj - object to initialize
     */
    rglwidgetClass.prototype.initObj = function(obj) {
      var type = obj.type, 
          flags = obj.flags,
          normals = obj.normals,
          round_points = (typeof obj.material === "undefined") ?
            false : this.getMaterial(obj, "point_antialias"),
          has_indices = typeof obj.indices !== "undefined",
          has_spheres = type === "spheres" || 
                        (type === "background" && obj.sphere),
          sprites_3d = rglwidgetClass.isSet(flags, rglwidgetClass.f_sprites_3d),
          depth_sort = rglwidgetClass.isSet(flags, rglwidgetClass.f_depth_sort),
          gl = this.gl || this.initGL(),
          fl, polygon_offset,
          texinfo, drawtype, nclipplanes, f, nrows, oldrows,
          i,j,v,v1,v2, mat, uri, matobj, pass, pmode,
          dim, nx, nz, nrow, shaders;

    obj.initialized = true;
    
    obj.someHidden = false; // used in selection
    
    this.expandBufferedFields(obj);
    
    if (type === "subscene")
      return;
      
    obj.defFlags = fl = rglwidgetClass.getDefFlags(flags, type, normals, round_points);
  
    obj.is_transparent = fl.is_transparent;
  
    if (type === "bboxdeco")
      return this.initBBox(obj);
      
    if (has_spheres && typeof this.sphere === "undefined")
      this.initSphere(16, 16);

    if (type === "light") {
      obj.ambient = new Float32Array(obj.colors[0].slice(0,3));
      obj.diffuse = new Float32Array(obj.colors[1].slice(0,3));
      obj.specular = new Float32Array(obj.colors[2].slice(0,3));
      obj.lightDir = new Float32Array(obj.vertices[0]);
      return;
    }

    if (type === "clipplanes") {
      obj.vClipplane = rglwidgetClass.flatten(rglwidgetClass.cbind(obj.normals, obj.offsets));
      return;
    }

    if (type === "background") {
      this.initBackground(obj);
      if (!obj.sphere)
        return;
    }

    polygon_offset = this.getMaterial(obj, "polygon_offset");
    if (polygon_offset[0] !== 0 || polygon_offset[1] !== 0)
      obj.polygon_offset = polygon_offset;

    if (fl.is_transparent) {
      depth_sort = ["triangles", "quads", "surface",
                    "spheres", "sprites", "text",
                    "planes"].indexOf(type) >= 0;
    }
    
    if (fl.is_brush)
      this.initSelection(obj.id);

    if (typeof obj.vertices === "undefined")
      obj.vertices = [];

    v = obj.vertices;
    if (has_indices)
      obj.vertexCount = obj.indices.length;
    else
      obj.vertexCount = v.length;
      
    if (!obj.vertexCount) return;

    if (fl.is_twosided && !fl.has_normals && type !== "background") {
      if (typeof obj.userAttributes === "undefined")
        obj.userAttributes = {};
      v1 = Array(v.length);
      v2 = Array(v.length);
      if (obj.type === "triangles" || obj.type === "quads") {
      	if (obj.type === "triangles")
      	  nrow = 3;
      	else
      	  nrow = 4;
        for (i=0; i<Math.floor(v.length/nrow); i++)
          for (j=0; j<nrow; j++) {
            v1[nrow*i + j] = v[nrow*i + ((j+1) % nrow)];
            v2[nrow*i + j] = v[nrow*i + ((j+2) % nrow)];
          }
      } else if (obj.type === "surface") {
        dim = obj.dim[0];
        nx = dim[0];
        nz = dim[1];
        for (j=0; j<nx; j++) {
          for (i=0; i<nz; i++) {
            if (i+1 < nz && j+1 < nx) {
              v2[j + nx*i] = v[j + nx*(i+1)];
              v1[j + nx*i] = v[j+1 + nx*(i+1)];
            } else if (i+1 < nz) {
              v2[j + nx*i] = v[j-1 + nx*i];
              v1[j + nx*i] = v[j + nx*(i+1)];
            } else {
              v2[j + nx*i] = v[j + nx*(i-1)];
              v1[j + nx*i] = v[j-1 + nx*(i-1)];
            }
          }
        }
      }
      obj.userAttributes.aPos1 = v1;
      obj.userAttributes.aPos2 = v2;
    }

    if (!sprites_3d) {
      if (gl.isContextLost()) return;
      if (typeof obj.prog !== "undefined") {
        gl.deleteProgram(obj.prog);
        obj.prog = undefined;
      }
      
      shaders = this.getShaders(obj);
      
      obj.prog = gl.createProgram();
      gl.attachShader(obj.prog, this.getShader( gl.VERTEX_SHADER,
                      shaders.vertex ));
      gl.attachShader(obj.prog, this.getShader( gl.FRAGMENT_SHADER,
                      shaders.fragment ));
      //  Force aPos to location 0, aCol to location 1
      gl.bindAttribLocation(obj.prog, 0, "aPos");
      gl.bindAttribLocation(obj.prog, 1, "aCol");
      gl.linkProgram(obj.prog);
      var linked = gl.getProgramParameter(obj.prog, gl.LINK_STATUS);
      if (!linked) {

        // An error occurred while linking
        var lastError = gl.getProgramInfoLog(obj.prog);
        console.warn("Error in program linking:" + lastError);

        gl.deleteProgram(obj.prog);
        return;
      }
    }

    if (type === "text") {
      texinfo = this.drawTextToCanvas(obj.texts,
                                      rglwidgetClass.flatten(obj.cex),
                                      rglwidgetClass.flatten(obj.family),
                                      rglwidgetClass.flatten(obj.family));
    }

    if (fl.fixed_quads && !sprites_3d) {
      obj.ofsLoc = gl.getAttribLocation(obj.prog, "aOfs");
    }

    if (fl.has_texture || type === "text") {
      if (!obj.texture) {
        obj.texture = gl.createTexture();
        // This is a trick from https://stackoverflow.com/a/19748905/2554330 to avoid warnings
        gl.bindTexture(gl.TEXTURE_2D, obj.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
              new Uint8Array([255,255,255, 255])); // white
      }
      obj.texLoc = gl.getAttribLocation(obj.prog, "aTexcoord");
      obj.sampler = gl.getUniformLocation(obj.prog, "uSampler");
    }
    
    if (fl.has_fog && !sprites_3d) {
      obj.uFogMode = gl.getUniformLocation(obj.prog, "uFogMode");
      obj.uFogColor = gl.getUniformLocation(obj.prog, "uFogColor");
      obj.uFogParms = gl.getUniformLocation(obj.prog, "uFogParms");
    }

    if (fl.has_texture) {
      mat = obj.material;
      if (typeof mat.uri !== "undefined")
        uri = mat.uri;
      else if (typeof mat.uriElementId === "undefined") {
        matobj = this.getObj(mat.uriId);
        if (typeof matobj !== "undefined") {
          uri = matobj.material.uri;
        } else {
          uri = "";
        }
      } else
        uri = document.getElementById(mat.uriElementId).rglinstance.getObj(mat.uriId).material.uri;

      this.loadImageToTexture(uri, obj.texture);
    }

    if (type === "text") {
      this.handleLoadedTexture(obj.texture, this.textureCanvas);
    }

    var stride = 3, nc, cofs, nofs, radofs, oofs, tofs, vnew, fnew,
        nextofs = -1, pointofs = -1, alias, colors, key, selection,
        filter, adj, offset, attr, last, options, 
        len, current;

    obj.alias = undefined;
    
    colors = obj.colors;

    j = this.scene.crosstalk.id.indexOf(obj.id);
    if (j >= 0) {
      key = this.scene.crosstalk.key[j];
      options = this.scene.crosstalk.options[j];
      colors = colors.slice(0); 
      for (i = 0; i < v.length; i++)
        colors[i] = obj.colors[i % obj.colors.length].slice(0);
      if ( (selection = this.scene.crosstalk.selection) &&
           (selection.length || !options.selectedIgnoreNone) )
        for (i = 0; i < v.length; i++) {
          if (!selection.includes(key[i])) {
            if (options.deselectedColor)
              colors[i] = options.deselectedColor.slice(0);
            colors[i][3] = colors[i][3]*options.deselectedFade;   /* default: mostly transparent if not selected */
          } else if (options.selectedColor)
            colors[i] = options.selectedColor.slice(0);
        }
      if ( (filter = this.scene.crosstalk.filter) )
        for (i = 0; i < v.length; i++) 
          if (!filter.includes(key[i])) {
            if (options.filteredColor)
              colors[i] = options.filteredColor.slice(0);
            colors[i][3] = colors[i][3]*options.filteredFade;   /* default: completely hidden if filtered */
          }
    }  
    
    nc = obj.colorCount = colors.length;
    if (nc > 1) {
      cofs = stride;
      stride = stride + 4;
      v = rglwidgetClass.cbind(v, colors);
    } else {
      cofs = -1;
      obj.onecolor = rglwidgetClass.flatten(colors);
    }

    if (fl.has_normals && !has_spheres) {
      nofs = stride;
      stride = stride + 3;
      v = rglwidgetClass.cbind(v, typeof obj.pnormals !== "undefined" ? obj.pnormals : obj.normals);
    } else
      nofs = -1;

    if (typeof obj.radii !== "undefined") {
      radofs = stride;
      stride = stride + 1;
      // FIXME:  always concat the radii?
      if (obj.radii.length === v.length) {
        v = rglwidgetClass.cbind(v, obj.radii);
      } else if (obj.radii.length === 1) {
        v = v.map(function(row) { return row.concat(obj.radii[0]);});
      }
    } else
      radofs = -1;
      
    // Add default indices
    if (has_indices) {
      f = Array(obj.indices.length);
      for (i = 0; i < f.length; i++)
        f[i] = obj.indices[i] - 1;
    } else {
      f = Array(v.length);
      for (i = 0; i < v.length; i++)
        f[i] = i;
    }
    obj.f = [f,f];

    if (type === "sprites" && !sprites_3d) {
      tofs = stride;
      stride += 2;
      oofs = stride;
      stride += 3;
      vnew = new Array(4*v.length);
      fnew = new Array(4*v.length);
      alias = new Array(v.length);
      var rescale = fl.fixed_size ? 72 : 1,
          size = obj.radii, s = rescale*size[0]/2;
      last = v.length;
      f = obj.f[0];
      obj.adj = rglwidgetClass.flatten(obj.adj);
      if (typeof obj.pos !== "undefined") {
        obj.pos = rglwidgetClass.flatten(obj.pos);
        offset = obj.adj[0];
      } else
        offset = 0;
      for (i=0; i < v.length; i++) {
        adj = this.getAdj(obj, i, offset);
        if (size.length > 1)
          s = rescale*size[i]/2;
        adj[0] = 2*s*(adj[0] - 0.5);
        adj[1] = 2*s*(adj[1] - 0.5);
        adj[2] = 2*s*(adj[2] - 0.5);
        vnew[i]  = v[i].concat([0,0]).concat([-s-adj[0],
                                              -s-adj[1],
                                              -adj[2]]);
        fnew[4*i] = f[i];
        vnew[last]= v[i].concat([1,0]).concat([s-adj[0],
                                              -s-adj[1],
                                              -adj[2]]);
        fnew[4*i+1] = last++;
        vnew[last]= v[i].concat([1,1]).concat([s-adj[0],
                                               s-adj[1],
                                               -adj[2]]);
        fnew[4*i+2] = last++;
        vnew[last]= v[i].concat([0,1]).concat([-s-adj[0],
                                                s-adj[1],
                                                -adj[2]]);
        fnew[4*i+3] = last++;
        alias[i] = [last-3, last-2, last-1];
      }
      v = vnew;
      obj.vertexCount = v.length;
      obj.f = [fnew, fnew];
    } else if (type === "text") {
      tofs = stride;
      stride += 2;
      oofs = stride;
      stride += 3;
      vnew = new Array(4*v.length);
      f = obj.f[0];
      fnew = new Array(4*f.length);
      alias = new Array(v.length);
      last = v.length;
      adj = rglwidgetClass.flatten(obj.adj);
      if (typeof obj.pos !== "undefined") {
        obj.pos = rglwidgetClass.flatten(obj.pos);
        offset = adj[0];
      } else
        offset = 0;
      for (i=0; i < v.length; i++) {
        adj = this.getAdj(obj, i, offset, obj.texts[i]);
        vnew[i]  = v[i].concat([0,-0.5]).concat(adj);
        fnew[4*i] = f[i];
        vnew[last] = v[i].concat([1,-0.5]).concat(adj);
        fnew[4*i+1] = last++;
        vnew[last] = v[i].concat([1, 1.5]).concat(adj);
        fnew[4*i+2] = last++;
        vnew[last] = v[i].concat([0, 1.5]).concat(adj);
        fnew[4*i+3] = last++;
        alias[i] = [last-3, last-2, last-1];
        for (j=0; j < 4; j++) {
          v1 = vnew[fnew[4*i+j]];
          v1[oofs] = 2*(v1[tofs]-v1[oofs])*texinfo.widths[i];
          v1[oofs+1] = 2*(v1[tofs+1]-v1[oofs+1])*texinfo.textHeights[i];
          v1[oofs+2] = 2*(0.5-v1[oofs+2])*texinfo.textHeights[i]/1000.0;
          v1[tofs] = (texinfo.offsetsx[i] + v1[tofs]*texinfo.widths[i])/texinfo.canvasX;
          v1[tofs+1] = 1.0-(texinfo.offsetsy[i] -
              v1[tofs+1]*texinfo.textHeights[i])/texinfo.canvasY;
          vnew[fnew[4*i+j]] = v1;
        }
      }
      v = vnew;
      obj.vertexCount = v.length;
      obj.f = [fnew, fnew];
    } else if (typeof obj.texcoords !== "undefined") {
      tofs = stride;
      stride += 2;
      oofs = -1;
      v = rglwidgetClass.cbind(v, obj.texcoords);
    } else {
      tofs = -1;
      oofs = -1;
    }
    
    obj.alias = alias;
                          
    if (typeof obj.userAttributes !== "undefined") {
      obj.userAttribOffsets = {};
      obj.userAttribLocations = {};
      obj.userAttribSizes = {};
      for (attr in obj.userAttributes) {
      	obj.userAttribLocations[attr] = gl.getAttribLocation(obj.prog, attr);
      	if (obj.userAttribLocations[attr] >= 0) { // Attribute may not have been used
      	  obj.userAttribOffsets[attr] = stride;
      	  v = rglwidgetClass.cbind(v, obj.userAttributes[attr]);
      	  stride = v[0].length;
      	  obj.userAttribSizes[attr] = stride - obj.userAttribOffsets[attr];
      	} else
      	  console.warn("attribute '"+attr+"' not found in object "+obj.id+".");
      }
    }

    if (typeof obj.userUniforms !== "undefined" ||
        typeof obj.userTextures !== "undefined") {
      obj.userUniformLocations = {};
      for (attr in obj.userUniforms) {
        obj.userUniformLocations[attr] = gl.getUniformLocation(obj.prog, attr);
        if (obj.userUniformLocations[attr] === null)
          console.warn("uniform '"+attr+"' not found in object "+obj.id+".");
      }
      for (attr in obj.userTextures) {
        var texture = obj.userTextures[attr];
        texture.texture = gl.createTexture();
        // This is a trick from https://stackoverflow.com/a/19748905/2554330 to avoid warnings
        gl.bindTexture(gl.TEXTURE_2D, texture.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
              new Uint8Array([255,255,255, 255])); // white
        texture.sampler = gl.getUniformLocation(obj.prog, attr);
        if (texture.sampler === null)
          console.warn("sampler '"+attr+"' not found in object "+obj.id+".");
        uri = texture.uri;
        this.loadImageToTexture(uri, texture.texture);
      }
    }

    if (sprites_3d) {
      obj.userMatrix = new CanvasMatrix4();
      obj.userMatrix.load(rglwidgetClass.flatten(obj.usermatrix));
      obj.objects = rglwidgetClass.flatten([].concat(obj.ids));
      fl.is_lit = false;
      obj.adj = rglwidgetClass.flatten(obj.adj);
      
      if (typeof obj.pos !== "undefined") {
        obj.pos = rglwidgetClass.flatten(obj.pos);
        obj.offset = obj.adj[0];
      } else
        obj.offset = 0;
        
      var shapenum = rglwidgetClass.flatten(obj.shapenum);
      obj.shapelens = [];
      obj.shapefirst = [];
      obj.shapefirst.push(0);
      len = 0;
      current = 0;
      for (i = 0; i < shapenum.length; i++) {
        if (shapenum[i] === shapenum[current]) {
          len++;
        } else {
          obj.shapelens.push(len);
          len = 1;
          current = i;
          obj.shapefirst.push(i);
        }
      }
      obj.shapelens.push(len);
        
      for (i=0; i < obj.objects.length; i++)
        this.initObjId(obj.objects[i]);
    }

    nclipplanes = this.countClipplanes();
    if (nclipplanes && !sprites_3d) {
      obj.clipLoc = gl.getUniformLocation(obj.prog,"vClipplane");
    }

    if (fl.is_lit) {
      obj.emissionLoc = gl.getUniformLocation(obj.prog, "emission");
      obj.emission = new Float32Array(this.stringToRgb(this.getMaterial(obj, "emission")));
      obj.shininessLoc = gl.getUniformLocation(obj.prog, "shininess");
      obj.shininess = this.getMaterial(obj, "shininess");
      obj.nlights = this.countLights();
      if (obj.nlights > 0) {
        obj.ambient = new Float32Array(this.stringToRgb(this.getMaterial(obj, "ambient")));
        obj.specular = new Float32Array(this.stringToRgb(this.getMaterial(obj, "specular")));
        obj.ambientLoc = gl.getUniformLocation(obj.prog, "ambient");
        obj.specularLoc = gl.getUniformLocation(obj.prog, "specular");
        obj.diffuseLoc = gl.getUniformLocation(obj.prog, "diffuse" );
        obj.lightDirLoc = gl.getUniformLocation(obj.prog, "lightDir");
        obj.viewpointLoc = gl.getUniformLocation(obj.prog, "viewpoint");
        obj.finiteLoc = gl.getUniformLocation(obj.prog, "finite" );
      }
    }
    
    obj.passes = fl.is_twosided + 1;
    obj.pmode = new Array(obj.passes);
    for (pass = 0; pass < obj.passes; pass++) {
      if (type === "triangles" || type === "quads" || type === "surface" || has_spheres)
      	pmode = this.getMaterial(obj, (pass === 0) ? "front" : "back");
      else pmode = "filled";
      obj.pmode[pass] = pmode;
    }
    if (!has_spheres) {
      obj.f.length = obj.passes;
      for (pass = 0; pass < obj.passes; pass++) {
      	f = fnew = obj.f[pass];
        pmode = obj.pmode[pass];
      	if (pmode === "culled")
      	  fnew = [];
        else if (pmode === "points") {
          // stay with default
        } else if ((type === "quads" || type === "text" ||
             type === "sprites") && !sprites_3d) {
          nrows = Math.floor(obj.vertexCount/4);
          if (pmode === "filled") {
            fnew = Array(6*nrows);
            for (i=0; i < nrows; i++) {
              fnew[6*i] = f[4*i];
              fnew[6*i+1] = f[4*i + 1];
              fnew[6*i+2] = f[4*i + 2];
              fnew[6*i+3] = f[4*i];
              fnew[6*i+4] = f[4*i + 2];
              fnew[6*i+5] = f[4*i + 3];
            }
          } else {
            fnew = Array(8*nrows);
            for (i=0; i < nrows; i++) {
              fnew[8*i] = f[4*i];
              fnew[8*i+1] = f[4*i + 1];
              fnew[8*i+2] = f[4*i + 1];
              fnew[8*i+3] = f[4*i + 2];
              fnew[8*i+4] = f[4*i + 2];
              fnew[8*i+5] = f[4*i + 3];
              fnew[8*i+6] = f[4*i + 3];
              fnew[8*i+7] = f[4*i];
            }
          }
        } else if (type === "triangles") {
          nrows = Math.floor(obj.vertexCount/3);
          if (pmode === "filled") {
            fnew = Array(3*nrows);
            for (i=0; i < fnew.length; i++) {
              fnew[i] = f[i];
            }
          } else if (pmode === "lines") {
            fnew = Array(6*nrows);
      	    for (i=0; i < nrows; i++) {
      	      fnew[6*i] = f[3*i];
      	      fnew[6*i + 1] = f[3*i + 1];
      	      fnew[6*i + 2] = f[3*i + 1];
      	      fnew[6*i + 3] = f[3*i + 2];
      	      fnew[6*i + 4] = f[3*i + 2];
      	      fnew[6*i + 5] = f[3*i];
      	    }
          }
        } else if (has_spheres) {
          // default
        } else if (type === "surface") {
          dim = obj.dim[0];
          nx = dim[0];
          nz = dim[1];
          if (pmode === "filled") {
            fnew = [];
            for (j=0; j<nx-1; j++) {
              for (i=0; i<nz-1; i++) {
                fnew.push(f[j + nx*i],
                       f[j + nx*(i+1)],
                       f[j + 1 + nx*(i+1)],
                       f[j + nx*i],
                       f[j + 1 + nx*(i+1)],
                       f[j + 1 + nx*i]);
              }
            }
          } else if (pmode === "lines") {
            fnew = [];
            for (j=0; j<nx; j++) {
              for (i=0; i<nz; i++) {
                if (i+1 < nz)
                  fnew.push(f[j + nx*i],
                         f[j + nx*(i+1)]);
                if (j+1 < nx)
                  fnew.push(f[j + nx*i],
                         f[j+1 + nx*i]);
              }
            }
          }
        }
        obj.f[pass] = fnew;
        if (depth_sort) {
          drawtype = "DYNAMIC_DRAW";
        } else {
          drawtype = "STATIC_DRAW";
        }
      }
    }
    
    if (fl.fat_lines) {
      alias = undefined;
      obj.nextLoc = gl.getAttribLocation(obj.prog, "aNext");
      obj.pointLoc = gl.getAttribLocation(obj.prog, "aPoint");
      obj.aspectLoc = gl.getUniformLocation(obj.prog, "uAspect");
      obj.lwdLoc = gl.getUniformLocation(obj.prog, "uLwd");
      // Expand vertices to turn each segment into a pair of triangles
        
      	for (pass = 0; pass < obj.passes; pass++) {
      	  f = obj.f[pass];	
          oldrows = f.length;
      	  if (obj.pmode[pass] === "lines") 
      	    break;
      	}
      
      if (type === "linestrip") 
        nrows = 4*(oldrows - 1); 
      else
        nrows = 2*oldrows;
      vnew = new Array(nrows);
      fnew = new Array(1.5*nrows);
      
      // We're going to turn each pair of vertices into 4 new ones, with the "next" and "pt" attributes
      // added.
      // We do this by copying the originals in the first pass, adding the new attributes, then in a 
      // second pass add new vertices at the end.

      for (i = 0; i < v.length; i++) {
        vnew[i] = v[i].concat([0,0,0,0,0]); 
      }

      nextofs = stride;
      pointofs = stride + 3;
      stride = stride + 5;
            
      // Now add the extras
      var ind, k;
      last = v.length - 1;
      ind = 0;
      alias = new Array(f.length);
      for (i = 0; i < f.length; i++)
        alias[i] = [];
      for (i = 0; i < f.length - 1; i++) {
      	if (type !== "linestrip" && i % 2 === 1)
      	  continue;
      	k = ++last;
      	vnew[k] = vnew[f[i]].slice();
      	for (j=0; j<3; j++)
      	  vnew[k][nextofs + j] = vnew[f[i+1]][j];
      	vnew[k][pointofs] = -1;
      	vnew[k][pointofs+1] = -1;
      	fnew[ind] = k;
      	last++;
      	vnew[last] = vnew[k].slice();
      	vnew[last][pointofs] = 1;
      	fnew[ind+1] = last;
      	alias[f[i]].push(last-1, last);
      	last++;
      	k = last;
      	vnew[k] = vnew[f[i+1]].slice();
      	for (j=0; j<3; j++)
      	  vnew[k][nextofs + j] = vnew[f[i]][j];
      	vnew[k][pointofs] = -1;
      	vnew[k][pointofs+1] = 1;
      	fnew[ind+2] = k;
      	fnew[ind+3] = fnew[ind+1];
      	last++;
      	vnew[last] = vnew[k].slice();
      	vnew[last][pointofs] = 1;
      	fnew[ind+4] = last;
      	fnew[ind+5] = fnew[ind+2];
      	ind += 6;
      	alias[f[i+1]].push(last-1, last);
      }
      vnew.length = last+1;
      v = vnew;
      obj.vertexCount = v.length;
      if (typeof alias !== "undefined" && typeof obj.alias !== "undefined") {  // Already have aliases from previous section?
        var oldalias = obj.alias, newalias = Array(obj.alias.length);
        for (i = 0; i < newalias.length; i++) {
          newalias[i] = oldalias[i].slice();
          for (j = 0; j < oldalias[i].length; j++)
            Array.prototype.push.apply(newalias[i], alias[oldalias[j]]); // pushes each element 
        }
        obj.alias = newalias;
      } else
        obj.alias = alias;
      
      for (pass = 0; pass < obj.passes; pass++)
      	if (type === "lines" || type === "linestrip" || obj.pmode[pass] === "lines") {
          obj.f[pass] = fnew;
        }
      
      if (depth_sort) 
        drawtype = "DYNAMIC_DRAW";
      else
        drawtype = "STATIC_DRAW";
    }
    
      for (pass = 0; pass < obj.passes; pass++) {
        if (obj.vertexCount > 65535) {
          if (this.index_uint) {
            obj.f[pass] = new Uint32Array(obj.f[pass]);
            obj.index_uint = true;
          } else
            this.alertOnce("Object has "+obj.vertexCount+" vertices, not supported in this browser.");
        } else {
          obj.f[pass] = new Uint16Array(obj.f[pass]);
          obj.index_uint = false;
        }
      }
    
    if (stride !== v[0].length) {
      this.alertOnce("problem in stride calculation");
    }

    obj.vOffsets = {vofs:0, cofs:cofs, nofs:nofs, radofs:radofs, oofs:oofs, tofs:tofs,
                    nextofs:nextofs, pointofs:pointofs, stride:stride};

    obj.values = new Float32Array(rglwidgetClass.flatten(v));

    if (!has_spheres && !sprites_3d) {
      obj.buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
      gl.bufferData(gl.ARRAY_BUFFER, obj.values, gl.STATIC_DRAW); //
      obj.ibuf = Array(obj.passes);
      obj.ibuf[0] = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibuf[0]);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, obj.f[0], gl[drawtype]);
      if (fl.is_twosided) {
      	obj.ibuf[1] = gl.createBuffer();
      	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibuf[1]);
      	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, obj.f[1], gl[drawtype]);
      }
    }

    if (!sprites_3d) {
      obj.mvMatLoc = gl.getUniformLocation(obj.prog, "mvMatrix");
      obj.prMatLoc = gl.getUniformLocation(obj.prog, "prMatrix");

      if (fl.fixed_size) {
        obj.textScaleLoc = gl.getUniformLocation(obj.prog, "textScale");
      }
    }

    if (fl.needs_vnormal) {
      obj.normLoc = gl.getAttribLocation(obj.prog, "aNorm");
      obj.normMatLoc = gl.getUniformLocation(obj.prog, "normMatrix");
    }

    if (fl.is_twosided) {
      obj.frontLoc = gl.getUniformLocation(obj.prog, "front");
      if (fl.has_normals)
        obj.invPrMatLoc = gl.getUniformLocation(obj.prog, "invPrMatrix");
    }
  };
    
    /**
     * Initialize the DOM object
     * @param { Object } el - the DOM object
     * @param { Object } x - the scene data sent by JSON from R
     */
    rglwidgetClass.prototype.initialize = function(el, x) {
      this.textureCanvas = document.createElement("canvas");
      this.textureCanvas.style.display = "block";
      this.scene = x;
      this.normMatrix = new CanvasMatrix4();
      this.invPrMatrix = new CanvasMatrix4();
      this.saveMat = {};
      this.distance = null;
      this.posLoc = 0;
      this.colLoc = 1;
      if (el) {
        el.rglinstance = this;
        this.el = el;
        this.webGLoptions = el.rglinstance.scene.webGLoptions;
        this.initCanvas();
      }
      if (typeof Shiny !== "undefined") {
        var self = this;
        Shiny.addCustomMessageHandler("shinyGetPar3d",
          function(message) {
            var i, param, 
                subscene = self.getObj(message.subscene),
                parameters = [].concat(message.parameters),
                result = {tag: message.tag, subscene: message.subscene};
            if (typeof subscene !== "undefined") {
              for (i = 0; i < parameters.length; i++) {
                param = parameters[i];
                result[param] = subscene.par3d[param];
              }
            } else {
              console.log("subscene "+message.subscene+" undefined.");
            }
            Shiny.setInputValue("par3d:shinyPar3d", result, {priority: "event"});
          });
          
        Shiny.addCustomMessageHandler("shinySetPar3d",
          function(message) {
            var param = message.parameter, 
                subscene = self.getObj(message.subscene);
            if (typeof subscene !== "undefined") {
              subscene.par3d[param] = message.value;
              subscene.initialized = false;
              self.drawScene();
            } else {
              console.log("subscene "+message.subscene+" undefined.");
            }
          });
          
        Shiny.addCustomMessageHandler("resetBrush",
          function(message) {
            if (message === self.scene.selectionInput) {
              self.clearBrush(null);
              self.recordSelection(0);
            }
          });
      }
    };
    
    /**
     * Restart the WebGL canvas
     */
    rglwidgetClass.prototype.restartCanvas = function() {
      var newcanvas = document.createElement("canvas"),
          self = this, 
          labelid = this.el.getAttribute("aria-labelledby");
      newcanvas.width = this.el.width;
      newcanvas.height = this.el.height;
      newcanvas.setAttribute("aria-labelledby", 
        labelid);
        
      if (typeof this.scene.altText !== "undefined") {
        // We're in Shiny, so alter the label
        var label = document.getElementById(labelid);
        if (label)
          label.innerHTML = this.scene.altText;
      }
      newcanvas.addEventListener("webglcontextrestored",
        this.onContextRestored, false);
      newcanvas.addEventListener("webglcontextlost",
        this.onContextLost, false);
      while (this.el.firstChild) {
        this.el.removeChild(this.el.firstChild);
      }
      this.el.appendChild(newcanvas);
      this.canvas = newcanvas;
      if (this.scene.javascript) {
        /* jshint evil:true */
        Function('"use strict";' + this.scene.javascript)();
        /* jshint evil:false */
      }
      this.setMouseHandlers();
      if (this.gl) 
        Object.keys(this.scene.objects).forEach(function(key){
          self.getObj(parseInt(key, 10)).texture = undefined; 
          });
      this.gl = null;
    };

    /**
     * Initialize the WebGL canvas
     */
    rglwidgetClass.prototype.initCanvas = function() {
      this.restartCanvas();
      var objs = this.scene.objects,
          self = this;
          
      /* These hold context specific data.  In Shiny, they   
         need to be deleted.  Elsewhere, they don't exist
         and these are no-ops. */
         
      delete this.cube;
      delete this.sphere;
      
      Object.keys(objs).forEach(function(key){
        self.initSubscene(parseInt(key, 10));
      });

      this.onContextRestored = function() {
        self.initGL();
        self.drawScene();
      };

      this.onContextLost = function(event) {
        if (!self.drawing)
          this.gl = null;
        event.preventDefault();
      };

      this.initGL0();
      this.lazyLoadScene = function() {
      	if (typeof self.slide === "undefined")
      	  self.slide = self.getSlide();
      	if (self.isInBrowserViewport()) {
      	  if (!self.gl || self.gl.isContextLost())
      	    self.initGL();
      	  self.drawScene();
      	}
      };
      window.addEventListener("DOMContentLoaded", this.lazyLoadScene, false);
      window.addEventListener("load", this.lazyLoadScene, false);
      window.addEventListener("resize", this.lazyLoadScene, false);
      window.addEventListener("scroll", this.lazyLoadScene, false);
      this.slide = this.getSlide();
      if (this.slide) {
        if (typeof this.slide.rgl === "undefined")
          this.slide.rgl = [this];
        else
          this.slide.rgl.push(this);
        if (this.scene.context.rmarkdown) 
          if (this.scene.context.rmarkdown === "ioslides_presentation") {
            this.slide.setAttribute("slideenter", "this.rgl.forEach(function(scene) { scene.lazyLoadScene.call(window);})");
          } else if (this.scene.context.rmarkdown === "slidy_presentation") {
            // This method would also work in ioslides, but it gets triggered
            // something like 5 times per slide for every slide change, so
            // you'd need a quicker function than lazyLoadScene.
            var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver,
            observer = new MutationObserver(function(mutations) {
              mutations.forEach(function() {
                self.slide.rgl.forEach(function(scene) { scene.lazyLoadScene.call(window); });});});
            observer.observe(this.slide, { attributes: true, attributeFilter:["class"] });
          }
      }
    };
</script>
<script>/**
 * Methods related to drawing transparent objects
 * @name ___METHODS_FOR_TRANSPARENCY___
 * @memberof rglwidgetClass
 * @kind function
 * @instance

 * These functions order the centers of displayed objects so they
 * can be drawn using the painters algorithm, necessary to support
 * transparency.  

 * Note that objid is not obj.id when drawing spheres.
 */

/**
 * Break objects into pieces
 * @returns { array } Array of pieces
 */
    rglwidgetClass.prototype.getPieces = function(context, objid, subid, obj) {
      var n = obj.centers.length,
          depth,
          result = new Array(n),
          z, w, i,
          meandepth = 0;
      context = context.slice();
          
      for(i=0; i<n; i++) {
        z = this.prmvMatrix.m13*obj.centers[i][0] +
            this.prmvMatrix.m23*obj.centers[i][1] +
            this.prmvMatrix.m33*obj.centers[i][2] +
            this.prmvMatrix.m43;
        w = this.prmvMatrix.m14*obj.centers[i][0] +
            this.prmvMatrix.m24*obj.centers[i][1] +
            this.prmvMatrix.m34*obj.centers[i][2] +
            this.prmvMatrix.m44;
        depth = z/w;
        meandepth += depth;
        result[i] = {context: context, 
                     objid: objid,
                     subid: subid,
                     index: i, 
                     depth: depth,
                     meandepth: 0};
      }
      meandepth /= n;
      for (i=0; i<n; i++)
        result[i].meandepth = meandepth;
      return result;    
    };
    
    /**
     * Get pieces from sphere
     * @returns { object }
     * @param { array } context - 
     * @param { numeric } subid - subscene
     * @param { object } obj - spheres object
     */
    rglwidgetClass.prototype.getSpherePieces = function(context, subid, obj)
    {
      if (obj.fastTransparency) 
        if (subid === 0) // Only compute pieces once
          return this.getPieces(context, obj.id, -1, obj);
        else
          return [];
      else
        return this.getPieces(context, obj.id, subid, this.sphere);
    };
    
   /**
     * Get pieces from cube
     * @returns { object }
     * @param { array } context - 
     * @param { numeric } subid - subscene
     * @param { object } obj - spheres object
     */
    rglwidgetClass.prototype.getCubePieces = function(context, obj)
    {
      return this.getPieces(context, obj.id, 0, this.cube);
    };
    
    /**
     * Merge pieces that can be drawn in one call
     * @returns { object }
     * @param { array } pieces - The pieces to merge
     */
    rglwidgetClass.prototype.mergePieces = function(pieces) {
      var result = [];
      if (pieces.length > 0) {
        var i,
          thiscontext = pieces[0].context, 
          thisobjid = pieces[0].objid, 
          thissubid = pieces[0].subid,
          indices = [];
        for (i= 0; i < pieces.length; i++) {
          if (pieces[i].context !== thiscontext || 
              pieces[i].objid !== thisobjid ||
              pieces[i].subid !== thissubid) {
            result.push({context: thiscontext, objid: thisobjid,
                         subid: thissubid, indices: indices});
            thiscontext = pieces[i].context;
            thisobjid = pieces[i].objid;
            thissubid = pieces[i].subid;
            indices = [];
          }
          indices.push(pieces[i].index);
        }
        result.push({context: thiscontext, objid: thisobjid,
                                subid: thissubid,
                                indices: indices});
      }
      return result;
    };

    /**
     * Sort pieces by depth
     * @returns { array }
     * @param { array } pieces - array of pieces 
     */
    rglwidgetClass.prototype.sortPieces = function(pieces) {
      var fastTransparency = this.scene.fastTransparency,
          compare = function(i,j) {
          var c1, c2,
              diff = fastTransparency ? j.meandepth - i.meandepth : j.depth - i.depth;
              
        // Check for different object depths     
        if (diff !== 0.0)
          return diff;
          
        // At this point we are either on the same object or
        // two different objects that are at the same mean
        // depth.  Context changes are expensive so arbitrarily
        // split the two objects.
        
        // Check for different objects
        diff = j.objid - i.objid;
        if (diff !== 0)
          return diff;
          
        // Check for different nested objects 
        c1 = j.context.slice();
        c2 = i.context.slice();
        diff = c1.length - c2.length; 
        while (diff === 0 && c1.length > 0) {
          diff = c1.pop() - c2.pop();
        }
        if (diff !== 0)
          return diff;
          
        // Both pieces are in the same object, so
        // check for different piece depths
        // If fastTransparency is not set, this is redundant,
        // but a test would probably be slower.
        
        diff = j.depth - i.depth;

        return diff;
        
      }, result = [];
      if (pieces.length) 
        result = pieces.sort(compare);
      return result;
    };
</script>
<script>    /**
     * Methods related to drawing
     * @name ___METHODS_FOR_DRAWING___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Start drawing
     * @returns { boolean } Previous state
     */
    rglwidgetClass.prototype.startDrawing = function() {
    	var value = this.drawing;
    	this.drawing = true;
    	return value;
    };

    /**
     * Stop drawing and check for context loss
     * @param { boolean } saved - Previous state
     */
    rglwidgetClass.prototype.stopDrawing = function(saved) {
      this.drawing = saved;
      if (!saved && this.gl && this.gl.isContextLost())
        this.restartCanvas();
    };

    /**
     * Update the triangles used to display a plane
     * @param { number } id - id of the plane
     * @param { Object } bbox - bounding box in which to display the plane
     */
    rglwidgetClass.prototype.planeUpdateTriangles = function(obj, bbox) {
      var perms = [[0,0,1], [1,2,2], [2,1,0]],
          x, xrow, elem, A, d, nhits, i, j, k, u, v, w, intersect, which, v0, v2, vx, reverse,
          face1 = [], face2 = [], normals = [],
          nPlanes = obj.normals.length, idx, center;
      obj.bbox = bbox;
      obj.vertices = [];
      obj.centers = [];
      obj.initialized = false;
      for (elem = 0; elem < nPlanes; elem++) {
//    Vertex Av = normal.getRecycled(elem);
        x = [];
        A = obj.normals[elem];
        d = obj.offsets[elem][0];
        nhits = 0;
        for (i=0; i<3; i++)
          for (j=0; j<2; j++)
            for (k=0; k<2; k++) {
              u = perms[0][i];
              v = perms[1][i];
              w = perms[2][i];
              if (A[w] !== 0.0) {
                intersect = -(d + A[u]*bbox[j+2*u] + A[v]*bbox[k+2*v])/A[w];
                if (bbox[2*w] < intersect && intersect < bbox[1+2*w]) {
                  xrow = [];
                  xrow[u] = bbox[j+2*u];
                  xrow[v] = bbox[k+2*v];
                  xrow[w] = intersect;
                  x.push(xrow);
                  face1[nhits] = j + 2*u;
                  face2[nhits] = k + 2*v;
                  nhits++;
                }
              }
            }

            if (nhits > 3) {
            /* Re-order the intersections so the triangles work */
              for (i=0; i<nhits-2; i++) {
                which = 0; /* initialize to suppress warning */
                for (j=i+1; j<nhits; j++) {
                  if (face1[i] === face1[j] || face1[i] === face2[j] ||
                      face2[i] === face1[j] || face2[i] === face2[j] ) {
                    which = j;
                    break;
                  }
                }
                if (which > i+1) {
                  rglwidgetClass.swap(x, i+1, which);
                  rglwidgetClass.swap(face1, i+1, which);
                  rglwidgetClass.swap(face2, i+1, which);
                }
              }
            }
            if (nhits >= 3) {
      /* Put in order so that the normal points out the FRONT of the faces */
              v0 = [x[0][0] - x[1][0] , x[0][1] - x[1][1], x[0][2] - x[1][2]];
              v2 = [x[2][0] - x[1][0] , x[2][1] - x[1][1], x[2][2] - x[1][2]];
              /* cross-product */
              vx = rglwidgetClass.xprod(v0, v2);
              reverse = rglwidgetClass.dotprod(vx, A) > 0;

              for (i=0; i<nhits-2; i++) {
                obj.vertices.push(x[0]);
                center = [];
                for (k = 0; k<3; k++)
                  center.push(x[0][k]/3);
                normals.push(A);
                for (j=1; j<3; j++) {
                  idx = i + (reverse ? 3-j : j);
                  obj.vertices.push(x[idx]);
                  for (k=0; k<3; k++)
                    center[k] += x[idx][k]/3;
                  normals.push(A);
                }
                obj.centers.push(center);
              }
            }
      }
      obj.pnormals = normals;
    };
    
    rglwidgetClass.prototype.mode4type = {points : "POINTS",
                     linestrip : "LINE_STRIP",
                     abclines : "LINES",
                     lines : "LINES",
                     sprites : "TRIANGLES",
                     planes : "TRIANGLES",
                     text : "TRIANGLES",
                     quads : "TRIANGLES",
                     surface : "TRIANGLES",
                     triangles : "TRIANGLES",
                     sphere : "TRIANGLES"
    };
    
    /**
     * Disable unused arrays
     * @param { Object } obj - Object to work with
     * @param { Array } enabled - Array indicating which are enabled
     */
    rglwidgetClass.prototype.disableArrays = function(obj, enabled) {
      var gl = this.gl || this.initGL(),
          objLocs = ["normLoc", "texLoc", "ofsLoc", "pointLoc", "nextLoc"],
          thisLocs = ["posLoc", "colLoc"], i, attr;
      for (i = 0; i < objLocs.length; i++) 
        if (enabled[objLocs[i]]) gl.disableVertexAttribArray(obj[objLocs[i]]);
      for (i = 0; i < thisLocs.length; i++)
        if (enabled[thisLocs[i]]) gl.disableVertexAttribArray(this[objLocs[i]]);
      if (typeof obj.userAttributes !== "undefined") {
      	for (attr in obj.userAttribSizes) {  // Not all attributes may have been used
      	  gl.disableVertexAttribArray( obj.userAttribLocations[attr] );
      	}
      }
    };

    /**
     * Start drawing the scene
     */    
    rglwidgetClass.prototype.doStartScene = function() {
      var gl = this.gl || this.initGL();
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.clearDepth(1.0);
      gl.clearColor(1,1,1,1);
      gl.depthMask(true); // Must be true before clearing depth buffer
      /* jshint bitwise: false */
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      /* jshint bitwise: true */
    };
    
    /**
     * Set gl depth test based on object's material
     * @param { Object } obj - object to use
     */
    rglwidgetClass.prototype.doDepthTest = function(obj) {
      var gl = this.gl,
          tests = {never: gl.NEVER,
                   less:  gl.LESS,
                   equal: gl.EQUAL,
                   lequal:gl.LEQUAL,
                   greater: gl.GREATER,
                   notequal: gl.NOTEQUAL,
                   gequal: gl.GEQUAL,
                   always: gl.ALWAYS},
           test = tests[this.getMaterial(obj, "depth_test")];
      gl.depthFunc(test);
    };    
    
    /**
     * Set polygon offset for an obj
     * @param { object } obj - object to use
     */
    rglwidgetClass.prototype.doPolygonOffset = function(obj) { 
      var gl = this.gl;
      if (typeof obj.polygon_offset !== "undefined") {
        gl.polygonOffset(obj.polygon_offset[0],
                          obj.polygon_offset[1]);
        gl.enable(gl.POLYGON_OFFSET_FILL);
      } else
        gl.disable(gl.POLYGON_OFFSET_FILL);
    };
    
    /**
     * Do code for clipping
     * @param { object } obj - Object to work with
     * @param { object } subscene - Subscene to work with
     */
    rglwidgetClass.prototype.doClipping = function(obj, subscene) {
      var gl = this.gl,
          clipcheck = 0,
          clipplaneids = subscene.clipplanes,
          clip, i,j, n = this.countClipplanes(),
          clipplanedata; 
          
      if (n > 0) {
        clipplanedata = new Float32Array(4*n);
        for (i=0; i < clipplaneids.length; i++) {
          clip = this.getObj(clipplaneids[i]);
          for (j=0; j < clip.offsets.length; j++) {
            clipplanedata.set(clip.IMVClip[j], clipcheck);
            clipcheck += 4;
          }
        }
      
        // Leftovers are initialized to zero, which is fine
        gl.uniform4fv(obj.clipLoc, clipplanedata);
      }
    };
    
    /**
     * Do code for lighting
     * @param { object } obj - Object to work with
     * @param { object } subscene - Subscene to work with
     */
    rglwidgetClass.prototype.doLighting = function(obj, subscene) {
    var gl = this.gl, i, j, n, light,
      ambient, specular, diffuse, lightDir, viewpoint, finite,
      ambient0, specular0;

      gl.uniform3fv( obj.emissionLoc, obj.emission);
      gl.uniform1f( obj.shininessLoc, obj.shininess);
      while ((typeof subscene.lights === "undefined" ||
              subscene.lights.length === 0) && 
             typeof subscene.parent !== "undefined")
        subscene = this.getObj(subscene.parent);

      if (typeof subscene.lights === "undefined")
        return;
        
      n = subscene.lights.length;
        
      ambient = new Float32Array(3*n);
      specular = new Float32Array(3*n);
      diffuse = new Float32Array(3*n);
      lightDir = new Float32Array(3*n);
      viewpoint = new Int32Array(n);
      finite = new Int32Array(n);
          
      for (i=0; i < n; i++) {
        light = this.getObj(subscene.lights[i]);
        if (!light.initialized) this.initObj(light);
        ambient0 = this.componentProduct(light.ambient, obj.ambient);
        specular0 = this.componentProduct(light.specular, obj.specular);
        for (j=0; j < 3; j++) {
          ambient[3*i + j] = ambient0[j];
          specular[3*i + j] = specular0[j];
          diffuse[3*i + j] = light.diffuse[j];
          lightDir[3*i + j] = light.lightDir[j];
        }
        viewpoint[i] = light.viewpoint;
        finite[i] = light.finite;
      }
        
      for (i = n; i < obj.nlights; i++) {
        for (j = 0; j < 3; j++) {
          ambient[3*i + j] = 0.0;
          specular[3*i + j] = 0.0;
          diffuse[3*i + j] = 0.0;
        }
      }
        
      gl.uniform3fv( obj.ambientLoc, ambient);
      gl.uniform3fv( obj.specularLoc, specular);
      gl.uniform3fv( obj.diffuseLoc, diffuse);
      gl.uniform3fv( obj.lightDirLoc, lightDir);
      gl.uniform1iv( obj.viewpointLoc, viewpoint);
      gl.uniform1iv( obj.finiteLoc, finite);
    };
    
    /**
     * Do code for colors
     * @param { object } obj - Object to work with
     */
    rglwidgetClass.prototype.doColors = function(obj) {
      var gl = this.gl;
      if (obj.colorCount === 1) {
        gl.disableVertexAttribArray( this.colLoc );
        gl.vertexAttrib4fv( this.colLoc, new Float32Array(obj.onecolor));
        return false;
      } else {
        gl.enableVertexAttribArray( this.colLoc );
        gl.vertexAttribPointer(this.colLoc, 4, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.cofs);
        return true;
      }
    };
    
    /**
     * Do code for normals
     * @param { object } obj - Object to work with
     */
    rglwidgetClass.prototype.doNormals = function(obj) {
      var gl = this.gl;
      if (obj.vOffsets.nofs >= 0) {
        gl.enableVertexAttribArray( obj.normLoc );
        gl.vertexAttribPointer(obj.normLoc, 3, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.nofs);
        return true;
      } else
        return false;
    };
    
    /**
     * Do code for vNormal
     * @param { object } obj - Object to work with
     */
    rglwidgetClass.prototype.doNormMat = function(obj) {
      var gl = this.gl;
        
      gl.uniformMatrix4fv( obj.normMatLoc, false, new Float32Array(this.normMatrix.getAsArray()) );
    };
    
    /**
     * Do code for textures
     * @param { object } obj - Object to work with
     */    
    rglwidgetClass.prototype.doTexture = function(obj) {
      var gl = this.gl, 
          is_sphere = obj.type === "sphere";
        gl.enableVertexAttribArray( obj.texLoc );
        if (is_sphere)
          gl.vertexAttribPointer(obj.texLoc, 2, gl.FLOAT, false, 4*this.sphere.vOffsets.stride, 4*this.sphere.vOffsets.tofs);
        else
          gl.vertexAttribPointer(obj.texLoc, 2, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.tofs);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, obj.texture);
        gl.uniform1i( obj.sampler, 0);
        return true;
    };
    
    /**
     * Do code for user attributes
     * @param { object } obj - Object to work with
     */    
    rglwidgetClass.prototype.doUserAttributes = function(obj) {
      if (typeof obj.userAttributes !== "undefined") {
        var gl = this.gl;
      	for (var attr in obj.userAttribSizes) {  // Not all attributes may have been used
      	  gl.enableVertexAttribArray( obj.userAttribLocations[attr] );
      	  gl.vertexAttribPointer( obj.userAttribLocations[attr], obj.userAttribSizes[attr],
      	  			  gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.userAttribOffsets[attr]);
      	}
      }
    };

    /**
     * Do code for user uniforms
     * @param { object } obj - Object to work with
     */    
    rglwidgetClass.prototype.doUserUniforms = function(obj) {
      var gl = this.gl, attr;
      if (typeof obj.userUniforms !== "undefined") {
      	for (attr in obj.userUniformLocations) {
      	  var loc = obj.userUniformLocations[attr];
      	  if (loc !== null) {
      	    var uniform = obj.userUniforms[attr];
      	    if (typeof uniform !== "undefined") {
      	      var dim = rglwidgetClass.arrayDim(uniform);
      	      if (dim.length === 0)
      	        gl.uniform1f(loc, uniform);
      	      else if (dim.length === 1) {
      	        uniform = new Float32Array(uniform);
      	        switch(uniform.length) {
      	      	  case 2: gl.uniform2fv(loc, uniform); break;
      	      	  case 3: gl.uniform3fv(loc, uniform); break;
      	      	  case 4: gl.uniform4fv(loc, uniform); break;
      	      	  default: console.warn("bad uniform length");
      	        }
      	      } else if (dim.length === 2 && dim[0] === 4 && dim[1] === 4)
      	        gl.uniformMatrix4fv(loc, false, new Float32Array(rglwidgetClass.flatten(uniform)));
      	      else if (dim.length === 2) {
      	        uniform = new Float32Array(rglwidgetClass.flatten(uniform));
      	        switch(dim[[1]]) {
      	          case 1: gl.uniform1fv(loc, uniform); break;
      	          case 2: gl.uniform2fv(loc, uniform); break;
      	          case 3: gl.uniform3fv(loc, uniform); break;
      	          case 4: gl.uniform4fv(loc, uniform); break;
      	          default: console.warn("bad uniform column count");
      	        }
      	      } else
      	        console.warn("unsupported uniform shape");
      	    }
      	  }
      	}
      }
      if (typeof obj.userTextures !== "undefined") {
        var has_texture = rglwidgetClass.isSet(obj.flags, rglwidgetClass.f_has_texture),
              texnum = has_texture - 1;
        for (attr in obj.userTextures) {
      	  var texture = obj.userTextures[attr];
      	  if (texture.sampler !== null) {
      	    texnum += 1;
      	    gl.activeTexture(gl.TEXTURE0 + texnum);
            gl.bindTexture(gl.TEXTURE_2D, texture.texture);
            gl.uniform1i( texture.sampler, texnum);
      	  }
      	}
      }
    };

    /**
     * Load indices for complex drawing
     * @param { object } obj - Object to work with
     * @param { numeric } pass - Which pass of drawing?
     * @param { array } indices - Indices to draw
     */    
    rglwidgetClass.prototype.doLoadIndices = function(obj, pass, indices) {
      var gl = this.gl,
          f = obj.f[pass],
          type = obj.type,
          fat_lines = rglwidgetClass.isSet(obj.flags, rglwidgetClass.f_fat_lines),
          fnew, step;
      switch(type){
        case "points":
          step = 1;
          break;
        case "abclines":
        case "lines":
          if (fat_lines)
            step = 6;
          else
            step = 2;
          break;
        case "linestrip":
          if (fat_lines)
            step = 6;
          else
            step = 1;
          break;
        case "sphere":
        case "planes":
        case "triangles":
          step = 3;
          break;
        case "text":
        case "sprites":
        case "quads":
        case "surface":
          step = 6;
          break;
        default:
          console.error("loadIndices for "+type);
          return 0;
      }
      if (obj.index_uint)
        fnew = new Uint32Array(step * indices.length);
      else
        fnew = new Uint16Array(step * indices.length);
      for (var i = 0; i < indices.length; i++) {
        for (var j = 0; j < step; j++) {
          fnew[step*i + j] = f[step*indices[i] + j];
        }
      }
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, fnew, gl.DYNAMIC_DRAW);
      return fnew.length;
    };

    /**
     * Do code for depth masking
     * @param { boolean } mask - whether to mask
     */
    rglwidgetClass.prototype.doMasking = function(mask) {
      var gl = this.gl;
      gl.depthMask(mask);
    };

    /**
     * Do code for alpha blending
     * @param { boolean }  blend - Whether to blend.
     * @param { integer }  objid - Object id
     */    
    rglwidgetClass.prototype.doBlending = function(blend, objid) {
      var gl = this.gl, blendfunc, obj, 
        blends =  {zero: gl.ZERO,
                   one:  gl.ONE,
                   src_color: gl.SRC_COLOR,
                   one_minus_src_color: gl.ONE_MINUS_SRC_COLOR,
                   dst_color: gl.DST_COLOR,
                   one_minus_dst_color: gl.ONE_MINUS_DST_COLOR,
                   src_alpha: gl.SRC_ALPHA,
                   one_minus_src_alpha: gl.ONE_MINUS_SRC_ALPHA,
                   dst_alpha: gl.DST_ALPHA,
                   one_minus_dst_alpha: gl.ONE_MINUS_DST_ALPHA,
                   constant_color: gl.CONSTANT_COLOR,
                   one_minus_constant_color: gl.ONE_MINUS_CONSTANT_COLOR,
                   constant_alpha: gl.CONSTANT_ALPHA,
                   one_minus_constant_alpha: gl.ONE_MINUS_CONSTANT_ALPHA,
                   src_alpha_saturate: gl.SRC_ALPHA_SATURATE};
      if (blend) {
        obj = this.getObj(objid);
        blendfunc = this.getMaterial(obj, "blend");
        gl.blendFuncSeparate(blends[blendfunc[0]],
                             blends[blendfunc[1]],
                             gl.ONE, gl.ONE);
        gl.enable(gl.BLEND);
      } else {
        gl.disable(gl.BLEND);
      }
    };
    
    /**
     * Set up for fog in the subscene
     * @param { object } obj - background object
     * @param { object } subscene - which subscene
     */
    rglwidgetClass.prototype.doFog = function(obj, subscene) {
      var gl = this.gl, fogmode, color, 
          observer = subscene.par3d.observer[2],
          sintheta = Math.sin(subscene.par3d.FOV*Math.PI/180/2),
          parms = [this.frustum.near - 2*observer,
                   this.frustum.far - 2*observer,
                   this.fogScale,
                   (1-sintheta)/(1+sintheta)];
      if (typeof this.fogType === "undefined")
        this.fogType = "none";
      if (typeof this.fogScale === "undefined")
        parms[2] = 1;
      if (sintheta === 0)
        parms[3] = 1/3;
      switch(this.fogType){
        case "none": fogmode = 0; break;
        case "linear": 
          fogmode = 1; break;
        case "exp":  
          fogmode = 2; break;
        case "exp2": 
          fogmode = 3;
          break;
        default: console.error("Unknown fogtype "+this.fogType);
      }
      gl.uniform1i(obj.uFogMode, fogmode);
      color = this.fogColor;
      gl.uniform3f(obj.uFogColor, color[0], color[1], color[2]);
      gl.uniform4f(obj.uFogParms, parms[0], parms[1], parms[2], parms[3]);
    };

    /* The draw methods are called twice.  When 
       this.opaquePass is true, they should draw opaque parts
       of the scene, and return the list of transparent
       pieces.  Here context is the context array on input,
       modified when the matrices are changed.
       When this.opaquePass is false, the context argument
       contains a "piece", i.e. an ordered list of parts
       of the object to draw. */

    /**
     * Draw simple object
     * @param { object } obj - Object to draw
     * @param { object } subscene - which subscene
     * @param { array } context - Which context are we in?
     */       
    rglwidgetClass.prototype.drawSimple = function(obj, subscene, context) {
      var 
          fl,
          is_transparent,
          type = obj.type,
          gl = this.gl || this.initGL(),
          count,
          pass, mode, pmode,
          enabled = {};
        
      if (!obj.initialized)
        this.initObj(obj);
        
      if (this.texturesLoading)
        return[];

      count = obj.vertexCount;
      if (!count)
        return [];
    
      fl = obj.defFlags;
      is_transparent = fl.is_transparent || obj.someHidden;
      
      if (is_transparent && this.opaquePass)
        return this.getPieces(context, obj.id, 0, obj);

      this.doDepthTest(obj);
      
      this.doMasking(this.getMaterial(obj, "depth_mask"));
            
      gl.useProgram(obj.prog);

      this.doPolygonOffset(obj);

      gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);

      gl.uniformMatrix4fv( obj.prMatLoc, false, new Float32Array(this.prMatrix.getAsArray()) );
      gl.uniformMatrix4fv( obj.mvMatLoc, false, new Float32Array(this.mvMatrix.getAsArray()) );

      this.doClipping(obj, subscene);

      if (fl.needs_vnormal)
        this.doNormMat(obj);
        
      if (fl.is_lit)
        this.doLighting(obj, subscene);

      if (fl.has_fog)
        this.doFog(obj, subscene);

      this.doUserAttributes(obj);

      this.doUserUniforms(obj);
 
      gl.enableVertexAttribArray( this.posLoc );
      enabled.posLoc = true;
        
      if (fl.has_texture || obj.type === "text")
        enabled.texLoc = this.doTexture(obj);

      enabled.colLoc = this.doColors(obj);
      enabled.normLoc = this.doNormals(obj);

      if (fl.fixed_size) {
        gl.uniform3f( obj.textScaleLoc, 0.75/this.vp.width, 0.75/this.vp.height, 1.0);
      }
      
      if (fl.fixed_quads) {
        gl.enableVertexAttribArray( obj.ofsLoc );
        enabled.ofsLoc = true;
        gl.vertexAttribPointer(obj.ofsLoc, 3, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.oofs);
      }

      for (pass = 0; pass < obj.passes; pass++) {
      	pmode = obj.pmode[pass];
        if (pmode === "culled")
          continue;

      	mode = fl.fat_lines && (fl.is_lines || pmode === "lines") ? "TRIANGLES" : this.mode4type[type];

      	if (fl.is_twosided) {
      	  gl.uniform1i(obj.frontLoc, pass !== 0);
      	  if (fl.has_normals) {
      	    gl.uniformMatrix4fv(obj.invPrMatLoc, false, new Float32Array(this.invPrMatrix.getAsArray()));
      	  }
      	}

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibuf[pass]);
        if (!this.opaquePass) {
          if (type === "sphere" && obj.fastTransparency)
            count = this.doLoadIndices(obj, pass, this.sphere.fastpieces[0].indices);
          else
            count = this.doLoadIndices(obj, pass, context.indices);
        } else {
          count = obj.f[pass].length;
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, obj.f[pass], gl.STATIC_DRAW);
        }
      	if (!fl.is_lines && pmode === "lines" && !fl.fat_lines) {
          mode = "LINES";
        } else if (pmode === "points") {
          mode = "POINTS";
        }
                          
        if ((fl.is_lines || pmode === "lines") && fl.fat_lines) {
          gl.enableVertexAttribArray(obj.pointLoc);
          enabled.pointLoc = true;
          gl.vertexAttribPointer(obj.pointLoc, 2, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.pointofs);
          gl.enableVertexAttribArray(obj.nextLoc );
          enabled.nextLoc = true;
          gl.vertexAttribPointer(obj.nextLoc, 3, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.nextofs);
          gl.uniform1f(obj.aspectLoc, this.vp.width/this.vp.height);
          gl.uniform1f(obj.lwdLoc, this.getMaterial(obj, "lwd")/this.vp.height);
        }

        gl.vertexAttribPointer(this.posLoc,  3, gl.FLOAT, false, 4*obj.vOffsets.stride,  4*obj.vOffsets.vofs);

        gl.drawElements(gl[mode], count, obj.index_uint ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT, 0);
      }
      this.disableArrays(obj, enabled);
      return [];
    };

    /**
     * Draw planes object
     * @param { object } obj - Object to draw
     * @param { object } subscene - which subscene
     * @param { array } context - Which context are we in?
     */      
    rglwidgetClass.prototype.drawPlanes = function(obj, subscene, context) {
      if (this.opaquePass && (obj.bbox !== subscene.par3d.bbox || !obj.initialized)) {
          this.planeUpdateTriangles(obj, subscene.par3d.bbox);
      }
      return this.drawSimple(obj, subscene, context);
   };

    /**
     * @param { object } obj - object to draw
     * @param { object } subscene 
     * @param { array } context 
     * @description
     * Draw spheres in a subscene<br>
     * 
     * Drawing spheres happens in six ways:<br>
     * 1 opaquepass, not transparent:  transform and draw this.sphere count times<br>
     * 2 opaquepass, transparent, not fast: transform & collect sphere pieces count times<br>
     * 3 opaquepass, transparent, fast:  order the centres into separate pieces, order this.sphere once<br>
     * 4 not opaquepass, not transparent:  do nothing<br>
     * 5 not opaquepass, transparent, not fast:  transform for one sphere, draw one merged piece<br>
     * 6 not opaquepass, transparent, fast:  transform for one sphere, draw this.sphere in fixed order.<br>
     **/

    rglwidgetClass.prototype.drawSpheres = function(obj, subscene, context) {
      var flags = obj.flags,
          is_transparent = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent),
          sphereMV, baseofs, ofs, sscale, i,
          count, nc, scount, scale, indices, sphereNorm,
          enabled = {}, drawing,
          saveNorm = new CanvasMatrix4(this.normMatrix),
          saveMV = new CanvasMatrix4(this.mvMatrix),
          savePRMV = null,
          result = [], idx, margin = obj.material.margin;
 
      if (typeof margin !== "undefined")
        if (!this.marginVecToDataVec(obj, subscene))
          return [];

      if (!obj.initialized)
        this.initObj(obj);

      count = obj.vertexCount;
      if (!count) 
        return [];
        
      is_transparent = is_transparent || obj.someHidden;

      if (!this.opaquePass && !is_transparent)
        return [];
        
      if (this.prmvMatrix !== null)
        savePRMV = new CanvasMatrix4(this.prmvMatrix);
      
      scale = subscene.par3d.scale;        
      sphereNorm = new CanvasMatrix4();
      sphereNorm.scale(scale[0], scale[1], scale[2]);
      sphereNorm.multRight(saveNorm);
      this.normMatrix = sphereNorm;

      if (this.opaquePass) {
        context = context.slice();
        context.push(obj.id);
      } 
      
      drawing = this.opaquePass !== is_transparent;
      if (drawing) {
        nc = obj.colorCount;
        if (nc === 1) {
          this.sphere.onecolor = obj.onecolor;
        }
      }
      
      this.initShapeFromObj(this.sphere, obj);

      if (!this.opaquePass && obj.fastTransparency && typeof this.sphere.fastpieces === "undefined") {
        this.sphere.fastpieces = this.getPieces(context.context, obj.id, 0, this.sphere);
        this.sphere.fastpieces = this.sortPieces(this.sphere.fastpieces);
        this.sphere.fastpieces = this.mergePieces(this.sphere.fastpieces);
      }

      if (this.opaquePass)
        scount = count;
      else {
        indices = context.indices;
        if (obj.fastTransparency)
          scount = indices.length;  /* Each item gives the center of a whole sphere */
        else
          scount = 1;               /* Each item is a fragment of the sphere, at location subid */
      }
      for (i = 0; i < scount; i++) {
        sphereMV = new CanvasMatrix4();
        if (this.opaquePass)
          idx = i;
        else if (obj.fastTransparency)
          idx = indices[i];
        else
          idx = context.subid;
        if (typeof idx === "undefined")
          console.error("idx is undefined");
        baseofs = idx*obj.vOffsets.stride;
        ofs = baseofs + obj.vOffsets.radofs;
        sscale = obj.values[ofs];

        sphereMV.scale(sscale/scale[0], sscale/scale[1], sscale/scale[2]);
        sphereMV.translate(obj.values[baseofs],
                             obj.values[baseofs+1],
                             obj.values[baseofs+2]);
        sphereMV.multRight(saveMV);
        this.mvMatrix = sphereMV;
        this.setnormMatrix2();
        this.setprmvMatrix();
        if (drawing) {
          if (nc > 1) {
            this.sphere.onecolor = obj.values.slice(baseofs + obj.vOffsets.cofs, baseofs + obj.vOffsets.cofs + 4);
          }
          this.drawSimple(this.sphere, subscene, context);
        } else 
          result = result.concat(this.getSpherePieces(context, i, obj));
      }
      if (drawing)
        this.disableArrays(obj, enabled);
      this.normMatrix = saveNorm;
      this.mvMatrix = saveMV;
      this.prmvMatrix = savePRMV;
        
      return result;
    };
    
    /**
     * Prepare clipplanes for drawing
     * @param { object } obj - clip planes object
     */
    rglwidgetClass.prototype.drawClipplanes = function(obj) {
      var count = obj.offsets.length,
        IMVClip = [];
      for (var i=0; i < count; i++) {
        IMVClip[i] = rglwidgetClass.multMV(this.invMatrix, obj.vClipplane.slice(4*i, 4*(i+1)));
      }
      obj.IMVClip = IMVClip;
      return [];
    };

    /**
     * Prepare linestrip for drawing
     * @param { object } obj - line strip object
     * @param { object } subscene 
     * @param { array } context 
     */    
    rglwidgetClass.prototype.drawLinestrip = function(obj, subscene, context) {
      var origIndices, i, j, margin = obj.material.margin;
 
      if (typeof margin !== "undefined") 
        if (!this.marginVecToDataVec(obj, subscene))
          return [];
          
      if (this.opaquePass)
        return this.drawSimple(obj, subscene, context);
      origIndices = context.indices.slice();
      for (i=0; i < origIndices.length; i++) {
        j = origIndices[i];
        if (j < obj.centers.length - 1) {
          context.indices = [j, j+1];
          this.drawSimple(obj, subscene, context);
        }
      }
      context.indices = origIndices;
      return [];
    };
          
    /**
     * Draw a sprites object in a subscene
     * @param { object } obj - object to draw
     * @param { object } subscene
     * @param { object } context
     */
    rglwidgetClass.prototype.drawSprites = function(obj, subscene, context) {
      var flags = obj.flags,
          is_transparent = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent),
          sprites3d = rglwidgetClass.isSet(flags, rglwidgetClass.f_sprites_3d),
          fixed_size = rglwidgetClass.isSet(flags, rglwidgetClass.f_fixed_size),
          rotating = rglwidgetClass.isSet(flags, rglwidgetClass.f_rotating),
          i,j,
          origMV = new CanvasMatrix4( this.mvMatrix ),
          origPRMV = null,
          origPR,
          pos, radius, userMatrix,
          result = [], margin = obj.material.margin;
 
      if (typeof margin !== "undefined")
        if (!this.marginVecToDataVec(obj, subscene))
          return [];

      if (!sprites3d) 
        return this.drawSimple(obj, subscene, context);
      
      if (!obj.initialized)
        this.initObj(obj);

      if (!obj.vertexCount)
        return [];
    
      is_transparent = is_transparent || obj.someHidden;
      
      var norigs = obj.vertices.length,
          savenorm = new CanvasMatrix4(this.normMatrix),
          iOrig, adj, offset;

      userMatrix = obj.userMatrix;
                   
      if (this.opaquePass) {
        context = context.slice();
        context.push(obj.id);
      } else
        norigs = 1;
          
      if (this.prmvMatrix !== null)
         origPRMV = new CanvasMatrix4( this.prmvMatrix );

      offset = obj.offset;
      
      if (fixed_size && !rotating) {
        origPR = this.prMatrix;
        this.prMatrix = new CanvasMatrix4();
      }
        
      for (iOrig=0; iOrig < norigs; iOrig++) {
        if (this.opaquePass)
          j = iOrig;
        else
          j = context.subid;
        pos = [].concat(obj.vertices[j]).concat(1.0);
        radius = obj.radii.length > 1 ? obj.radii[j][0] : obj.radii[0][0];
        this.mvMatrix = new CanvasMatrix4(userMatrix);
        adj = this.getAdj(obj, j, offset);
        this.mvMatrix.translate(1 - 2*adj[0], 1 - 2*adj[1], 1 - 2*adj[2]);
        this.mvMatrix.scale(radius, radius, radius);
        
        if (fixed_size) {
          var viewport = subscene.par3d.viewport,
            winwidth = viewport.width*this.canvas.width,
            winheight = viewport.height*this.canvas.height,
            scalex = 27/winwidth, scaley = 27/winheight,
              scale = Math.sqrt(scalex * scaley);
          if (!rotating) {
            pos = rglwidgetClass.multVM(pos, origMV);
            pos = rglwidgetClass.multVM(pos, origPR);
            this.mvMatrix.scale(scalex, scaley, scale);
          } else {
            scale = 4.0 * scale * subscene.par3d.zoom;
            this.mvMatrix.scale(scale, scale, scale);
          }
          this.mvMatrix.translate(pos[0]/pos[3], pos[1]/pos[3], pos[2]/pos[3]);
          if (rotating)
            this.mvMatrix.multRight(origMV);
        } else {
          if (!rotating) {
            pos = rglwidgetClass.multVM(pos, origMV);
            this.mvMatrix.translate(pos[0]/pos[3], pos[1]/pos[3], pos[2]/pos[3]);
          } else {
            this.mvMatrix.translate(pos[0]/pos[3], pos[1]/pos[3], pos[2]/pos[3]);
            this.mvMatrix.multRight(origMV);
          }
        }
        this.setnormMatrix2();
        this.setprmvMatrix();
      
        j = iOrig % obj.shapefirst.length;
        var first = obj.shapefirst[j];
        
        for (i=0; i < obj.shapelens[j]; i++)
          if (this.opaquePass)
            result = result.concat(this.drawObjId(obj.objects[first + i], subscene.id, context.concat(j)));
          else
            this.drawObjId(obj.objects[i], subscene.id, context);
      }
      this.normMatrix = savenorm;
      this.mvMatrix = origMV;
      if (fixed_size && !rotating)
        this.prMatrix = origPR;
      if (origPRMV !== null)
        this.prmvMatrix = origPRMV;
      return result;
    };
    
    /**
     * Draw object that might be in margin
     * @param { Object } obj - text object to draw
     * @param { Object } subscene - subscene holding it
     * @param { Object } context - context for drawing
     */
    rglwidgetClass.prototype.drawMarginal = function(obj, subscene, context) {
      var margin = obj.material.margin;
 
      if (typeof margin !== "undefined") 
        if (!this.marginVecToDataVec(obj, subscene))
          return [];
          
      return this.drawSimple(obj, subscene, context);
    };
    
    /**
     * Draw bounding box and decorations
     * @param { Object } obj - bboxdeco to draw
     * @param { Object } subscene - subscene holding it
     * @param { Object } context - context for drawing
     */
    rglwidgetClass.prototype.drawBBox = function(obj, subscene, context) {
      var flags = obj.flags,
          is_transparent = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent),
          scale, bbox, indices,
          enabled = {}, drawing,
          result = [], idx, center, edges,
          saved;

      if (!obj.initialized)
        this.initBBox(obj);
      
      is_transparent = is_transparent || obj.someHidden;

      if (!this.opaquePass && !is_transparent)
        return result;
      
      this.setBbox(obj, subscene);
      
      saved = this.setBBoxMatrices(obj);
      
      bbox = obj.bbox;
      center = obj.center;

      scale = [bbox[1]-bbox[0], bbox[3]-bbox[2], bbox[5]-bbox[4]];

      if (!obj.cube.initialized) {
        this.initObj(obj.cube);
      }

      if (this.opaquePass) {
        context = context.slice();
        context.push(obj.id);
      } 
      
      drawing = this.opaquePass !== is_transparent;
      this.cube.onecolor = obj.cube.onecolor;
      this.initShapeFromObj(this.cube, obj.cube);

      if (!this.opaquePass)
        indices = context.indices;

      if (this.opaquePass)
        idx = 0;
      else
        idx = context.subid;
      if (typeof idx === "undefined")
        console.error("idx is undefined");

      if (drawing) {
        this.drawSimple(this.cube, subscene, context);
      } else 
        result = result.concat(this.getCubePieces(context, obj));

      if (!obj.ticks.initialized) {
        obj.ticks.locations = this.getTickLocations(obj);
        obj.ticks.edges = undefined;
      }
      edges = this.getTickEdges(this.prmvMatrix);
      if (obj.needsAxisCallback) 
        this.doAxisCallback(obj, edges);
      if (!obj.ticks.edges || edges.toString() !== obj.ticks.edges.toString()) {
        obj.ticks.edges = edges;
        this.getTickVertices(obj.ticks);
        this.placeTickLabels(obj);
        this.setTickLabels(obj);
      }
      if (!obj.ticks.initialized) {
        this.initObj(obj.ticks);
        this.initObj(obj.labels);
      }
        
      if (drawing) {
        this.drawSimple(obj.ticks, subscene, context);
        this.drawSimple(obj.labels, subscene, context);

        this.disableArrays(obj, enabled);
      } else {
        result = result.concat(this.drawSimple(obj.ticks, subscene, context));
        result = result.concat(this.drawSimple(obj.labels, subscene, context));
      }

      this.restoreBBoxMatrices(saved);
        
      return result;
    };
    
    /**
     * Use ids to choose object to draw
     * @param { numeric } id - object to draw
     * @param { numeric } subscene
     * @param { array } context
     */   
    rglwidgetClass.prototype.drawObjId = function(id, subsceneid, context) {
      if (typeof id !== "number")
        this.alertOnce("drawObjId id is "+typeof id);

      return this.drawObj(this.getObj(id), this.getObj(subsceneid), context);
   };
   
    /**
     * Draw an object in a subscene
     * @param { object } obj - object to draw
     * @param { object } subscene
     * @param { array } context
     */
    rglwidgetClass.prototype.drawObj = function(obj, subscene, context) {
      switch(obj.type) {
        case "abclines":
        case "surface":
          return this.drawSimple(obj, subscene, context);
        case "points":
        case "lines":  
        case "triangles":
        case "quads":
        case "text":
          return this.drawMarginal(obj, subscene, context);
        case "linestrip":
          return this.drawLinestrip(obj, subscene, context);
        case "planes":
          return this.drawPlanes(obj, subscene, context);
        case "spheres":
          return this.drawSpheres(obj, subscene, context);
        case "clipplanes":
          return this.drawClipplanes(obj);
        case "sprites":
          return this.drawSprites(obj, subscene, context);
        case "light":
          return [];
        case "bboxdeco":
          return this.drawBBox(obj, subscene, context);
      }
      
      console.error("drawObj for type = "+obj.type);
    };

    /**
     * Draw the background for a subscene
     * @param { number } id - id of background object
     * @param { number } subsceneid - id of subscene
     */
    rglwidgetClass.prototype.drawBackground = function(id, subsceneid, context) {
      var gl = this.gl || this.initGL(),
          obj = this.getObj(id),
          subscene,
          bg, i, savepr, saveinvpr, savemv, savenorm, m, bbox, result = [], 
          savedm = gl.getParameter(gl.DEPTH_WRITEMASK),
          savedt = gl.isEnabled(gl.DEPTH_TEST),
          saveblend = gl.isEnabled(gl.BLEND);

      if (!obj.initialized)
        this.initObj(obj);

      if (obj.colors.length) {
        bg = obj.colors[0];
        gl.depthMask(true);
        gl.clear(gl.DEPTH_BUFFER_BIT);
        gl.clearColor(bg[0], bg[1], bg[2], bg[3]);
        gl.clear(gl.COLOR_BUFFER_BIT);
        this.fogColor = bg;
      } else {
        this.fogColor = [0,0,0,0];
        obj.colors = [[0,0,0,0]];
      }
  
      this.fogType = obj.fogtype;
      this.fogScale = obj.fogscale;
      gl.disable(gl.BLEND);
      gl.disable(gl.DEPTH_TEST);
      gl.depthMask(false);
      if (typeof obj.quad !== "undefined") {
        savepr = this.prMatrix;
        saveinvpr = this.invPrMatrix;
        savemv = this.mvMatrix;
        savenorm = this.normMatrix;
        this.prMatrix = new CanvasMatrix4();
        this.invPrMatrix = new CanvasMatrix4();
        this.mvMatrix = new CanvasMatrix4();
        this.normMatrix = new CanvasMatrix4();
        for (i=0; i < obj.quad.length; i++)
          result = result.concat(this.drawObjId(obj.quad[i], subsceneid));
        this.prMatrix = savepr;
        this.invPrMatrix = saveinvpr;
        this.mvMatrix = savemv;
        this.normMatrix = savenorm;

      } else if (obj.sphere) {
        subscene = this.getObj(subsceneid);
        savemv = this.mvMatrix;
        savenorm = this.normMatrix;
        bbox = subscene.par3d.bbox;
        var center = [(bbox[0] + bbox[1])/2, 
                  (bbox[2] + bbox[3])/2, 
                  (bbox[4] + bbox[5])/2, 1],
            scale = subscene.par3d.scale,
            ranges = [bbox[1] - bbox[0], 
                  bbox[3] - bbox[2],
                  bbox[5] - bbox[4]],
            avgscale = rglwidgetClass.vlen(ranges)/Math.sqrt(3),
            aspect = [ranges[0]*scale[0]/avgscale,
                      ranges[1]*scale[1]/avgscale,
                      ranges[2]*scale[2]/avgscale],
            maxaspect = Math.max(aspect[0], aspect[1], aspect[2]),
            zoom = subscene.par3d.zoom;
        m = new CanvasMatrix4();
        m.rotate(90, 1, 0, 0);
        m.scale(zoom*2.0*maxaspect*ranges[0]/aspect[0], 
                zoom*2.0*maxaspect*ranges[1]/aspect[1],
                zoom*2.0*maxaspect*ranges[2]/aspect[2]);
        m.translate(center[0], center[1], center[2]);
        m.multRight(savemv);
        center = rglwidgetClass.multVM(center, savemv);
        m.translate(-center[0], -center[1], -center[2]);
        m.scale(1, 1, 0.25/zoom);
        m.translate(center[0], center[1], center[2]);
        this.mvMatrix = m;
        this.initShapeFromObj(this.sphere, obj);
        this.sphere.onecolor = obj.colors.length > 1 ? obj.colors[1] : obj.colors[0];
        
        this.normMatrix = new CanvasMatrix4();
        
        this.setnormMatrix2();
        this.setprmvMatrix();
        
        result = result.concat(this.drawSimple(this.sphere, subscene, context));
        this.mvMatrix = savemv;
        this.normMatrix = savenorm;
      }
      gl.depthMask(savedm);
      if (savedt)
        gl.enable(gl.DEPTH_TEST);
      if (saveblend)
        gl.enable(gl.BLEND);
      return result;
    };

    /**
     * Draw a subscene
     * @param { number } subsceneid - id of subscene
     * @param { array } context 
     */
    rglwidgetClass.prototype.drawSubscene = function(subsceneid, context) {
      var sub = this.getObj(subsceneid),
          objects = this.scene.objects,
          clipids = sub.clipplanes,
          subids = sub.objects,
          subscene_has_faces = false,
          subscene_needs_sorting = false,
          flags, i, obj, result = [];
          
      if (sub.par3d.skipRedraw)
        return result;
      
      if (this.opaquePass) {
        for (i=0; i < subids.length; i++) {
      	  obj = objects[subids[i]];
          flags = obj.flags;
          if (typeof flags !== "undefined") {
            subscene_has_faces = subscene_has_faces || 
                            (rglwidgetClass.isSet(flags, rglwidgetClass.f_is_lit) &&
                            !rglwidgetClass.isSet(flags, rglwidgetClass.f_fixed_quads));
            obj.is_transparent = obj.someHidden || 
              rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent);
            subscene_needs_sorting = subscene_needs_sorting || 
              obj.is_transparent ||
              rglwidgetClass.isSet(flags, rglwidgetClass.f_depth_sort);
          }
        }
      }

      this.setViewport(subsceneid);

      this.setprMatrix(subsceneid);
      this.setInvPrMatrix();
      this.setmvMatrix(subsceneid);
      this.setnormMatrix2();
      this.setprmvMatrix();
      this.invMatrix = new CanvasMatrix4(this.mvMatrix);
      this.invMatrix.invert();
      
      if (this.opaquePass) {
        context = context.slice();
        context.push(subsceneid);
        
        this.doBlending(false);
        this.subsceneid = subsceneid;
        if (typeof this.sphere !== "undefined") // reset this.sphere.fastpieces; it will be recreated if needed
          this.sphere.fastpieces = undefined;
        if (typeof sub.backgroundId !== "undefined")
          result = result.concat(this.drawBackground(sub.backgroundId, subsceneid, context));
      }

      if (subids.length) {
            
        if (clipids.length > 0) {
          for (i = 0; i < clipids.length; i++)
            this.drawObjId(clipids[i], subsceneid);
        }
        
        subids = sub.opaque.concat(sub.transparent);
        if (this.opaquePass) {
          for (i = 0; i < subids.length; i++)
            result = result.concat(this.drawObjId(subids[i], subsceneid, context));
          subids = sub.subscenes;
          for (i = 0; i < subids.length; i++)
            result = result.concat(this.drawSubscene(subids[i], context));
        }
      }
      return result;
    };
    
    /**
     * Set the context for drawing transparently
     * @param { array } context
     */
    rglwidgetClass.prototype.setContext = function(context) {
      var result = [], objid, obj, type;
      context = context.slice();
      context.reverse();
      while (context.length > 0) {
        objid = context.pop();
        obj = this.getObj(objid);
        type = obj.type;
        switch (type) {
          case "subscene":
            this.drawSubscene(objid, false);
            break;
          case "sprites":
            result = result.concat(context.pop());
            break;
          case "spheres":
            // this.initSphereFromObj(obj);  // FIXME:  not needed?
            break;
          case "bboxdeco":
            result = result.concat(context.pop());
            break;
          default:
            console.error("bad type '", type, "' in setContext");
        }
      }
      return result;
    };
    
    /**
     * Draw the transparent pieces of a scene
     * @param {object} pieces
     */
    rglwidgetClass.prototype.drawPieces = function(pieces) {
      var i, prevcontext = [], context;
      for (i = 0; i < pieces.length; i++) {
        context = pieces[i].context.slice();
        if (context !== prevcontext) {
          prevcontext = context.slice();
          context = this.setContext(context);
          this.doBlending(true, pieces[i].objid);
        }
        this.drawObjId(pieces[i].objid, this.subsceneid, 
                       pieces[i]);
      }
    };
 
    /**
     * Draw the whole scene
     */
    rglwidgetClass.prototype.drawScene = function() {
      var wasDrawing = this.startDrawing(),
          pieces;
      if (!wasDrawing) {
        if (this.select.state !== "inactive")
          this.selectionChanged();

        this.doStartScene();
        this.opaquePass = true;
        pieces = this.drawSubscene(this.scene.rootSubscene, []);
        this.opaquePass = false;
        pieces = this.sortPieces(pieces);
        pieces = this.mergePieces(pieces);
        this.drawPieces(pieces);
      }
      this.stopDrawing(wasDrawing);
    };
</script>
<script>
    /**
     * Change the displayed subset
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The subset control data.
     */
    rglwidgetClass.prototype.subsetSetter = function(el, control) {
      if (typeof control.subscenes === "undefined" ||
          control.subscenes === null)
        control.subscenes = this.scene.rootSubscene;
      var value = Math.round(control.value),
          subscenes = [].concat(control.subscenes),
          fullset = [].concat(control.fullset),
          i, j, subsceneid,
          adds = [], deletes = [];
      if (rglwidgetClass.missing(value))
        value = control.value = 0;
      if (control.accumulate)
        for (i=0; i <= value; i++)
          adds = adds.concat(control.subsets[i]);
      else
        adds = adds.concat(control.subsets[value]);
      deletes = fullset.filter(function(x) { return adds.indexOf(x) < 0; });
      for (i = 0; i < subscenes.length; i++) {
        subsceneid = subscenes[i];
        if (typeof this.getObj(subsceneid) === "undefined")
          this.alertOnce("typeof object is undefined");
        for (j = 0; j < adds.length; j++)
          this.addToSubscene(adds[j], subsceneid);
        for (j = 0; j < deletes.length; j++)
          this.delFromSubscene(deletes[j], subsceneid);
      }
    };

    /**
     * Change the requested property
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The property setter control data.
     */
    rglwidgetClass.prototype.propertySetter = function(el, control)  {
      var value = control.value,
          values = [].concat(control.values),
          svals = [].concat(control.param),
          direct = values[0] === null,
          entries = [].concat(control.entries),
          ncol = entries.length,
          nrow = values.length/ncol,
          properties = rglwidgetClass.repeatToLen(control.properties, ncol),
          objids = rglwidgetClass.repeatToLen(control.objids, ncol),
          property, objid = objids[0],
          obj = this.getObj(objid),
          propvals, i, j, v1, v2, p, entry, gl, needsBinding,
          newprop, newid,

          getPropvals = function() {
            if (property === "userMatrix")
              return obj.par3d.userMatrix.getAsArray();
            else if (property === "scale" || property === "FOV" || property === "zoom")
              return [].concat(obj.par3d[property]);
            else
              return [].concat(obj[property]);
          },

          putPropvals = function(newvals) {
            if (newvals.length === 1)
              newvals = newvals[0];
            if (property === "userMatrix")
              obj.par3d.userMatrix.load(newvals);
            else if (property === "scale" || property === "FOV" || property === "zoom")
              obj.par3d[property] = newvals;
            else
              obj[property] = newvals;
          };

      if (direct && typeof value === "undefined")
        return;

      if (control.interp) {
        values = values.slice(0, ncol).concat(values).
                 concat(values.slice(ncol*(nrow-1), ncol*nrow));
        svals = [-Infinity].concat(svals).concat(Infinity);
        for (i = 1; i < svals.length; i++) {
          if (value <= svals[i]) {
            if (svals[i] === Infinity)
              p = 1;
            else
              p = (svals[i] - value)/(svals[i] - svals[i-1]);
            break;
          }
        }
      } else if (!direct) {
        value = Math.round(value);
      }

      for (j=0; j<entries.length; j++) {
        entry = entries[j];
        newprop = properties[j];
        newid = objids[j];

        if (newprop !== property || newid !== objid) {
          if (typeof property !== "undefined")
            putPropvals(propvals);
          property = newprop;
          objid = newid;
          obj = this.getObj(objid);
          propvals = getPropvals();
        }
        if (control.interp) {
          v1 = values[ncol*(i-1) + j];
          v2 = values[ncol*i + j];
          this.setElement(propvals, entry, p*v1 + (1-p)*v2);
        } else if (!direct) {
          this.setElement(propvals, entry, values[ncol*value + j]);
        } else {
          this.setElement(propvals, entry, value[j]);
        }
      }
      putPropvals(propvals);

      needsBinding = [];
      for (j=0; j < entries.length; j++) {
        if (properties[j] === "values" &&
            needsBinding.indexOf(objids[j]) === -1) {
          needsBinding.push(objids[j]);
        }
      }
      for (j=0; j < needsBinding.length; j++) {
        gl = this.gl || this.initGL();
        obj = this.getObj(needsBinding[j]);
        gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
        gl.bufferData(gl.ARRAY_BUFFER, obj.values, gl.STATIC_DRAW);
      }
    };

    /**
     * Change the requested vertices
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The vertext setter control data.
     */
    rglwidgetClass.prototype.vertexSetter = function(el, control)  {
      var svals = [].concat(control.param),
          j, k, p, a, propvals, stride, ofs, obj, entry,
          attrib, vertex, varies,
          ofss    = {x:"vofs", y:"vofs", z:"vofs",
                     red:"cofs", green:"cofs", blue:"cofs",
                     alpha:"cofs", radii:"radofs",
                     nx:"nofs", ny:"nofs", nz:"nofs",
                     ox:"oofs", oy:"oofs", oz:"oofs",
                     ts:"tofs", tt:"tofs"},
          pos     = {x:0, y:1, z:2,
                     red:0, green:1, blue:2,
                     alpha:3,radii:0,
                     nx:0, ny:1, nz:2,
                     ox:0, oy:1, oz:2,
                     ts:0, tt:1},
        values = control.values,
        direct = values === null,
        ncol,
        interp = control.interp,
        vertices = [].concat(control.vertices),
        attributes = [].concat(control.attributes),
        value = control.value, newval, aliases, alias;

      ncol = Math.max(vertices.length, attributes.length);

      if (!ncol)
        return;

      vertices = rglwidgetClass.repeatToLen(vertices, ncol);
      attributes = rglwidgetClass.repeatToLen(attributes, ncol);

      if (direct)
        interp = false;

      /* JSON doesn't pass Infinity */
      svals[0] = -Infinity;
      svals[svals.length - 1] = Infinity;

      for (j = 1; j < svals.length; j++) {
        if (value <= svals[j]) {
          if (interp) {
            if (svals[j] === Infinity)
              p = 1;
            else
              p = (svals[j] - value)/(svals[j] - svals[j-1]);
          } else {
            if (svals[j] - value > value - svals[j-1])
              j = j - 1;
          }
          break;
        }
      }

      obj = this.getObj(control.objid);
      // First, make sure color attributes vary in original
      if (typeof obj.vOffsets !== "undefined") {
      	varies = true;
        for (k = 0; k < ncol; k++) {
          attrib = attributes[k];
          if (typeof attrib !== "undefined") {
            ofs = obj.vOffsets[ofss[attrib]];
            if (ofs < 0) {
              switch(attrib) {
              	case "alpha":
              	case "red":
              	case "green":
              	case "blue":
              	  obj.colors = [obj.colors[0], obj.colors[0]];
              	  break;
              }
              varies = false;
            }
          }
        }
        if (!varies)
          this.initObjId(control.objid);
      }
      propvals = obj.values;
      aliases = obj.alias;
      if (typeof aliases === "undefined")
        aliases = [];
      for (k=0; k<ncol; k++) {
        if (direct) {
          newval = value;
        } else if (interp) {
          newval = p*values[j-1][k] + (1-p)*values[j][k];
        } else {
          newval = values[j][k];
        }      	
        attrib = attributes[k];
        vertex = vertices[k];
        alias = aliases[vertex];
        if (obj.type === "planes" || obj.type === "clipplanes") {
          ofs = ["nx", "ny", "nz", "offset"].indexOf(attrib);
          if (ofs >= 0) {
            if (ofs < 3) {
              if (obj.normals[vertex][ofs] !== newval) {  // Assume no aliases here...
              	obj.normals[vertex][ofs] = newval;
              	obj.initialized = false;
              }
            } else {
              if (obj.offsets[vertex][0] !== newval) {
              	obj.offsets[vertex][0] = newval;
              	obj.initialized = false;
              }
            }
            continue;
          }
        }
        // Not a plane setting...
        ofs = obj.vOffsets[ofss[attrib]];
        if (ofs < 0)
          this.alertOnce("Attribute '"+attrib+"' not found in object "+control.objid);
        else {
          stride = obj.vOffsets.stride;
          ofs = ofs + pos[attrib];
          entry = vertex*stride + ofs;
          propvals[entry] = newval;
          if (typeof alias !== "undefined")
            for (a = 0; a < alias.length; a++)
              propvals[alias[a]*stride + ofs] = newval;
        }
      }
      if (typeof obj.buf !== "undefined") {
        var gl = this.gl || this.initGL();
        gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
        gl.bufferData(gl.ARRAY_BUFFER, propvals, gl.STATIC_DRAW);
      }
    };

    /**
     * Change the requested vertex properties by age
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The age setter control data.
     */
    rglwidgetClass.prototype.ageSetter = function(el, control) {
      var objids = [].concat(control.objids),
          nobjs = objids.length,
          time = control.value,
          births = [].concat(control.births),
          ages = [].concat(control.ages),
          steps = births.length,
          j = Array(steps),
          p = Array(steps),
          i, k, l, age, j0, propvals, stride, ofs, objid, obj,
          attrib, dim, varies, alias, aliases, a, d,
          attribs = ["colors", "alpha", "radii", "vertices",
                     "normals", "origins", "texcoords",
                     "x", "y", "z",
                     "red", "green", "blue"],
          ofss    = ["cofs", "cofs", "radofs", "vofs",
                     "nofs", "oofs", "tofs",
                     "vofs", "vofs", "vofs",
                     "cofs", "cofs", "cofs"],
          dims    = [3,1,1,3,
                     3,2,2,
                     1,1,1,
                     1,1,1],
          pos     = [0,3,0,0,
                     0,0,0,
                     0,1,2,
                     0,1,2];
      /* Infinity doesn't make it through JSON */
      ages[0] = -Infinity;
      ages[ages.length-1] = Infinity;
      for (i = 0; i < steps; i++) {
        if (births[i] !== null) {  // NA in R becomes null
          age = time - births[i];
          for (j0 = 1; age > ages[j0]; j0++);
          if (ages[j0] === Infinity)
            p[i] = 1;
          else if (ages[j0] > ages[j0-1])
            p[i] = (ages[j0] - age)/(ages[j0] - ages[j0-1]);
          else
            p[i] = 0;
          j[i] = j0;
        }
      }
      // First, make sure color attributes vary in original
      for (l = 0; l < nobjs; l++) {
      	objid = objids[l];
      	obj = this.getObj(objid);
      	varies = true;
        if (typeof obj.vOffsets === "undefined")
          continue;
        for (k = 0; k < attribs.length; k++) {
          attrib = control[attribs[k]];
          if (typeof attrib !== "undefined") {
            ofs = obj.vOffsets[ofss[k]];
            if (ofs < 0) {
              switch(attribs[k]) {
              	case "colors":
              	case "alpha":
              	case "red":
              	case "green":
              	case "blue":
              	  obj.colors = [obj.colors[0], obj.colors[0]];
              	  break;
              }
              varies = false;
            }
          }
        }
        if (!varies)
          this.initObjId(objid);
      }
      for (l = 0; l < nobjs; l++) {
        objid = objids[l];
        obj = this.getObj(objid);
        if (typeof obj.vOffsets === "undefined")
          continue;
        aliases = obj.alias;
        if (typeof aliases === "undefined")
          aliases = [];
        propvals = obj.values;
        stride = obj.vOffsets.stride;
        for (k = 0; k < attribs.length; k++) {
          attrib = control[attribs[k]];
          if (typeof attrib !== "undefined") {
            ofs = obj.vOffsets[ofss[k]];
            if (ofs >= 0) {
              dim = dims[k];
              ofs = ofs + pos[k];
              for (i = 0; i < steps; i++) {
              	alias = aliases[i];
                if (births[i] !== null) {
                  for (d=0; d < dim; d++) {
                    propvals[i*stride + ofs + d] = p[i]*attrib[dim*(j[i]-1) + d] + (1-p[i])*attrib[dim*j[i] + d];
                    if (typeof alias !== "undefined")
                      for (a=0; a < alias.length; a++)
                        propvals[alias[a]*stride + ofs + d] = propvals[i*stride + ofs + d];
                  }
                }
              }
            } else
              this.alertOnce("\'"+attribs[k]+"\' property not found in object "+objid);
          }
        }
        obj.values = propvals;
        if (typeof obj.buf !== "undefined") {
          var gl = this.gl || this.initGL();
          gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
          gl.bufferData(gl.ARRAY_BUFFER, obj.values, gl.STATIC_DRAW);
        }
      }
    };

    /**
     * Bridge to old style control
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The bridge control data.
     */
    rglwidgetClass.prototype.oldBridge = function(el, control) {
      var attrname, global = window[control.prefix + "rgl"];
      if (global)
        for (attrname in global)
          this[attrname] = global[attrname];
      window[control.prefix + "rgl"] = this;
    };

    /**
     * Set up a player control
     * @param { Object } el - The player control element
     * @param { Object } control - The player data.
     */
    rglwidgetClass.prototype.Player = function(el, control) {
      var
        self = this,
        components = [].concat(control.components),
        buttonLabels = [].concat(control.buttonLabels),

        Tick = function() { /* "this" will be a timer */
          var i,
              nominal = this.value,
              slider = this.Slider,
              labels = this.outputLabels,
              output = this.Output,
              step;
          if (typeof slider !== "undefined" && nominal !== slider.value)
            slider.value = nominal;
          if (typeof output !== "undefined") {
            step = Math.round((nominal - output.sliderMin)/output.sliderStep);
            if (labels !== null) {
              output.innerHTML = labels[step];
            } else {
              step = step*output.sliderStep + output.sliderMin;
              output.innerHTML = step.toPrecision(output.outputPrecision);
            }
          }
          for (i=0; i < this.actions.length; i++) {
            this.actions[i].value = nominal;
          }
          self.applyControls(el, this.actions, false);
          self.drawScene();
        },

        OnSliderInput = function() { /* "this" will be the slider */
          this.rgltimer.value = Number(this.value);
          this.rgltimer.Tick();
        },

        addSlider = function(min, max, step, value) {
          var slider = document.createElement("input");
          slider.type = "range";
          slider.min = min;
          slider.max = max;
          slider.step = step;
          slider.value = value;
          slider.oninput = OnSliderInput;
          slider.sliderActions = control.actions;
          slider.sliderScene = this;
          slider.className = "rgl-slider";
          slider.id = el.id + "-slider";
          el.rgltimer.Slider = slider;
          slider.rgltimer = el.rgltimer;
          el.appendChild(slider);
        },

        addLabel = function(labels, min, step, precision) {
          var output = document.createElement("output");
          output.sliderMin = min;
          output.sliderStep = step;
          output.outputPrecision = precision;
          output.className = "rgl-label";
          output.id = el.id + "-label";
          el.rgltimer.Output = output;
          el.rgltimer.outputLabels = labels;
          el.appendChild(output);
        },

        addButton = function(which, label, active) {
          var button = document.createElement("input"),
              onclicks = {Reverse: function() { this.rgltimer.reverse();},
                    Play: function() { this.rgltimer.play();
                                       this.value = this.rgltimer.enabled ? this.inactiveValue : this.activeValue; },
                   Slower: function() { this.rgltimer.slower(); },
                   Faster: function() { this.rgltimer.faster(); },
                   Reset: function() { this.rgltimer.reset(); },
              	   Step:  function() { this.rgltimer.step(); }
              };
          button.rgltimer = el.rgltimer;
          button.type = "button";
          button.value = label;
          button.activeValue = label;
          button.inactiveValue = active;
          if (which === "Play")
            button.rgltimer.PlayButton = button;
          button.onclick = onclicks[which];
          button.className = "rgl-button";
          button.id = el.id + "-" + which;
          el.appendChild(button);
        };

        if (typeof control.reinit !== "undefined" && control.reinit !== null) {
          control.actions.reinit = control.reinit;
        }
        el.rgltimer = new rgltimerClass(Tick, control.start, control.interval, control.stop,
                                        control.step, control.value, control.rate, control.loop, control.actions);
        for (var i=0; i < components.length; i++) {
          switch(components[i]) {
            case "Slider": addSlider(control.start, control.stop,
                                   control.step, control.value);
              break;
            case "Label": addLabel(control.labels, control.start,
                                   control.step, control.precision);
              break;
            default:
              addButton(components[i], buttonLabels[i], control.pause);
          }
        }
        el.rgltimer.Tick();
    };

    /**
     * Apply all registered controls
     * @param { Object } el - DOM element of the control
     * @param { Object } x - List of actions to apply
     * @param { boolean } [draw=true] - Whether to redraw after applying
     */
    rglwidgetClass.prototype.applyControls = function(el, x, draw) {
      var self = this, reinit = x.reinit, i, control, type;
      for (i = 0; i < x.length; i++) {
        control = x[i];
        type = control.type;
        self[type](el, control);
      }
      if (typeof reinit !== "undefined" && reinit !== null) {
        reinit = [].concat(reinit);
        for (i = 0; i < reinit.length; i++)
          self.getObj(reinit[i]).initialized = false;
      }
      if (typeof draw === "undefined" || draw)
        self.drawScene();
    };

    /**
     * Handler for scene change
     * @param { Object } message - What sort of scene change to do?
     */
    rglwidgetClass.prototype.sceneChangeHandler = function(message) {
      var self = document.getElementById(message.elementId).rglinstance,
          objs = message.objects, mat = message.material,
          root = message.rootSubscene,
          initSubs = message.initSubscenes,
          redraw = message.redrawScene,
          skipRedraw = message.skipRedraw,
          deletes, subs, allsubs = [], i,j;
      if (typeof message.delete !== "undefined") {
        deletes = [].concat(message.delete);
        if (typeof message.delfromSubscenes !== "undefined")
          subs = [].concat(message.delfromSubscenes);
        else
          subs = [];
        for (i = 0; i < deletes.length; i++) {
          for (j = 0; j < subs.length; j++) {
            self.delFromSubscene(deletes[i], subs[j]);
          }
          delete self.scene.objects[deletes[i]];
        }
      }
      if (typeof objs !== "undefined") {
        Object.keys(objs).forEach(function(key){
          key = parseInt(key, 10);
          self.scene.objects[key] = objs[key];
          self.initObjId(key);
          var obj = self.getObj(key),
              subs = [].concat(obj.inSubscenes), k;
          allsubs = allsubs.concat(subs);
          for (k = 0; k < subs.length; k++)
            self.addToSubscene(key, subs[k]);
        });
      }
      if (typeof mat !== "undefined") {
        self.scene.material = mat;
      }
      if (typeof root !== "undefined") {
        self.scene.rootSubscene = root;
      }
      if (typeof initSubs !== "undefined")
        allsubs = allsubs.concat(initSubs);
      allsubs = self.unique(allsubs);
      for (i = 0; i < allsubs.length; i++) {
        self.initSubscene(allsubs[i]);
      }
      if (typeof skipRedraw !== "undefined") {
        root = self.getObj(self.scene.rootSubscene);
        root.par3d.skipRedraw = skipRedraw;
      }
      if (redraw)
        self.drawScene();
    };
</script>
<script>    /**
     * Methods related to selection
     * @name ___METHODS_FOR_SELECTION___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Respond to brush change
     */
    rglwidgetClass.prototype.selectionChanged = function() {
      var i, j, k, id, subid = this.select.subscene, subscene,
          objids, obj,
          p1 = this.select.region.p1, p2 = this.select.region.p2,
          filter, selection = [], handle, keys, xmin, x, xmax, ymin, y, ymax, z, v,
          someHidden;
      if (!subid)
        return;
      subscene = this.getObj(subid);
      objids = subscene.objects;
      filter = this.scene.crosstalk.filter;
      this.setmvMatrix(subid);
      this.setprMatrix(subid);
      this.setprmvMatrix();
      xmin = Math.min(p1.x, p2.x);
      xmax = Math.max(p1.x, p2.x);
      ymin = Math.min(p1.y, p2.y);
      ymax = Math.max(p1.y, p2.y);
      for (i = 0; i < objids.length; i++) {
      	id = objids[i];
      	j = this.scene.crosstalk.id.indexOf(id);
      	if (j >= 0) {
      	  keys = this.scene.crosstalk.key[j];
      	  obj = this.getObj(id);
      	  someHidden = false;
      	  for (k = 0; k < keys.length; k++) {
      	    if (filter && filter.indexOf(keys[k]) < 0) {
      	      someHidden = true;
      	      continue;
      	    }
      	    v = [].concat(obj.vertices[k]).concat(1.0);
            v = rglwidgetClass.multVM(v, this.prmvMatrix);
            x = v[0]/v[3];
            y = v[1]/v[3];
            z = v[2]/v[3];
            if (xmin <= x && x <= xmax && ymin <= y && y <= ymax && -1.0 <= z && z <= 1.0) {
              selection.push(keys[k]);
            } else
              someHidden = true;
      	  }
      	  obj.someHidden = someHidden && (filter || selection.length);
      	  obj.initialized = false;
      	  /* Who should we notify?  Only shared data in the current subscene, or everyone? */
      	  if (!this.equalArrays(selection, this.scene.crosstalk.selection)) {
      	    handle = this.scene.crosstalk.sel_handle[j];
      	    handle.set(selection, {rglSubsceneId: this.select.subscene});
      	  }
      	}
      }
    };
    
    /**
     * Respond to selection or filter change from crosstalk
     * @param { Object } event - crosstalk event
     * @param { boolean } filter - filter or selection?
     */
    rglwidgetClass.prototype.selection = function(event, filter) {
      	var i, j, ids, obj, keys, crosstalk = this.scene.crosstalk,
      	    selection, someHidden;

      	// Record the message and find out if this event makes some objects have mixed values:
      	
      	crosstalk = this.scene.crosstalk;
      	
      	if (filter) {
      	  filter = crosstalk.filter = event.value;
      	  selection = crosstalk.selection;
      	} else {  
          selection = crosstalk.selection = event.value;
          filter = crosstalk.filter;
      	}
        ids = crosstalk.id;
        for (i = 0; i < ids.length ; i++) {
          obj = this.getObj(ids[i]);
          obj.initialized = false;
          keys = crosstalk.key[i];
          someHidden = false;
          for (j = 0; j < keys.length && !someHidden; j++) {
            if ((filter && filter.indexOf(keys[j]) < 0) ||
                (selection.length && selection.indexOf(keys[j]) < 0))
                someHidden = true;
          }
          obj.someHidden = someHidden;
        }
        this.drawScene();
    };
    
    /**
     * Clear the selection brush
     * @param { number } except - Subscene that should ignore this request
     */
    rglwidgetClass.prototype.clearBrush = function(except) {
      if (this.select.subscene !== except) {
        this.select.region = {p1: {x:Infinity, y:Infinity}, 
                              p2: {x:Infinity, y:Infinity}};
        this.selectionChanged();
        this.select.state = "inactive";
        this.delFromSubscene(this.scene.brushId, this.select.subscene);
      }
      this.drawScene();
    };
    
    /**
     * Set the vertices in the selection box object
     */
    rglwidgetClass.prototype.initSelection = function(id) {
      if (typeof this.select.region === "undefined")
        return;
      var obj = this.getObj(id),
          p1 = this.select.region.p1,
          p2 = this.select.region.p2;
          
      obj.vertices = [[p1.x, p1.y, 0.0],
                      [p2.x, p1.y, 0.0],
                      [p2.x, p2.y, 0.0],
                      [p1.x, p2.y, 0.0],
                      [p1.x, p1.y, 0.0]];
    };
</script>
<script>
/* globals rgltimerClass: true */

/**
 * The class of an rgl timer object
 * @class
*/

/**
 * Construct an rgltimerClass object
 * @constructor
 * @param { function } Tick - action when timer fires
 * @param { number } startTime - nominal start time in seconds
 * @param { number } interval - seconds between updates
 * @param { number } stopTime - nominal stop time in seconds
 * @param { number } stepSize - nominal step size
 * @param { number } value - current nominal time
 * @param { number } rate - nominal units per second
 * @param { string } loop - "none", "cycle" or "oscillate"
 * @param { Object } actions - list of actions
 */
rgltimerClass = function(Tick, startTime, interval, stopTime, stepSize, value, rate, loop, actions) {
  this.enabled = false;
  this.timerId = 0;
  /** nominal start time in seconds */
  this.startTime = startTime;   
  /** current nominal time */      
  this.value = value;
  /** seconds between updates */                 
  this.interval = interval;
  /** nominal stop time */           
  this.stopTime = stopTime;
  /** nominal step size */           
  this.stepSize = stepSize;
  /** nominal units per second */           
  this.rate = rate;
  /** "none", "cycle", or "oscillate" */                   
  this.loop = loop;
  /** real world start time */                   
  this.realStart = undefined;
  /** multiplier for fast-forward or reverse */         
  this.multiplier = 1;                
  this.actions = actions;
  this.Tick = Tick;
};


    /**
     * Methods related to players
     * @name ___METHODS_FOR_PLAYERS___
     * @memberof rgltimerClass
     * @kind function
     * @instance
     */

  /**
   * Start playing
   * @memberof rgltimerClass
   */
  rgltimerClass.prototype.play = function() {
    if (this.enabled) {
      this.enabled = false;
      window.clearInterval(this.timerId);
      this.timerId = 0;
      return;
    }
    var tick = function(self) {
      var now = new Date();
      self.value = self.multiplier*self.rate*(now - self.realStart)/1000 + self.startTime;
      self.forceToRange();
      if (typeof self.Tick !== "undefined") {
        self.Tick(self.value);
      }

    };
    this.realStart = new Date() - 1000*(this.value - this.startTime)/this.rate/this.multiplier;
    this.timerId = window.setInterval(tick, 1000*this.interval, this);
    this.enabled = true;
  };

  /**
   * Force value into legal range
   */
  rgltimerClass.prototype.forceToRange = function() {
    if (this.value > this.stopTime + this.stepSize/2 || this.value < this.startTime - this.stepSize/2) {
      if (!this.loop) {
        this.reset();
      } else {
        var cycle = this.stopTime - this.startTime + this.stepSize,
            newval = (this.value - this.startTime) % cycle + this.startTime;
        if (newval < this.startTime) {
          newval += cycle;
        }
        this.realStart += (this.value - newval)*1000/this.multiplier/this.rate;
        this.value = newval;
      }
    }
  };

  /**
   * Reset to start values
   */
  rgltimerClass.prototype.reset = function() {
    this.value = this.startTime;
    this.newmultiplier(1);
    if (typeof this.Tick !== "undefined") {
        this.Tick(this.value);
    }
    if (this.enabled)
      this.play();  /* really pause... */
    if (typeof this.PlayButton !== "undefined")
      this.PlayButton.value = "Play";
  };

  /**
   * Increase the multiplier to play faster
   */
  rgltimerClass.prototype.faster = function() {
    this.newmultiplier(Math.SQRT2*this.multiplier);
  };

  /**
   * Decrease the multiplier to play slower
   */
  rgltimerClass.prototype.slower = function() {
    this.newmultiplier(this.multiplier/Math.SQRT2);
  };

  /**
   * Change sign of multiplier to reverse direction
   */
  rgltimerClass.prototype.reverse = function() {
    this.newmultiplier(-this.multiplier);
  };

  /**
   * Set multiplier for play speed
   * @param { number } newmult - new value
   */
  rgltimerClass.prototype.newmultiplier = function(newmult) {
    if (newmult !== this.multiplier) {
      this.realStart += 1000*(this.value - this.startTime)/this.rate*(1/this.multiplier - 1/newmult);
      this.multiplier = newmult;
    }
  };

  /**
   * Take one step
   */
  rgltimerClass.prototype.step = function() {
    this.value += this.rate*this.multiplier;
    this.forceToRange();
    if (typeof this.Tick !== "undefined")
      this.Tick(this.value);
  };
</script>
<script>/**
 * Pretty function from R
 * @name ___PRETTY_FROM_R___
 * @memberof rglwidgetClass
 * @kind function
 * @instance
 */


/* This file is translated from pretty.c, which was
 taken from the R sources, r61744 of src/appl/pretty.c,
 with minimal changes */

/*
 *  R : A Computer Language for Statistical Data Analysis
 *  Copyright (C) 1995-2012  The R Core Team
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, a copy is available at
 *  http://www.r-project.org/Licenses/
 */

/**     
 * Construct pretty values to cover an interval
 * @param { number } lo - lower end of interval
 * @param { number } up - upper end of interval
 * @param { number } ndiv - requested number of divisions
 * @param { number } min_n - minimum divisions
 * @param { number } shrink_sml - if too many cells, amount to shrink by
 * @param { number } high_u_fact - bias in favour of larger units
 * @param { number } eps_correction - correction to bounds
 * @param { Boolean } return_bounds - whether to return bounds
 * @description
 * Pretty Intervals

 * Constructs m "pretty" values which cover the given interval	*lo <= *up
 *	m ~= *ndiv + 1	(i.e., ndiv := approximate number of INTERVALS)
 *
 * It is not quite clear what should happen for	 *lo = *up;
 * S itself behaves quite funilly, then.
 *
 * In my opinion, a proper 'pretty' should always ensure
 * *lo < *up, and hence *ndiv >=1 in the result.
 * However, in S and here, we allow  *lo == *up, and *ndiv = 0.
 * Note however, that we are NOT COMPATIBLE to S. [Martin M.]
 *
 * NEW (0.63.2): ns, nu are double (==> no danger of integer overflow)
 *
 * We determine
 * if the interval (up - lo) is ``small'' [<==>	 i_small == TRUE, below].
 * For the ``i_small'' situation, there is a parameter  shrink_sml,
 * the factor by which the "scale" is shrunk.		~~~~~~~~~~
 * It is advisable to set it to some (smaller) integer power of 2,
 * since this enables exact floating point division.
 */
rglwidgetClass.prototype.R_pretty = function(
  lo, up, ndiv, min_n, shrink_sml, high_u_fact,
  eps_correction, return_bounds) {
  /* From version 0.65 on, we had rounding_eps := 1e-5, before, r..eps = 0
   * 1e-7 is consistent with seq.default() */
  var rounding_eps = 1e-7,  h = high_u_fact[0],
                                           h5 = high_u_fact[1], 
                                                           dx, cell, unit, base, U, ns, nu, k, i_small,
                                                           DBL_EPSILON = Number.EPSILON,
                                                           DBL_MIN = Number.MIN_VALUE,
                                                           DBL_MAX = Number.MAX_VALUE;
  
  dx = up - lo;
  /* cell := "scale"	here */
  if (dx === 0 && up === 0) { /*  up == lo == 0	 */
  cell = 1;
    i_small = true;
  } else {
    cell = Math.max(Math.abs(lo), Math.abs(up));
    /* U = upper bound on cell/unit */
    U = (1 + (h5 >= 1.5*h+0.5)) ? 1/(1+h) : 1.5/(1+h5);
    /* added times 3, as several calculations here */
    i_small = dx < cell * U * Math.max(1,ndiv) * DBL_EPSILON *3;
  }
  
  /*OLD: cell = FLT_EPSILON+ dx / *ndiv; FLT_EPSILON = 1.192e-07 */
  if(i_small) {
    if(cell > 10)
      cell = 9 + cell/10;
    cell *= shrink_sml;
    if(min_n > 1) cell /= min_n;
  } else {
    cell = dx;
    if(ndiv > 1) cell /= ndiv;
  }
  
  if(cell < 20*DBL_MIN) {
    /* warning(_("Internal(pretty()): very small range.. corrected")); */
    cell = 20*DBL_MIN;
  } else if(cell * 10 > DBL_MAX) {
    /* warning(_("Internal(pretty()): very large range.. corrected")); */
    cell = 0.1*DBL_MAX;
  }
  base = Math.pow(10, Math.floor(Math.log10(cell))); /* base <= cell < 10*base */
    
    /* unit : from { 1,2,5,10 } * base
     *	 such that |u - cell| is small,
     * favoring larger (if h > 1, else smaller)  u  values;
     * favor '5' more than '2'  if h5 > h  (default h5 = .5 + 1.5 h) */
    unit = base;
    if((U = 2*base)-cell <  h*(cell-unit)) { unit = U;
      if((U = 5*base)-cell < h5*(cell-unit)) { unit = U;
        if((U =10*base)-cell <  h*(cell-unit)) unit = U; }}
    /* Result: c := cell,  u := unit,  b := base
     *	c in [	1,	      (2+ h) /(1+h) ] b ==> u=  b
     *	c in ( (2+ h)/(1+h),  (5+2h5)/(1+h5)] b ==> u= 2b
     *	c in ( (5+2h)/(1+h), (10+5h) /(1+h) ] b ==> u= 5b
     *	c in ((10+5h)/(1+h),	         10 ) b ==> u=10b
     *
     *	===>	2/5 *(2+h)/(1+h)  <=  c/u  <=  (2+h)/(1+h)	*/
    
    ns = Math.floor(lo/unit+rounding_eps);
    nu = Math.ceil (up/unit-rounding_eps);
    
    if(eps_correction && (eps_correction > 1 || !i_small)) {
      if(lo !== 0.0) lo *= (1- DBL_EPSILON); else lo = -DBL_MIN;
      if(up !== 0.0) up *= (1+ DBL_EPSILON); else up = +DBL_MIN;
    }
    
    while(ns*unit > lo + rounding_eps*unit) ns--;
    
    while(nu*unit < up - rounding_eps*unit) nu++;
    
    k = Math.floor(0.5 + nu - ns);
    if(k < min_n) {
      /* ensure that	nu - ns	 == min_n */
      
      k = min_n - k;
      if(ns >= 0) {
        nu += k/2;
        ns -= k/2 + k%2;/* ==> nu-ns = old(nu-ns) + min_n -k = min_n */
      } else {
        ns -= k/2;
        nu += k/2 + k%2;
      }
      ndiv = min_n;
    } else {
      ndiv = k;
    }
    if(return_bounds) { /* if()'s to ensure that result covers original range */
      if(ns * unit < lo) lo = ns * unit;
      if(nu * unit > up) up = nu * unit;
    } else {
      lo = ns;
      up = nu;
    }
    return {lo:lo, up:up, ndiv:ndiv, unit:unit};
};
</script>
<script>    /**
     * Methods related to axes
     * @name ___METHODS_FOR_AXES___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Choose edges for ticks
     * @param { Matrix } prmv - projection-model-view matrix
     */
    rglwidgetClass.prototype.getTickEdges = function(prmv){
      var vertices = [[0,0,0,1], [0,0,1,1],
                      [0,1,0,1], [0,1,1,1],
                      [1,0,0,1], [1,0,1,1],
                      [1,1,0,1], [1,1,1,1]], 
           dim, i, j, k, edges, hull, step, result = [], proj = [],

        // Filter to edges that are on sides that would
        // be shown with a filled backing.
        
      has_back = function(edge) {
          var normals = [[], []],
              verts = [vertices[edge[0]], 
                       vertices[edge[1]]], 
              normal, m, n;
          n = 0;
          for (m=0; m<3; m++) {
            if (verts[0][m] === verts[1][m]) {
              normals[n] = [0,0,0,1];
              normals[n][m] = 2*verts[0][m] - 1;
              n++;
            }
          }
          for (n=0; n<2; n++) {
            normal = rglwidgetClass.multVM(normals[n], self.normMatrix);
            if (normal[2] < 0 ||
                (normal[2] === 0 && normal[0] < 0))
              return true;
          }
          return false;
        }, self = this;
        
      for (i = 0; i < vertices.length; i++) {
        proj[i] = rglwidgetClass.multVM(vertices[i], prmv);
        proj[i][0] = proj[i][0]/proj[i][3];
        proj[i][1] = proj[i][1]/proj[i][3];
        proj[i][2] = i;
      }
      hull = rglwidgetClass.chull(proj.slice());  
      for (i = 0; i < hull.length; i++)
        hull[i] = hull[i][2];
      hull.push(hull[0]);
      for (dim = 0; dim < 3; dim++) { 
        edges = [];
        step = Math.pow(2, 2-dim);
        for (i = 0; i < 4; i++) {
          j = (dim === 0) ? i : (dim === 1) ? i + 2*(i>1) : 2*i;
          for (k = 0; k < hull.length - 1; k++) {
            if ((hull[k] === j && hull[k+1] === j + step) ||
                (hull[k] === j+step && hull[k+1] === j))
          
              edges.push([j, j+step], [j+step, j]);
          }
        }

        edges = edges.filter(has_back);
        
        // Find the edge with a vertex closest
        // to the bottom left corner
        if (edges.length) {
          var best, best2, val = Infinity, newval;
          for (i = 0; i < edges.length; i++) {
            j = edges[i][0];
            newval = proj[j][0] + proj[j][1];
            if (newval < val) {
              best = j;
              best2 = edges[i][1];
              val = newval;
            }
          }
          if (typeof best !== "undefined") {
            result[dim] = vertices[best].slice(0,3);
            result[dim][dim] = undefined;
          } else
            result[dim] = undefined;
        }
      }
      return result;
    };
    
    /**
     * Choose tick locations
     * @param { Object } obj - The bboxdeco
    */
    rglwidgetClass.prototype.getTickLocations = function(obj){
      var dim, i, limits, locations = [], result = [[],[],[]], value,
          len, delta, range, bbox = obj.bbox;
      obj.needsAxisCallback = false;
      for (dim = 0; dim < 3; dim++) {
        limits = bbox.slice(2*dim, 2*dim + 2);
        range = limits[1] - limits[0];
        switch(obj.axes.mode[dim]) {
        case "custom":
          for (i=0; i < obj.vertices.length; i++) {
            value = (obj.vertices[i][dim] - limits[0])/range;
            if (typeof value !== "undefined" &&
                !isNaN(value))
              result[dim].push(value);
          }
          break;
        case "fixedstep":
          len = Math.floor(range/obj.axes.step[dim]);
          delta = obj.axes.step[dim];
          for (i = 0; i < len; i++)
            result[dim].push(i*delta);          
          break;
        case "fixednum":
          len = obj.axes.nticks[dim];
          delta = (len > 1) ? range/(len-1) : 0;
          for (i = 0; i < len; i++)
            result[dim].push(i*delta/range);
          break;
        case "pretty":
          locations = this.R_pretty(limits[0], limits[1], obj.axes.nticks[dim],
                                  3, // min_n
                                  0.75, // shrink_sml
                                  [1.5, 2.75], // high_u_fact
                                  0, // eps_correction
                                  0); // return_bounds)  
          for (i = locations.lo; i <= locations.up; i++) {
            value = (i*locations.unit - limits[0])/range;
            if (0 < value && value < 1)
              result[dim].push(value);
          }
          break;
        case "user":
          obj.needsAxisCallback = true;
          break;
        }
      }
      return result;
    };
    
    /**
     * Set tick vertices
     * @param { Object } ticks - the tick object
     * @param { Array }  edges - Which edges get the ticks?
    */
    rglwidgetClass.prototype.getTickVertices = function(ticks) {
      var dim, i, j, vertices = [], locations, 
          edges = ticks.edges, edge;
      for (dim = 0; dim < 3; dim++) {
        locations = ticks.locations[dim];
        if (locations.length)
          for (i = 0; i < locations.length; i++) 
            if (typeof edges[dim] !== "undefined") {
              edge = edges[dim].slice();
              edge[dim] = locations[i];
              vertices.push(edge);
              edge = edge.slice();
              for (j = 0; j < 3; j++)       
                if ((dim < 2 && j === 1 - dim) || 
                    (dim === 2 && j === 0))
                  edge[j] += 2*(edge[j] - 0.5)/ticks.axes.marklen[dim];
              vertices.push(edge);
            }
        }
      ticks.vertices = vertices;
      ticks.vertexCount = vertices.length;
      ticks.values = new Float32Array(rglwidgetClass.flatten(vertices));
      ticks.initialized = false;
    };
    
    /**
     * Set tick label positions
     * @param { Object } obj - the bbox object
    */
    rglwidgetClass.prototype.placeTickLabels = function(obj) {
      var ticks = obj.ticks, labels = obj.labels, i,j,k,
          vertices = [], tickvertices = ticks.vertices, 
          vertex, locations, dim, edges = obj.ticks.edges;
      j = 0;
      for (dim = 0; dim < 3; dim++) {
        if (typeof edges[dim] === "undefined") 
          continue;
        locations = ticks.locations[dim];
        if (locations.length)
          for (i = 0; i < locations.length; i++) {
            if (isNaN(locations[i]))
              continue;
            while (j < tickvertices.length && 
                   tickvertices[j][dim] !== locations[i]) j++;
            if (j >= tickvertices.length)
              break;
            vertex = tickvertices[j].slice();
            for (k = 0; k < 3; k++)
              vertex[k] += 2*(tickvertices[j+1][k] - vertex[k]);
            vertices.push(vertex);
            j += 2;
          }
        }
      labels.vertices = vertices;
      labels.centers = labels.vertices;
      labels.initialized = false;
    };  
     
    /**
     * Set tick labels
     * @param { Object } obj - the bbox object
     */ 
    rglwidgetClass.prototype.setTickLabels = function(obj) {
      var ticks = obj.ticks, mode, locations, labels = [],
      start = 0, nticks, dim, i, limits, range, values, max,
      edges = obj.ticks.edges;
      for (dim = 0; dim < 3; dim++) {
        if (typeof edges[dim] === "undefined") 
          continue;
        mode = obj.axes.mode[dim];
        nticks = obj.axes.nticks[dim]; // used on input only for custom!
        if (mode === "custom") 
          labels = labels.concat(obj.texts.slice(start, start + nticks));
        else {
          limits = obj.bbox.slice(2*dim, 2*(dim+1));
          range = limits[1] - limits[0];
          locations = ticks.locations[dim];
          max = -Infinity;
          values = [];
          for (i = 0; i < locations.length; i++) {
            values.push(limits[0] + range*locations[i]);
            max = Math.max(max, Math.abs(values[i]));
          }
          for (i = 0; i < locations.length; i++) {
            if (Math.abs(values[i])/max < Math.pow(10, -5))
              values[i] = 0;
            labels.push(rglwidgetClass.signif(values[i], 4).toString());
          }
          obj.axes.nticks[dim] = locations.length;  
        }
        start += nticks;
      }
      obj.labels.texts = labels;
    };

    /**
     * Set bboxdeco bbox and center vector 
     * @param { Object } obj - the bbox object
     */ 
    rglwidgetClass.prototype.setBbox = function(obj, subscene) {
      var i, expand, center = [], bbox;
      if (!obj.initialized)
        this.initBBox(obj);
        
      bbox = [].concat(subscene.par3d.bbox);
      for (i = 0; i < 3; i++) {
        expand = obj.axes.expand[i];
        center[i] = (bbox[2*i] + bbox[2*i + 1])/2;
        bbox[2*i] = center[i] - expand*(bbox[2*i + 1] - center[i]);
        bbox[2*i+1] = center[i] + expand*(bbox[2*i + 1] - center[i]);
      }
      obj.bbox = bbox;
      obj.center = center;
    };

    rglwidgetClass.prototype.setBBoxMatrices = function(obj) {
      var saved = {normMatrix: new CanvasMatrix4(this.normMatrix),
                   mvMatrix: new CanvasMatrix4(this.mvMatrix)},
          bboxNorm, bboxMV, bbox = obj.bbox, scale;
          
      bboxNorm = new CanvasMatrix4();
      scale = [bbox[1]-bbox[0], bbox[3]-bbox[2], bbox[5]-bbox[4]];
      bboxNorm.scale(1/scale[0], 1/scale[1], 1/scale[2]);
      bboxNorm.multRight(saved.normMatrix);
      this.normMatrix = bboxNorm;

      bboxMV = new CanvasMatrix4();
      bboxMV.scale(scale[0], scale[1], scale[2]);
      bboxMV.translate(bbox[0], bbox[2], bbox[4]);
      bboxMV.multRight(saved.mvMatrix);
      this.mvMatrix = obj.mvMatrix = bboxMV;
      
      if (this.prmvMatrix === null)
        saved.prmvMatrix = null;
      else
        saved.prmvMatrix = new CanvasMatrix4(this.prmvMatrix);
        
      this.setprmvMatrix();
      obj.prmvMatrix = this.prmvMatrix;
      
      return saved;
    };
    
    rglwidgetClass.prototype.restoreBBoxMatrices = function(saved) {
      this.normMatrix = saved.normMatrix;
      this.mvMatrix   = saved.mvMatrix;
      this.prmvMatrix = saved.prmvMatrix;
    };
    
    rglwidgetClass.prototype.getMarginParameters = function(bboxdeco, material) {
      // Assume we've run this.setBbox(bboxdeco, subscene);
      var bbox = bboxdeco.bbox,
          edge = [].concat(material.edge),
          saved, edges, i, 
          at = material.margin, line, level, trans, scale;

      if (material.floating) {
        saved = this.setBBoxMatrices(bboxdeco);
        edges = this.getTickEdges(this.prmvMatrix)[at];
        this.restoreBBoxMatrices(saved);
        if (typeof edges !== "undefined")
          for (i = 0; i < 3; i++) {
            if (edges[i] < 1) edges[i] = -1;
              edge[i] = edge[i]*edges[i];
        } else
          return undefined;
      }
      switch(at) {
      case 0: line = 1;
              level = 2;
              break;
      case 1: line = 0;
              level = 2;
              break;
      case 2: line = 0;
              level = 1;
              break;
      }
      scale = [edge[0]*(bbox[1]-bbox[0])/bboxdeco.axes.marklen[0], 
               edge[1]*(bbox[3]-bbox[2])/bboxdeco.axes.marklen[1], 
               edge[2]*(bbox[5]-bbox[4])/bboxdeco.axes.marklen[2]];
      trans = [edge[0] === 1 ? bbox[1] : bbox[0],
               edge[1] === 1 ? bbox[3] : bbox[2],
               edge[2] === 1 ? bbox[5] : bbox[4]];
      return {at: at, line: line, level: level, trans: trans, scale: scale};        
    };
    
    rglwidgetClass.prototype.fixVertex = function(orig, parms, center, bbox) {
      var vertex = [0,0,0];
      if (rglwidgetClass.missing(orig[0]))
        vertex[parms.at] = center[parms.at];
      else if (orig[0] === "-Inf")
        vertex[parms.at] = bbox[2*parms.at];
      else if (orig[0] === "Inf")
        vertex[parms.at] = bbox[2*parms.at + 1];
      else
        vertex[parms.at] = orig[0];
      vertex[parms.line] = parms.scale[parms.line]*orig[1] + 
          parms.trans[parms.line];
      vertex[parms.level] = parms.scale[parms.level]*orig[2] + 
          parms.trans[parms.level];
      return vertex;
    };
    
    rglwidgetClass.prototype.fixNormal = function(orig, parms) {
      var vertex = [0,0,0];
      vertex[parms.at] = orig[0];
      vertex[parms.line] = orig[1]/parms.scale[parms.line];
      vertex[parms.level] = orig[2]/parms.scale[parms.level];
      return vertex;
    };

    rglwidgetClass.prototype.marginVecToDataVec = function(obj, subscene) {
      var bboxdeco = this.getBBoxDeco(subscene),
          center, bbox, parms, parmsjson,
          orig = obj.orig, 
          vertices = [], normals = [],
          centers = [], i, vertex;
      if (typeof orig === "undefined") {
        orig = {vert: obj.vertices,
                norm: obj.normals,
                cent: obj.centers,
                doNormals: typeof obj.normals !== "undefined",
                doCenters: typeof obj.centers !== "undefined",
                parms: ""
               };
        obj.orig = orig;
      }

      if (typeof bboxdeco !== "undefined") {
        this.setBbox(bboxdeco, subscene);
        center = bboxdeco.center;
        bbox = bboxdeco.bbox;
        parms = this.getMarginParameters(bboxdeco, obj.material);
        if (typeof parms === "undefined")
          return false;  /* axis is not currently shown */
        
        parmsjson = JSON.stringify(parms);
        if (parmsjson === orig.parms)
          return true;  /* nothing has changed */
    
        orig.parms = parmsjson;
        
        for (i=0; i < orig.vert.length; i++) {
          vertex = this.fixVertex(orig.vert[i], parms, center, bbox);
          vertices.push(vertex);
        }
        obj.vertices = vertices;
        if (orig.doNormals) {
          for (i=0; i < orig.norm.length; i++) {
            vertex = this.fixNormal(orig.norm[i], parms);
            normals.push(vertex);
          }
          obj.normals = normals;
        }
        if (orig.doCenters) {
          for (i=0; i < orig.cent.length; i++) {
            vertex = this.fixVertex(orig.cent[i], parms, center, bbox);
            centers.push(vertex);
          }
          obj.centers = centers;
        }
        
        obj.initialized = false;
        return true;
      } else {
        console.warn("bboxdeco not found");
        return false;
      }
    };

    rglwidgetClass.prototype.doAxisCallback = function(obj, edges) {
      var i, j, code, axis, fn;
      for (i = 0; i < 3; i++) {
        if (obj.axes.mode[i] === "user") {
          axis = ["x", "y", "z"][i];
          if (typeof obj.callbacks !== "undefined" &&
              typeof (code = obj.callbacks[axis]) !== "undefined") {
            if (typeof edges[i] !== "undefined")
              for (j = 0; j < 3; j++)
                if (typeof edges[i][j] !== "undefined")
                  axis = axis + (edges[i][j] > 0 ? "+" : "-");
            
          /* jshint evil:true */
            fn = Function('"use strict";return (' + code + ')')();
          /* jshint evil:false */
            fn.call(this, axis);
          }
        }
      }
    };
</script>
<script>/**
     * Methods related to animations
     * @name ___METHODS_FOR_ANIMATION___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
    /**
     * Binary search
     * @param x - x coordinates in increasing order
     * @param newx - value to find, assumed to be in the range of x
     * @result index of largest x value below newx
     */
    rglwidgetClass.bisect = function(x, newx) {
      var lo = 0, hi = x.length - 1, mid;
      while (lo < hi - 1) {
        mid = Math.round((lo + hi)/2);
        if (x[mid] < newx)
          lo = mid;
        else
          hi = mid;
      }
      return lo;
    };
    
    /**
     * Step interpolation (constant outside bounds)
     * @param x - x coordinates in increasing order
     * @param v - values at x; either a vector or matrix
     * @param newx - value at which to evaluate
     */
    rglwidgetClass.step = function(x, v, newx) {
      var n, lo;
      if (newx <= x[0])
        return v[0];    
      n = x.length;
      if (newx >= x[n-1])
        return v[n-1];
      lo = this.bisect(x, newx);
      return v[lo];
    };
    
    /**
     * Linear interpolation (constant outside bounds)
     * @param x - x coordinates in increasing order
     * @param v - values at x; either a vector or matrix
     * @param newx - value at which to evaluate
     */
    rglwidgetClass.lerp = function(x, v, newx) {
      var i, n, lo, hi, alpha, result;
      if (newx <= x[0])
        return v[0];    
      n = x.length;
      if (newx >= x[n-1])
        return v[n-1];
      lo = this.bisect(x, newx);
      if (newx === x[lo])
        return v[lo];
      hi = lo + 1;
      if (newx === x[hi])
        return v[hi];
      alpha = (newx - x[lo])/(x[hi] - x[lo]);
      result = v[lo];
      n = result.length;
      if (typeof n !== "undefined") {
        for (i = 0; i < n; i++)
          result[i] = (1 - alpha)*result[i] + alpha*v[hi][i];
      } else
        result = (1 - alpha)*result + alpha*v[hi];
      return result;
    };
    
    /**
     * Spherical linear interpolation (constant outside bounds)
     * @param x - x coordinates in increasing order
     * @param v - a matrix of unit quaternions
     * @param newx - value at which to evaluate
     */
    rglwidgetClass.slerp = function(x, v, newx) {
      var n, lo, hi, alpha, result,
          p0, p1, dot, Omega, alpha0, alpha1, len;
      if (newx <= x[0])
        return v[0];    
      if (newx >= x[n-1])
        return v[n-1];
      lo = this.bisect(x, newx);
      if (newx === x[lo])
        return v[lo];
      hi = lo + 1;
      if (newx === x[hi])
        return v[hi];
      p0 = v[lo];
      p1 = v[hi];
      dot = p0[0]*p1[0] + 
            p0[1]*p1[1] +
            p0[2]*p1[2] +
            p0[3]*p1[3];
      if (dot < 0) {
        p1 = [-p1[0], -p1[1], -p1[2], -p1[3]];
        dot = -dot;
      }
      if (dot >= 1)
        result = p1;
      else {
        alpha = (newx - x[lo])/(x[hi] - x[lo]);
        Omega = Math.acos(dot);
        alpha0 = Math.sin((1 - alpha)*Omega);
        alpha1 = Math.sin(alpha*Omega);
        result = [alpha0*p0[0] + alpha1*p1[0],
                  alpha0*p0[1] + alpha1*p1[1],
                  alpha0*p0[2] + alpha1*p1[2],
                  alpha0*p0[3] + alpha1*p1[3]];
      }
      len = Math.sqrt(result[0]*result[0] +
                      result[1]*result[1] +
                      result[2]*result[2] +
                      result[3]*result[3]);
      return [result[0]/len,
              result[1]/len,
              result[2]/len,
              result[3]/len];
    };

    /**
     * Rotate using unit quaternion
     * @param q - a single unit quaternion
     */
    rglwidgetClass.rotateByQuaternion = function(M, q) {

    var xx = q[0]*q[0],
        xy = q[0]*q[1],
        xz = q[0]*q[2],
        xw = q[0]*q[3],
        yy = q[1]*q[1],
        yz = q[1]*q[2],
        yw = q[1]*q[3],
        zz = q[2]*q[2],
        zw = q[2]*q[3],
        matrix = new CanvasMatrix4();
      matrix.m11 = 1 - 2*(yy + zz);
      matrix.m12 = 2*(xy + zw);
      matrix.m13 = 2*(xz - yw);
        
      matrix.m21 = 2*(xy - zw);
      matrix.m22 = 1 - 2*(xx + zz);
      matrix.m23 = 2*(yz + xw);

      matrix.m31 = 2*(xz + yw);
      matrix.m32 = 2*(yz - xw);
      matrix.m33 = 1 - 2*(xx + yy);

      M.multRight(matrix);      
    };
</script>
<script>/* globals CanvasMatrix4: true */
/* globals WebGLFloatArray */
/* jshint eqeqeq: false */
/*
 * Copyright (C) 2009 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 * Copyright (2016) Duncan Murdoch - fixed CanvasMatrix4.ortho,
 * cleaned up.
 */
/*
    CanvasMatrix4 class

    This class implements a 4x4 matrix. It has functions which
    duplicate the functionality of the OpenGL matrix stack and
    glut functions.

    IDL:

    [
        Constructor(in CanvasMatrix4 matrix),           // copy passed matrix into new CanvasMatrix4
        Constructor(in sequence<float> array)           // create new CanvasMatrix4 with 16 floats (row major)
        Constructor()                                   // create new CanvasMatrix4 with identity matrix
    ]
    interface CanvasMatrix4 {
        attribute float m11;
        attribute float m12;
        attribute float m13;
        attribute float m14;
        attribute float m21;
        attribute float m22;
        attribute float m23;
        attribute float m24;
        attribute float m31;
        attribute float m32;
        attribute float m33;
        attribute float m34;
        attribute float m41;
        attribute float m42;
        attribute float m43;
        attribute float m44;

        void load(in CanvasMatrix4 matrix);                 // copy the values from the passed matrix
        void load(in sequence<float> array);                // copy 16 floats into the matrix
        sequence<float> getAsArray();                       // return the matrix as an array of 16 floats
        WebGLFloatArray getAsCanvasFloatArray();           // return the matrix as a WebGLFloatArray with 16 values
        void makeIdentity();                                // replace the matrix with identity
        void transpose();                                   // replace the matrix with its transpose
        void invert();                                      // replace the matrix with its inverse

        void translate(in float x, in float y, in float z); // multiply the matrix by passed translation values on the right
        void scale(in float x, in float y, in float z);     // multiply the matrix by passed scale values on the right
        void rotate(in float angle,                         // multiply the matrix by passed rotation values on the right
                    in float x, in float y, in float z);    // (angle is in degrees)
        void multRight(in CanvasMatrix matrix);             // multiply the matrix by the passed matrix on the right
        void multLeft(in CanvasMatrix matrix);              // multiply the matrix by the passed matrix on the left
        void ortho(in float left, in float right,           // multiply the matrix by the passed ortho values on the right
                   in float bottom, in float top,
                   in float near, in float far);
        void frustum(in float left, in float right,         // multiply the matrix by the passed frustum values on the right
                     in float bottom, in float top,
                     in float near, in float far);
        void perspective(in float fovy, in float aspect,    // multiply the matrix by the passed perspective values on the right
                         in float zNear, in float zFar);
        void lookat(in float eyex, in float eyey, in float eyez,    // multiply the matrix by the passed lookat
                    in float ctrx, in float ctry, in float ctrz,    // values on the right
                    in float upx, in float upy, in float upz);
    }
*/

CanvasMatrix4 = function(m)
{
    if (typeof m == 'object') {
        if ("length" in m && m.length >= 16) {
            this.load(m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]);
            return;
        }
        else if (m instanceof CanvasMatrix4) {
            this.load(m);
            return;
        }
    }
    this.makeIdentity();
};

CanvasMatrix4.prototype.load = function()
{
    if (arguments.length == 1 && typeof arguments[0] == 'object') {
        var matrix = arguments[0];

        if ("length" in matrix && matrix.length == 16) {
            this.m11 = matrix[0];
            this.m12 = matrix[1];
            this.m13 = matrix[2];
            this.m14 = matrix[3];

            this.m21 = matrix[4];
            this.m22 = matrix[5];
            this.m23 = matrix[6];
            this.m24 = matrix[7];

            this.m31 = matrix[8];
            this.m32 = matrix[9];
            this.m33 = matrix[10];
            this.m34 = matrix[11];

            this.m41 = matrix[12];
            this.m42 = matrix[13];
            this.m43 = matrix[14];
            this.m44 = matrix[15];
            return;
        }

        if (arguments[0] instanceof CanvasMatrix4) {

            this.m11 = matrix.m11;
            this.m12 = matrix.m12;
            this.m13 = matrix.m13;
            this.m14 = matrix.m14;

            this.m21 = matrix.m21;
            this.m22 = matrix.m22;
            this.m23 = matrix.m23;
            this.m24 = matrix.m24;

            this.m31 = matrix.m31;
            this.m32 = matrix.m32;
            this.m33 = matrix.m33;
            this.m34 = matrix.m34;

            this.m41 = matrix.m41;
            this.m42 = matrix.m42;
            this.m43 = matrix.m43;
            this.m44 = matrix.m44;
            return;
        }
    }

    this.makeIdentity();
};

CanvasMatrix4.prototype.getAsArray = function()
{
    return [
        this.m11, this.m12, this.m13, this.m14,
        this.m21, this.m22, this.m23, this.m24,
        this.m31, this.m32, this.m33, this.m34,
        this.m41, this.m42, this.m43, this.m44
    ];
};

CanvasMatrix4.prototype.getAsWebGLFloatArray = function()
{
    return new WebGLFloatArray(this.getAsArray());
};

CanvasMatrix4.prototype.makeIdentity = function()
{
    this.m11 = 1;
    this.m12 = 0;
    this.m13 = 0;
    this.m14 = 0;

    this.m21 = 0;
    this.m22 = 1;
    this.m23 = 0;
    this.m24 = 0;

    this.m31 = 0;
    this.m32 = 0;
    this.m33 = 1;
    this.m34 = 0;

    this.m41 = 0;
    this.m42 = 0;
    this.m43 = 0;
    this.m44 = 1;
};

CanvasMatrix4.prototype.transpose = function()
{
    var tmp = this.m12;
    this.m12 = this.m21;
    this.m21 = tmp;

    tmp = this.m13;
    this.m13 = this.m31;
    this.m31 = tmp;

    tmp = this.m14;
    this.m14 = this.m41;
    this.m41 = tmp;

    tmp = this.m23;
    this.m23 = this.m32;
    this.m32 = tmp;

    tmp = this.m24;
    this.m24 = this.m42;
    this.m42 = tmp;

    tmp = this.m34;
    this.m34 = this.m43;
    this.m43 = tmp;
};

CanvasMatrix4.prototype.invert = function()
{
    // Calculate the 4x4 determinant
    // If the determinant is zero,
    // then the inverse matrix is not unique.
    var det = this._determinant4x4();

    if (Math.abs(det) < 1e-8)
        return null;

    this._makeAdjoint();

    // Scale the adjoint matrix to get the inverse
    this.m11 /= det;
    this.m12 /= det;
    this.m13 /= det;
    this.m14 /= det;

    this.m21 /= det;
    this.m22 /= det;
    this.m23 /= det;
    this.m24 /= det;

    this.m31 /= det;
    this.m32 /= det;
    this.m33 /= det;
    this.m34 /= det;

    this.m41 /= det;
    this.m42 /= det;
    this.m43 /= det;
    this.m44 /= det;
};

CanvasMatrix4.prototype.translate = function(x,y,z)
{
    if (x === undefined)
        x = 0;
    if (y === undefined)
        y = 0;
    if (z === undefined)
        z = 0;

    var matrix = new CanvasMatrix4();
    matrix.m41 = x;
    matrix.m42 = y;
    matrix.m43 = z;

    this.multRight(matrix);
};

CanvasMatrix4.prototype.scale = function(x,y,z)
{
    if (x === undefined)
        x = 1;
    if (z === undefined) {
        if (y === undefined) {
            y = x;
            z = x;
        }
        else
            z = 1;
    }
    else if (y === undefined)
        y = x;

    var matrix = new CanvasMatrix4();
    matrix.m11 = x;
    matrix.m22 = y;
    matrix.m33 = z;

    this.multRight(matrix);
};

CanvasMatrix4.prototype.rotate = function(angle,x,y,z)
{
    // angles are in degrees. Switch to radians
    angle = angle / 180 * Math.PI;

    angle /= 2;
    var sinA = Math.sin(angle);
    var cosA = Math.cos(angle);
    var sinA2 = sinA * sinA;

    // normalize
    var length = Math.sqrt(x * x + y * y + z * z);
    if (length === 0) {
        // bad vector, just use something reasonable
        x = 0;
        y = 0;
        z = 1;
    } else if (length != 1) {
        x /= length;
        y /= length;
        z /= length;
    }

    var mat = new CanvasMatrix4();

    // optimize case where axis is along major axis
    if (x == 1 && y === 0 && z === 0) {
        mat.m11 = 1;
        mat.m12 = 0;
        mat.m13 = 0;
        mat.m21 = 0;
        mat.m22 = 1 - 2 * sinA2;
        mat.m23 = 2 * sinA * cosA;
        mat.m31 = 0;
        mat.m32 = -2 * sinA * cosA;
        mat.m33 = 1 - 2 * sinA2;
        mat.m14 = mat.m24 = mat.m34 = 0;
        mat.m41 = mat.m42 = mat.m43 = 0;
        mat.m44 = 1;
    } else if (x === 0 && y == 1 && z === 0) {
        mat.m11 = 1 - 2 * sinA2;
        mat.m12 = 0;
        mat.m13 = -2 * sinA * cosA;
        mat.m21 = 0;
        mat.m22 = 1;
        mat.m23 = 0;
        mat.m31 = 2 * sinA * cosA;
        mat.m32 = 0;
        mat.m33 = 1 - 2 * sinA2;
        mat.m14 = mat.m24 = mat.m34 = 0;
        mat.m41 = mat.m42 = mat.m43 = 0;
        mat.m44 = 1;
    } else if (x === 0 && y === 0 && z == 1) {
        mat.m11 = 1 - 2 * sinA2;
        mat.m12 = 2 * sinA * cosA;
        mat.m13 = 0;
        mat.m21 = -2 * sinA * cosA;
        mat.m22 = 1 - 2 * sinA2;
        mat.m23 = 0;
        mat.m31 = 0;
        mat.m32 = 0;
        mat.m33 = 1;
        mat.m14 = mat.m24 = mat.m34 = 0;
        mat.m41 = mat.m42 = mat.m43 = 0;
        mat.m44 = 1;
    } else {
        var x2 = x*x;
        var y2 = y*y;
        var z2 = z*z;

        mat.m11 = 1 - 2 * (y2 + z2) * sinA2;
        mat.m12 = 2 * (x * y * sinA2 + z * sinA * cosA);
        mat.m13 = 2 * (x * z * sinA2 - y * sinA * cosA);
        mat.m21 = 2 * (y * x * sinA2 - z * sinA * cosA);
        mat.m22 = 1 - 2 * (z2 + x2) * sinA2;
        mat.m23 = 2 * (y * z * sinA2 + x * sinA * cosA);
        mat.m31 = 2 * (z * x * sinA2 + y * sinA * cosA);
        mat.m32 = 2 * (z * y * sinA2 - x * sinA * cosA);
        mat.m33 = 1 - 2 * (x2 + y2) * sinA2;
        mat.m14 = mat.m24 = mat.m34 = 0;
        mat.m41 = mat.m42 = mat.m43 = 0;
        mat.m44 = 1;
    }
    this.multRight(mat);
};

CanvasMatrix4.prototype.multRight = function(mat)
{
    var m11 = (this.m11 * mat.m11 + this.m12 * mat.m21 +
               this.m13 * mat.m31 + this.m14 * mat.m41);
    var m12 = (this.m11 * mat.m12 + this.m12 * mat.m22 +
               this.m13 * mat.m32 + this.m14 * mat.m42);
    var m13 = (this.m11 * mat.m13 + this.m12 * mat.m23 +
               this.m13 * mat.m33 + this.m14 * mat.m43);
    var m14 = (this.m11 * mat.m14 + this.m12 * mat.m24 +
               this.m13 * mat.m34 + this.m14 * mat.m44);

    var m21 = (this.m21 * mat.m11 + this.m22 * mat.m21 +
               this.m23 * mat.m31 + this.m24 * mat.m41);
    var m22 = (this.m21 * mat.m12 + this.m22 * mat.m22 +
               this.m23 * mat.m32 + this.m24 * mat.m42);
    var m23 = (this.m21 * mat.m13 + this.m22 * mat.m23 +
               this.m23 * mat.m33 + this.m24 * mat.m43);
    var m24 = (this.m21 * mat.m14 + this.m22 * mat.m24 +
               this.m23 * mat.m34 + this.m24 * mat.m44);

    var m31 = (this.m31 * mat.m11 + this.m32 * mat.m21 +
               this.m33 * mat.m31 + this.m34 * mat.m41);
    var m32 = (this.m31 * mat.m12 + this.m32 * mat.m22 +
               this.m33 * mat.m32 + this.m34 * mat.m42);
    var m33 = (this.m31 * mat.m13 + this.m32 * mat.m23 +
               this.m33 * mat.m33 + this.m34 * mat.m43);
    var m34 = (this.m31 * mat.m14 + this.m32 * mat.m24 +
               this.m33 * mat.m34 + this.m34 * mat.m44);

    var m41 = (this.m41 * mat.m11 + this.m42 * mat.m21 +
               this.m43 * mat.m31 + this.m44 * mat.m41);
    var m42 = (this.m41 * mat.m12 + this.m42 * mat.m22 +
               this.m43 * mat.m32 + this.m44 * mat.m42);
    var m43 = (this.m41 * mat.m13 + this.m42 * mat.m23 +
               this.m43 * mat.m33 + this.m44 * mat.m43);
    var m44 = (this.m41 * mat.m14 + this.m42 * mat.m24 +
               this.m43 * mat.m34 + this.m44 * mat.m44);

    this.m11 = m11;
    this.m12 = m12;
    this.m13 = m13;
    this.m14 = m14;

    this.m21 = m21;
    this.m22 = m22;
    this.m23 = m23;
    this.m24 = m24;

    this.m31 = m31;
    this.m32 = m32;
    this.m33 = m33;
    this.m34 = m34;

    this.m41 = m41;
    this.m42 = m42;
    this.m43 = m43;
    this.m44 = m44;
};

CanvasMatrix4.prototype.multLeft = function(mat)
{
    var m11 = (mat.m11 * this.m11 + mat.m12 * this.m21 +
               mat.m13 * this.m31 + mat.m14 * this.m41);
    var m12 = (mat.m11 * this.m12 + mat.m12 * this.m22 +
               mat.m13 * this.m32 + mat.m14 * this.m42);
    var m13 = (mat.m11 * this.m13 + mat.m12 * this.m23 +
               mat.m13 * this.m33 + mat.m14 * this.m43);
    var m14 = (mat.m11 * this.m14 + mat.m12 * this.m24 +
               mat.m13 * this.m34 + mat.m14 * this.m44);

    var m21 = (mat.m21 * this.m11 + mat.m22 * this.m21 +
               mat.m23 * this.m31 + mat.m24 * this.m41);
    var m22 = (mat.m21 * this.m12 + mat.m22 * this.m22 +
               mat.m23 * this.m32 + mat.m24 * this.m42);
    var m23 = (mat.m21 * this.m13 + mat.m22 * this.m23 +
               mat.m23 * this.m33 + mat.m24 * this.m43);
    var m24 = (mat.m21 * this.m14 + mat.m22 * this.m24 +
               mat.m23 * this.m34 + mat.m24 * this.m44);

    var m31 = (mat.m31 * this.m11 + mat.m32 * this.m21 +
               mat.m33 * this.m31 + mat.m34 * this.m41);
    var m32 = (mat.m31 * this.m12 + mat.m32 * this.m22 +
               mat.m33 * this.m32 + mat.m34 * this.m42);
    var m33 = (mat.m31 * this.m13 + mat.m32 * this.m23 +
               mat.m33 * this.m33 + mat.m34 * this.m43);
    var m34 = (mat.m31 * this.m14 + mat.m32 * this.m24 +
               mat.m33 * this.m34 + mat.m34 * this.m44);

    var m41 = (mat.m41 * this.m11 + mat.m42 * this.m21 +
               mat.m43 * this.m31 + mat.m44 * this.m41);
    var m42 = (mat.m41 * this.m12 + mat.m42 * this.m22 +
               mat.m43 * this.m32 + mat.m44 * this.m42);
    var m43 = (mat.m41 * this.m13 + mat.m42 * this.m23 +
               mat.m43 * this.m33 + mat.m44 * this.m43);
    var m44 = (mat.m41 * this.m14 + mat.m42 * this.m24 +
               mat.m43 * this.m34 + mat.m44 * this.m44);

    this.m11 = m11;
    this.m12 = m12;
    this.m13 = m13;
    this.m14 = m14;

    this.m21 = m21;
    this.m22 = m22;
    this.m23 = m23;
    this.m24 = m24;

    this.m31 = m31;
    this.m32 = m32;
    this.m33 = m33;
    this.m34 = m34;

    this.m41 = m41;
    this.m42 = m42;
    this.m43 = m43;
    this.m44 = m44;
};

CanvasMatrix4.prototype.ortho = function(left, right, bottom, top, near, far)
{
    var tx = (left + right) / (left - right);
    var ty = (top + bottom) / (bottom - top);
    var tz = (far + near) / (near - far);

    var matrix = new CanvasMatrix4();
    matrix.m11 = 2 / (right - left);
    matrix.m12 = 0;
    matrix.m13 = 0;
    matrix.m14 = 0;
    matrix.m21 = 0;
    matrix.m22 = 2 / (top - bottom);
    matrix.m23 = 0;
    matrix.m24 = 0;
    matrix.m31 = 0;
    matrix.m32 = 0;
    matrix.m33 = -2 / (far - near);
    matrix.m34 = 0;
    matrix.m41 = tx;
    matrix.m42 = ty;
    matrix.m43 = tz;
    matrix.m44 = 1;

    this.multRight(matrix);
};

CanvasMatrix4.prototype.frustum = function(left, right, bottom, top, near, far)
{
    var matrix = new CanvasMatrix4();
    var A = (right + left) / (right - left);
    var B = (top + bottom) / (top - bottom);
    var C = -(far + near) / (far - near);
    var D = -(2 * far * near) / (far - near);

    matrix.m11 = (2 * near) / (right - left);
    matrix.m12 = 0;
    matrix.m13 = 0;
    matrix.m14 = 0;

    matrix.m21 = 0;
    matrix.m22 = 2 * near / (top - bottom);
    matrix.m23 = 0;
    matrix.m24 = 0;

    matrix.m31 = A;
    matrix.m32 = B;
    matrix.m33 = C;
    matrix.m34 = -1;

    matrix.m41 = 0;
    matrix.m42 = 0;
    matrix.m43 = D;
    matrix.m44 = 0;

    this.multRight(matrix);
};

CanvasMatrix4.prototype.perspective = function(fovy, aspect, zNear, zFar)
{
    var top = Math.tan(fovy * Math.PI / 360) * zNear;
    var bottom = -top;
    var left = aspect * bottom;
    var right = aspect * top;
    this.frustum(left, right, bottom, top, zNear, zFar);
};

CanvasMatrix4.prototype.lookat = function(eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz)
{
    var matrix = new CanvasMatrix4(),
        xx, xy, xz;

    // Make rotation matrix

    // Z vector
    var zx = eyex - centerx;
    var zy = eyey - centery;
    var zz = eyez - centerz;
    var mag = Math.sqrt(zx * zx + zy * zy + zz * zz);
    if (mag) {
        zx /= mag;
        zy /= mag;
        zz /= mag;
    }

    // Y vector
    var yx = upx;
    var yy = upy;
    var yz = upz;

    // X vector = Y cross Z
    xx =  yy * zz - yz * zy;
    xy = -yx * zz + yz * zx;
    xz =  yx * zy - yy * zx;

    // Recompute Y = Z cross X
    yx = zy * xz - zz * xy;
    yy = -zx * xz + zz * xx;
    yx = zx * xy - zy * xx;

    // cross product gives area of parallelogram, which is < 1.0 for
    // non-perpendicular unit-length vectors; so normalize x, y here

    mag = Math.sqrt(xx * xx + xy * xy + xz * xz);
    if (mag) {
        xx /= mag;
        xy /= mag;
        xz /= mag;
    }

    mag = Math.sqrt(yx * yx + yy * yy + yz * yz);
    if (mag) {
        yx /= mag;
        yy /= mag;
        yz /= mag;
    }

    matrix.m11 = xx;
    matrix.m12 = xy;
    matrix.m13 = xz;
    matrix.m14 = 0;

    matrix.m21 = yx;
    matrix.m22 = yy;
    matrix.m23 = yz;
    matrix.m24 = 0;

    matrix.m31 = zx;
    matrix.m32 = zy;
    matrix.m33 = zz;
    matrix.m34 = 0;

    matrix.m41 = 0;
    matrix.m42 = 0;
    matrix.m43 = 0;
    matrix.m44 = 1;
    matrix.translate(-eyex, -eyey, -eyez);

    this.multRight(matrix);
};

// Support functions
CanvasMatrix4.prototype._determinant2x2 = function(a, b, c, d)
{
    return a * d - b * c;
};

CanvasMatrix4.prototype._determinant3x3 = function(a1, a2, a3, b1, b2, b3, c1, c2, c3)
{
    return a1 * this._determinant2x2(b2, b3, c2, c3) -
         b1 * this._determinant2x2(a2, a3, c2, c3) +
         c1 * this._determinant2x2(a2, a3, b2, b3);
};

CanvasMatrix4.prototype._determinant4x4 = function()
{
    var a1 = this.m11;
    var b1 = this.m12;
    var c1 = this.m13;
    var d1 = this.m14;

    var a2 = this.m21;
    var b2 = this.m22;
    var c2 = this.m23;
    var d2 = this.m24;

    var a3 = this.m31;
    var b3 = this.m32;
    var c3 = this.m33;
    var d3 = this.m34;

    var a4 = this.m41;
    var b4 = this.m42;
    var c4 = this.m43;
    var d4 = this.m44;

    return a1 * this._determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4) -
         b1 * this._determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4) +
         c1 * this._determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4) -
         d1 * this._determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
};

CanvasMatrix4.prototype._makeAdjoint = function()
{
    var a1 = this.m11;
    var b1 = this.m12;
    var c1 = this.m13;
    var d1 = this.m14;

    var a2 = this.m21;
    var b2 = this.m22;
    var c2 = this.m23;
    var d2 = this.m24;

    var a3 = this.m31;
    var b3 = this.m32;
    var c3 = this.m33;
    var d3 = this.m34;

    var a4 = this.m41;
    var b4 = this.m42;
    var c4 = this.m43;
    var d4 = this.m44;

    // Row column labeling reversed since we transpose rows & columns
    this.m11  =   this._determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4);
    this.m21  = - this._determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4);
    this.m31  =   this._determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4);
    this.m41  = - this._determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);

    this.m12  = - this._determinant3x3(b1, b3, b4, c1, c3, c4, d1, d3, d4);
    this.m22  =   this._determinant3x3(a1, a3, a4, c1, c3, c4, d1, d3, d4);
    this.m32  = - this._determinant3x3(a1, a3, a4, b1, b3, b4, d1, d3, d4);
    this.m42  =   this._determinant3x3(a1, a3, a4, b1, b3, b4, c1, c3, c4);

    this.m13  =   this._determinant3x3(b1, b2, b4, c1, c2, c4, d1, d2, d4);
    this.m23  = - this._determinant3x3(a1, a2, a4, c1, c2, c4, d1, d2, d4);
    this.m33  =   this._determinant3x3(a1, a2, a4, b1, b2, b4, d1, d2, d4);
    this.m43  = - this._determinant3x3(a1, a2, a4, b1, b2, b4, c1, c2, c4);

    this.m14  = - this._determinant3x3(b1, b2, b3, c1, c2, c3, d1, d2, d3);
    this.m24  =   this._determinant3x3(a1, a2, a3, c1, c2, c3, d1, d2, d3);
    this.m34  = - this._determinant3x3(a1, a2, a3, b1, b2, b3, d1, d2, d3);
    this.m44  =   this._determinant3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3);
};
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">

div.csl-bib-body { }
div.csl-entry {
clear: both;
}
.hanging div.csl-entry {
margin-left:2em;
text-indent:-2em;
}
div.csl-left-margin {
min-width:2em;
float:left;
}
div.csl-right-inline {
margin-left:2em;
padding-left:1em;
}
div.csl-indent {
margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">zonohedra User Guide</h1>
<h4 class="author">Glenn Davis</h4>
<h4 class="date">2025-08-27</h4>


<div id="TOC">
<ul>
<li><a href="#introduction" id="toc-introduction">Introduction</a></li>
<li><a href="#polar-zonohedra" id="toc-polar-zonohedra">Polar
Zonohedra</a></li>
<li><a href="#classic-zonohedra" id="toc-classic-zonohedra">Classic
Zonohedra</a></li>
<li><a href="#colorimetry-zonohedra" id="toc-colorimetry-zonohedra">Colorimetry Zonohedra</a></li>
<li><a href="#future-work" id="toc-future-work">Future Work</a></li>
<li><a href="#references" id="toc-references">References</a>
<ul>
<li><a href="#appendix-a---methods" id="toc-appendix-a---methods">Appendix A - Methods</a></li>
<li><a href="#appendix-b---logging" id="toc-appendix-b---logging">Appendix B - Logging</a></li>
</ul></li>
<li><a href="#session-information" id="toc-session-information">Session
Information</a></li>
</ul>
</div>

<style type="text/css">
body {
max-width: 750px; 
}
h1{
font-size: 25pt; 
}

</style>
<script>
function ToggleDiv(ID) {
  var D = document.getElementById("D-" + ID);
  var B = document.getElementById("B-" + ID);
  if (D.style.display === "none") {
    // open the div and change button text
    D.style.display = "block";
    B.innerText = "Hide " + ID;
  } else {
    // close the div and change button text
    D.style.display = "none";
    B.innerText = "Show " + ID;
  }
}
</script>
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>A <em>zonohedron</em> is the linear image of a high-dimensional cube
<span class="math inline">\([0,1]^N\)</span> to <span class="math inline">\(\mathbb{R}^3\)</span>. A zonohedron is a special
type of convex polyhedron. The images of the standard basis of <span class="math inline">\(\mathbb{R}^N\)</span> are called the
<em>generators</em> of the zonohedron.</p>
The goal of this package is to construct <em>any</em> zonohedron from
the generators, but especially the ones in these 2 families:
<ul>
<li>
the classical zonohedra, with high symmetry
</li>
<li>
zonohedra that arise naturally from colorimetry, which may contain
hundreds of generators, but little symmetry
</li>
</ul>
<p>In the first case, 13 classical zonohedra have been taken from <span class="citation">[9]</span> and are built in to the package. In the
second case, an <em>object color solid</em> is viewed as a zonohedron;
this connection was discovered by Paul Centore and is explained very
clearly in <span class="citation">[1]</span>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(zonohedra)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">library</span>(rgl)</span></code></pre></div>
<p>The package dependencies are:</p>
<ul>
<li>
<strong>rgl</strong> <span class="citation">[4]</span> - for 3D plotting
</li>
<li>
<strong>microbenchmark</strong> <span class="citation">[7]</span> - is
suggested for its high-precision timer
</li>
<li>
<strong>logger</strong> <span class="citation">[3]</span> - for event
logging
</li>
</ul>
<p>Some of the figures below are displayed with <strong>WebGL</strong> -
a JavaScript API for rendering interactive 2D and 3D graphics. Try using
the left mouse button to rotate and the scroll wheel to zoom.</p>
<p><br><br></p>
</div>
<div id="polar-zonohedra" class="section level1">
<h1>Polar Zonohedra</h1>
<p>The generators for a polar zonohedra are particularly simple - they
are equally distributed on a circle that is in a plane parallel to the
xy-plane and whose center is on the z-axis. Construct polar zonohedra
with 5 and 25 generators and plot them.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>rgl<span class="sc">::</span><span class="fu">mfrow3d</span>( <span class="dv">1</span>, <span class="dv">2</span> )</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>pz5 <span class="ot">=</span> <span class="fu">polarzonohedron</span>( <span class="dv">5</span> ) ;  <span class="fu">plot</span>( pz5, <span class="at">ewd=</span><span class="dv">5</span> )</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>rgl<span class="sc">::</span><span class="fu">next3d</span>()</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a><span class="fu">plot</span>( <span class="fu">polarzonohedron</span>( <span class="dv">25</span> ), <span class="at">ewd=</span><span class="dv">3</span> )</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>rgl<span class="sc">::</span><span class="fu">rglwidget</span>( <span class="at">webgl=</span><span class="cn">TRUE</span> )</span></code></pre></div>
<div class="figure">
<div id="rgl8754" style="width:768px;height:384px;" class="rglWebGL html-widget" role="img" aria-labelledby="rgl8754-aria"></div>
<script type="application/json" data-for="rgl8754">{"x":{"material":{"color":"#000000","alpha":1,"lit":true,"ambient":"#000000","specular":"#FFFFFF","emission":"#000000","shininess":50,"smooth":true,"front":"filled","back":"filled","size":3,"lwd":1,"fog":true,"point_antialias":false,"line_antialias":false,"texture":null,"textype":"rgb","texmode":"modulate","texmipmap":false,"texminfilter":"linear","texmagfilter":"linear","texenvmap":false,"depth_mask":true,"depth_test":"less","isTransparent":false,"polygon_offset":[0,0],"margin":"","floating":false,"tag":"","blend":["src_alpha","one_minus_src_alpha"]},"rootSubscene":104,"objects":{"114":{"id":114,"type":"points","material":{"lit":false,"size":10,"point_antialias":true},"vertices":"0","colors":"1","centers":"2","ignoreExtent":false,"flags":34816},"115":{"id":115,"type":"points","material":{"lit":false,"size":10,"point_antialias":true},"vertices":"3","colors":"4","centers":"5","ignoreExtent":false,"flags":34816},"116":{"id":116,"type":"points","material":{"lit":false,"size":10,"point_antialias":true},"vertices":"6","colors":"7","centers":"8","ignoreExtent":false,"flags":34816},"117":{"id":117,"type":"linestrip","material":{"lit":false,"lwd":3},"vertices":"9","colors":"10","centers":"11","ignoreExtent":false,"flags":41024},"118":{"id":118,"type":"lines","material":{"lit":false,"lwd":5},"vertices":"12","colors":"13","centers":"14","ignoreExtent":false,"flags":41024},"119":{"id":119,"type":"lines","material":{"lit":false,"lwd":5},"vertices":"15","colors":"16","centers":"17","ignoreExtent":false,"flags":41024},"120":{"id":120,"type":"lines","material":{"lit":false,"lwd":5},"vertices":"18","colors":"19","centers":"20","ignoreExtent":false,"flags":41024},"121":{"id":121,"type":"lines","material":{"lit":false,"lwd":5},"vertices":"21","colors":"22","centers":"23","ignoreExtent":false,"flags":41024},"122":{"id":122,"type":"lines","material":{"lit":false,"lwd":5},"vertices":"24","colors":"25","centers":"26","ignoreExtent":false,"flags":41024},"124":{"id":124,"type":"points","material":{"lit":false,"size":10,"point_antialias":true},"vertices":"27","colors":"28","centers":"29","ignoreExtent":false,"flags":34816},"125":{"id":125,"type":"points","material":{"lit":false,"size":10,"point_antialias":true},"vertices":"30","colors":"31","centers":"32","ignoreExtent":false,"flags":34816},"126":{"id":126,"type":"points","material":{"lit":false,"size":10,"point_antialias":true},"vertices":"33","colors":"34","centers":"35","ignoreExtent":false,"flags":34816},"127":{"id":127,"type":"linestrip","material":{"lit":false,"lwd":3},"vertices":"36","colors":"37","centers":"38","ignoreExtent":false,"flags":41024},"128":{"id":128,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"39","colors":"40","centers":"41","ignoreExtent":false,"flags":41024},"129":{"id":129,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"42","colors":"43","centers":"44","ignoreExtent":false,"flags":41024},"130":{"id":130,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"45","colors":"46","centers":"47","ignoreExtent":false,"flags":41024},"131":{"id":131,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"48","colors":"49","centers":"50","ignoreExtent":false,"flags":41024},"132":{"id":132,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"51","colors":"52","centers":"53","ignoreExtent":false,"flags":41024},"133":{"id":133,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"54","colors":"55","centers":"56","ignoreExtent":false,"flags":41024},"134":{"id":134,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"57","colors":"58","centers":"59","ignoreExtent":false,"flags":41024},"135":{"id":135,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"60","colors":"61","centers":"62","ignoreExtent":false,"flags":41024},"136":{"id":136,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"63","colors":"64","centers":"65","ignoreExtent":false,"flags":41024},"137":{"id":137,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"66","colors":"67","centers":"68","ignoreExtent":false,"flags":41024},"138":{"id":138,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"69","colors":"70","centers":"71","ignoreExtent":false,"flags":41024},"139":{"id":139,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"72","colors":"73","centers":"74","ignoreExtent":false,"flags":41024},"140":{"id":140,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"75","colors":"76","centers":"77","ignoreExtent":false,"flags":41024},"141":{"id":141,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"78","colors":"79","centers":"80","ignoreExtent":false,"flags":41024},"142":{"id":142,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"81","colors":"82","centers":"83","ignoreExtent":false,"flags":41024},"143":{"id":143,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"84","colors":"85","centers":"86","ignoreExtent":false,"flags":41024},"144":{"id":144,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"87","colors":"88","centers":"89","ignoreExtent":false,"flags":41024},"145":{"id":145,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"90","colors":"91","centers":"92","ignoreExtent":false,"flags":41024},"146":{"id":146,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"93","colors":"94","centers":"95","ignoreExtent":false,"flags":41024},"147":{"id":147,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"96","colors":"97","centers":"98","ignoreExtent":false,"flags":41024},"148":{"id":148,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"99","colors":"100","centers":"101","ignoreExtent":false,"flags":41024},"149":{"id":149,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"102","colors":"103","centers":"104","ignoreExtent":false,"flags":41024},"150":{"id":150,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"105","colors":"106","centers":"107","ignoreExtent":false,"flags":41024},"151":{"id":151,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"108","colors":"109","centers":"110","ignoreExtent":false,"flags":41024},"152":{"id":152,"type":"lines","material":{"lit":false,"lwd":3},"vertices":"111","colors":"112","centers":"113","ignoreExtent":false,"flags":41024},"108":{"id":108,"type":"light","vertices":[[0,0,1]],"colors":[[1,1,1,1],[1,1,1,1],[1,1,1,1]],"viewpoint":true,"finite":false},"110":{"id":110,"type":"background","material":{"lit":false,"back":"lines"},"colors":"114","centers":"115","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"113":{"id":113,"type":"background","material":{"lit":false,"back":"lines"},"colors":"116","centers":"117","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"123":{"id":123,"type":"background","material":{"lit":false,"back":"lines"},"colors":"118","centers":"119","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"111":{"id":111,"type":"subscene","par3d":{"antialias":8,"FOV":30,"ignoreExtent":false,"listeners":111,"mouseMode":{"none":"none","left":"trackball","right":"zoom","middle":"fov","wheel":"pull"},"observer":[0,0,8.137496948242188],"modelMatrix":[[1,0,0,0],[0,0.3420201539993286,0.9396926164627075,-1.476065754890442],[0,-0.9396926164627075,0.3420201539993286,-8.674740791320801],[0,0,0,1]],"projMatrix":[[3.732050895690918,0,0,0],[0,1.866025447845459,0,0],[0,0,-3.86370325088501,-29.33473587036133],[0,0,-1,0]],"skipRedraw":false,"userMatrix":[[1,0,0,0],[0,0.3420201433256682,0.9396926207859085,0],[0,-0.9396926207859085,0.3420201433256682,0],[0,0,0,1]],"userProjection":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],"scale":[1,1,1],"viewport":{"x":0,"y":0,"width":0.5,"height":1},"zoom":1,"bbox":[-1.016640782356262,1.016640782356262,-0.9668828248977661,0.9668828248977661,0,3.141592741012573],"windowRect":[268,291,524,547],"family":"sans","font":1,"cex":1,"useFreeType":false,"fontname":"TT Arial","maxClipPlanes":8,"glVersion":4.6,"activeSubscene":0},"embeddings":{"viewport":"replace","projection":"replace","model":"replace","mouse":"inherit"},"objects":[113,114,115,116,117,118,119,120,121,122,108],"parent":104,"subscenes":[],"flags":43328},"112":{"id":112,"type":"subscene","par3d":{"antialias":8,"FOV":30,"ignoreExtent":false,"listeners":112,"mouseMode":{"none":"none","left":"trackball","right":"zoom","middle":"fov","wheel":"pull"},"observer":[0,0,8.165210723876953],"modelMatrix":[[1,0,0,0],[0,0.3420201539993286,0.9396926164627075,-1.476065754890442],[0,-0.9396926164627075,0.3420201539993286,-8.702454566955566],[0,0,0,1]],"projMatrix":[[3.732050657272339,0,0,0],[0,1.866025328636169,0,0],[0,0,-3.863703727722168,-29.43464279174805],[0,0,-1,0]],"skipRedraw":false,"userMatrix":[[1,0,0,0],[0,0.3420201433256682,0.9396926207859085,0],[0,-0.9396926207859085,0.3420201433256682,0],[0,0,0,1]],"userProjection":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],"scale":[1,1,1],"viewport":{"x":0.5,"y":0,"width":0.5,"height":1},"zoom":1,"bbox":[-1.000658273696899,1.000658273696899,-0.9986836910247803,0.9986836910247803,-3.608224830031759e-16,3.141592741012573],"windowRect":[268,291,524,547],"family":"sans","font":1,"cex":1,"useFreeType":false,"fontname":"TT Arial","maxClipPlanes":8,"glVersion":4.6,"activeSubscene":0},"embeddings":{"viewport":"replace","projection":"replace","model":"replace","mouse":"inherit"},"objects":[123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,108],"parent":104,"subscenes":[],"flags":43328},"104":{"id":104,"type":"subscene","par3d":{"antialias":8,"FOV":30,"ignoreExtent":false,"listeners":104,"mouseMode":{"none":"none","left":"trackball","right":"zoom","middle":"fov","wheel":"pull"},"observer":[0,0,823.132080078125],"modelMatrix":[[1,0,0,0],[0,0.3420201539993286,0.9396926164627075,0],[0,-0.9396926164627075,0.3420201539993286,-823.132080078125],[0,0,0,1]],"projMatrix":[[3.732050657272339,0,0,0],[0,3.732050657272339,0,0],[0,0,-3.863703727722168,-2967.29638671875],[0,0,-1,0]],"skipRedraw":false,"userMatrix":[[1,0,0,0],[0,0.3420201433256682,0.9396926207859085,0],[0,-0.9396926207859085,0.3420201433256682,0],[0,0,0,1]],"userProjection":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],"scale":[1,1,1],"viewport":{"x":0,"y":0,"width":1,"height":1},"zoom":1,"bbox":[123,-123,123,-123,123,-123],"windowRect":[268,291,524,547],"family":"sans","font":1,"cex":1,"useFreeType":false,"fontname":"TT Arial","maxClipPlanes":8,"glVersion":4.6,"activeSubscene":0},"embeddings":{"viewport":"replace","projection":"replace","model":"replace","mouse":"replace"},"objects":[110,108,111,112],"subscenes":[111,112],"flags":43328}},"crosstalk":{"key":[],"group":[],"id":[],"options":[]},"width":768,"height":384,"buffer":{"accessors":[{"bufferView":0,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":1,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":2,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":3,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":4,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":5,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":6,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":7,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":8,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":9,"componentType":5126,"count":2,"type":"VEC3"},{"bufferView":10,"componentType":5121,"count":2,"type":"VEC4","normalized":true},{"bufferView":11,"componentType":5126,"count":2,"type":"VEC3"},{"bufferView":12,"componentType":5126,"count":16,"type":"VEC3"},{"bufferView":13,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":14,"componentType":5126,"count":8,"type":"VEC3"},{"bufferView":15,"componentType":5126,"count":16,"type":"VEC3"},{"bufferView":16,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":17,"componentType":5126,"count":8,"type":"VEC3"},{"bufferView":18,"componentType":5126,"count":16,"type":"VEC3"},{"bufferView":19,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":20,"componentType":5126,"count":8,"type":"VEC3"},{"bufferView":21,"componentType":5126,"count":16,"type":"VEC3"},{"bufferView":22,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":23,"componentType":5126,"count":8,"type":"VEC3"},{"bufferView":24,"componentType":5126,"count":16,"type":"VEC3"},{"bufferView":25,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":26,"componentType":5126,"count":8,"type":"VEC3"},{"bufferView":27,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":28,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":29,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":30,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":31,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":32,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":33,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":34,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":35,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":36,"componentType":5126,"count":2,"type":"VEC3"},{"bufferView":37,"componentType":5121,"count":2,"type":"VEC4","normalized":true},{"bufferView":38,"componentType":5126,"count":2,"type":"VEC3"},{"bufferView":39,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":40,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":41,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":42,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":43,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":44,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":45,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":46,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":47,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":48,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":49,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":50,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":51,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":52,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":53,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":54,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":55,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":56,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":57,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":58,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":59,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":60,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":61,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":62,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":63,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":64,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":65,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":66,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":67,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":68,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":69,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":70,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":71,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":72,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":73,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":74,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":75,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":76,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":77,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":78,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":79,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":80,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":81,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":82,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":83,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":84,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":85,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":86,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":87,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":88,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":89,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":90,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":91,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":92,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":93,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":94,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":95,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":96,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":97,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":98,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":99,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":100,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":101,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":102,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":103,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":104,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":105,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":106,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":107,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":108,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":109,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":110,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":111,"componentType":5126,"count":96,"type":"VEC3"},{"bufferView":112,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":113,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":114,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":115,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":116,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":117,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":118,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":119,"componentType":5121,"count":1,"type":"VEC3"}],"bufferViews":[{"buffer":0,"byteLength":3,"byteOffset":0},{"buffer":0,"byteLength":4,"byteOffset":3},{"buffer":0,"byteLength":3,"byteOffset":7},{"buffer":0,"byteLength":12,"byteOffset":12},{"buffer":0,"byteLength":4,"byteOffset":24},{"buffer":0,"byteLength":12,"byteOffset":28},{"buffer":0,"byteLength":12,"byteOffset":40},{"buffer":0,"byteLength":16,"byteOffset":52},{"buffer":0,"byteLength":12,"byteOffset":68},{"buffer":0,"byteLength":24,"byteOffset":80},{"buffer":0,"byteLength":8,"byteOffset":104},{"buffer":0,"byteLength":24,"byteOffset":112},{"buffer":0,"byteLength":192,"byteOffset":136},{"buffer":0,"byteLength":4,"byteOffset":328},{"buffer":0,"byteLength":96,"byteOffset":332},{"buffer":0,"byteLength":192,"byteOffset":428},{"buffer":0,"byteLength":16,"byteOffset":620},{"buffer":0,"byteLength":96,"byteOffset":636},{"buffer":0,"byteLength":192,"byteOffset":732},{"buffer":0,"byteLength":16,"byteOffset":924},{"buffer":0,"byteLength":96,"byteOffset":940},{"buffer":0,"byteLength":192,"byteOffset":1036},{"buffer":0,"byteLength":16,"byteOffset":1228},{"buffer":0,"byteLength":96,"byteOffset":1244},{"buffer":0,"byteLength":192,"byteOffset":1340},{"buffer":0,"byteLength":16,"byteOffset":1532},{"buffer":0,"byteLength":96,"byteOffset":1548},{"buffer":0,"byteLength":3,"byteOffset":1644},{"buffer":0,"byteLength":4,"byteOffset":1647},{"buffer":0,"byteLength":3,"byteOffset":1651},{"buffer":0,"byteLength":12,"byteOffset":1656},{"buffer":0,"byteLength":4,"byteOffset":1668},{"buffer":0,"byteLength":12,"byteOffset":1672},{"buffer":0,"byteLength":12,"byteOffset":1684},{"buffer":0,"byteLength":16,"byteOffset":1696},{"buffer":0,"byteLength":12,"byteOffset":1712},{"buffer":0,"byteLength":24,"byteOffset":1724},{"buffer":0,"byteLength":8,"byteOffset":1748},{"buffer":0,"byteLength":24,"byteOffset":1756},{"buffer":0,"byteLength":1152,"byteOffset":1780},{"buffer":0,"byteLength":4,"byteOffset":2932},{"buffer":0,"byteLength":576,"byteOffset":2936},{"buffer":0,"byteLength":1152,"byteOffset":3512},{"buffer":0,"byteLength":16,"byteOffset":4664},{"buffer":0,"byteLength":576,"byteOffset":4680},{"buffer":0,"byteLength":1152,"byteOffset":5256},{"buffer":0,"byteLength":16,"byteOffset":6408},{"buffer":0,"byteLength":576,"byteOffset":6424},{"buffer":0,"byteLength":1152,"byteOffset":7000},{"buffer":0,"byteLength":16,"byteOffset":8152},{"buffer":0,"byteLength":576,"byteOffset":8168},{"buffer":0,"byteLength":1152,"byteOffset":8744},{"buffer":0,"byteLength":16,"byteOffset":9896},{"buffer":0,"byteLength":576,"byteOffset":9912},{"buffer":0,"byteLength":1152,"byteOffset":10488},{"buffer":0,"byteLength":16,"byteOffset":11640},{"buffer":0,"byteLength":576,"byteOffset":11656},{"buffer":0,"byteLength":1152,"byteOffset":12232},{"buffer":0,"byteLength":16,"byteOffset":13384},{"buffer":0,"byteLength":576,"byteOffset":13400},{"buffer":0,"byteLength":1152,"byteOffset":13976},{"buffer":0,"byteLength":16,"byteOffset":15128},{"buffer":0,"byteLength":576,"byteOffset":15144},{"buffer":0,"byteLength":1152,"byteOffset":15720},{"buffer":0,"byteLength":16,"byteOffset":16872},{"buffer":0,"byteLength":576,"byteOffset":16888},{"buffer":0,"byteLength":1152,"byteOffset":17464},{"buffer":0,"byteLength":16,"byteOffset":18616},{"buffer":0,"byteLength":576,"byteOffset":18632},{"buffer":0,"byteLength":1152,"byteOffset":19208},{"buffer":0,"byteLength":16,"byteOffset":20360},{"buffer":0,"byteLength":576,"byteOffset":20376},{"buffer":0,"byteLength":1152,"byteOffset":20952},{"buffer":0,"byteLength":16,"byteOffset":22104},{"buffer":0,"byteLength":576,"byteOffset":22120},{"buffer":0,"byteLength":1152,"byteOffset":22696},{"buffer":0,"byteLength":16,"byteOffset":23848},{"buffer":0,"byteLength":576,"byteOffset":23864},{"buffer":0,"byteLength":1152,"byteOffset":24440},{"buffer":0,"byteLength":16,"byteOffset":25592},{"buffer":0,"byteLength":576,"byteOffset":25608},{"buffer":0,"byteLength":1152,"byteOffset":26184},{"buffer":0,"byteLength":16,"byteOffset":27336},{"buffer":0,"byteLength":576,"byteOffset":27352},{"buffer":0,"byteLength":1152,"byteOffset":27928},{"buffer":0,"byteLength":16,"byteOffset":29080},{"buffer":0,"byteLength":576,"byteOffset":29096},{"buffer":0,"byteLength":1152,"byteOffset":29672},{"buffer":0,"byteLength":16,"byteOffset":30824},{"buffer":0,"byteLength":576,"byteOffset":30840},{"buffer":0,"byteLength":1152,"byteOffset":31416},{"buffer":0,"byteLength":16,"byteOffset":32568},{"buffer":0,"byteLength":576,"byteOffset":32584},{"buffer":0,"byteLength":1152,"byteOffset":33160},{"buffer":0,"byteLength":16,"byteOffset":34312},{"buffer":0,"byteLength":576,"byteOffset":34328},{"buffer":0,"byteLength":1152,"byteOffset":34904},{"buffer":0,"byteLength":16,"byteOffset":36056},{"buffer":0,"byteLength":576,"byteOffset":36072},{"buffer":0,"byteLength":1152,"byteOffset":36648},{"buffer":0,"byteLength":16,"byteOffset":37800},{"buffer":0,"byteLength":576,"byteOffset":37816},{"buffer":0,"byteLength":1152,"byteOffset":38392},{"buffer":0,"byteLength":16,"byteOffset":39544},{"buffer":0,"byteLength":576,"byteOffset":39560},{"buffer":0,"byteLength":1152,"byteOffset":40136},{"buffer":0,"byteLength":16,"byteOffset":41288},{"buffer":0,"byteLength":576,"byteOffset":41304},{"buffer":0,"byteLength":1152,"byteOffset":41880},{"buffer":0,"byteLength":16,"byteOffset":43032},{"buffer":0,"byteLength":576,"byteOffset":43048},{"buffer":0,"byteLength":1152,"byteOffset":43624},{"buffer":0,"byteLength":16,"byteOffset":44776},{"buffer":0,"byteLength":576,"byteOffset":44792},{"buffer":0,"byteLength":4,"byteOffset":45368},{"buffer":0,"byteLength":3,"byteOffset":45372},{"buffer":0,"byteLength":16,"byteOffset":45376},{"buffer":0,"byteLength":3,"byteOffset":45392},{"buffer":0,"byteLength":16,"byteOffset":45396},{"buffer":0,"byteLength":3,"byteOffset":45412}],"buffers":[{"byteLength":45415,"bytes":"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\nAA=="}]},"context":{"shiny":false,"rmarkdown":"rmarkdown::html_vignette"},"vertexShader":"#line 2 1\n// File 1 is the vertex shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\n\nattribute vec3 aPos;\nattribute vec4 aCol;\nuniform mat4 mvMatrix;\nuniform mat4 prMatrix;\nvarying vec4 vCol;\nvarying vec4 vPosition;\n\n#ifdef NEEDS_VNORMAL\nattribute vec3 aNorm;\nuniform mat4 normMatrix;\nvarying vec4 vNormal;\n#endif\n\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nattribute vec2 aTexcoord;\nvarying vec2 vTexcoord;\n#endif\n\n#ifdef FIXED_SIZE\nuniform vec3 textScale;\n#endif\n\n#ifdef FIXED_QUADS\nattribute vec3 aOfs;\n#endif\n\n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\nvarying float normz;\nuniform mat4 invPrMatrix;\n#else\nattribute vec3 aPos1;\nattribute vec3 aPos2;\nvarying float normz;\n#endif\n#endif // IS_TWOSIDED\n\n#ifdef FAT_LINES\nattribute vec3 aNext;\nattribute vec2 aPoint;\nvarying vec2 vPoint;\nvarying float vLength;\nuniform float uAspect;\nuniform float uLwd;\n#endif\n\n#ifdef USE_ENVMAP\nvarying vec3 vReflection;\n#endif\n\nvoid main(void) {\n  \n#ifndef IS_BRUSH\n#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG) || defined(USE_ENVMAP)\n  vPosition = mvMatrix * vec4(aPos, 1.);\n#endif\n  \n#ifndef FIXED_QUADS\n  gl_Position = prMatrix * vPosition;\n#endif\n#endif // !IS_BRUSH\n  \n#ifdef IS_POINTS\n  gl_PointSize = POINTSIZE;\n#endif\n  \n  vCol = aCol;\n  \n// USE_ENVMAP implies NEEDS_VNORMAL\n\n#ifdef NEEDS_VNORMAL\n  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\n#endif\n\n#ifdef USE_ENVMAP\n  vReflection = normalize(reflect(vPosition.xyz/vPosition.w, \n                        normalize(vNormal.xyz/vNormal.w)));\n#endif\n  \n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\n  /* normz should be calculated *after* projection */\n  normz = (invPrMatrix*vNormal).z;\n#else\n  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\n  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\n  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\n  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\n  normz = pos1.x*pos2.y - pos1.y*pos2.x;\n#endif\n#endif // IS_TWOSIDED\n  \n#ifdef NEEDS_VNORMAL\n  vNormal = vec4(normalize(vNormal.xyz), 1);\n#endif\n  \n#if defined(HAS_TEXTURE) || defined(IS_TEXT)\n  vTexcoord = aTexcoord;\n#endif\n  \n#if defined(FIXED_SIZE) && !defined(ROTATING)\n  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w;\n  gl_Position = pos + vec4(aOfs*textScale, 0.);\n#endif\n  \n#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\n  vec4 pos = mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w + vec4(aOfs,  0.);\n  gl_Position = prMatrix*pos;\n#endif\n  \n#ifdef FAT_LINES\n  /* This code was inspired by Matt Deslauriers' code in \n   https://mattdesl.svbtle.com/drawing-lines-is-hard */\n  vec2 aspectVec = vec2(uAspect, 1.0);\n  mat4 projViewModel = prMatrix * mvMatrix;\n  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\n  currentProjected = currentProjected/currentProjected.w;\n  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\n  vec2 currentScreen = currentProjected.xy * aspectVec;\n  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\n  float len = uLwd;\n  vec2 dir = vec2(1.0, 0.0);\n  vPoint = aPoint;\n  vLength = length(nextScreen - currentScreen)/2.0;\n  vLength = vLength/(vLength + len);\n  if (vLength > 0.0) {\n    dir = normalize(nextScreen - currentScreen);\n  }\n  vec2 normal = vec2(-dir.y, dir.x);\n  dir.x /= uAspect;\n  normal.x /= uAspect;\n  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\n  gl_Position = currentProjected + offset;\n#endif\n  \n#ifdef IS_BRUSH\n  gl_Position = vec4(aPos, 1.);\n#endif\n}","fragmentShader":"#line 2 2\n// File 2 is the fragment shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\nvarying vec4 vCol; // carries alpha\nvarying vec4 vPosition;\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nvarying vec2 vTexcoord;\nuniform sampler2D uSampler;\n#endif\n\n#ifdef HAS_FOG\nuniform int uFogMode;\nuniform vec3 uFogColor;\nuniform vec4 uFogParms;\n#endif\n\n#if defined(IS_LIT) && !defined(FIXED_QUADS)\nvarying vec4 vNormal;\n#endif\n\n#if NCLIPPLANES > 0\nuniform vec4 vClipplane[NCLIPPLANES];\n#endif\n\n#if NLIGHTS > 0\nuniform mat4 mvMatrix;\n#endif\n\n#ifdef IS_LIT\nuniform vec3 emission;\nuniform float shininess;\n#if NLIGHTS > 0\nuniform vec3 ambient[NLIGHTS];\nuniform vec3 specular[NLIGHTS]; // light*material\nuniform vec3 diffuse[NLIGHTS];\nuniform vec3 lightDir[NLIGHTS];\nuniform bool viewpoint[NLIGHTS];\nuniform bool finite[NLIGHTS];\n#endif\n#endif // IS_LIT\n\n#ifdef IS_TWOSIDED\nuniform bool front;\nvarying float normz;\n#endif\n\n#ifdef FAT_LINES\nvarying vec2 vPoint;\nvarying float vLength;\n#endif\n\n#ifdef USE_ENVMAP\nvarying vec3 vReflection;\n#endif\n\nvoid main(void) {\n  vec4 fragColor;\n#ifdef FAT_LINES\n  vec2 point = vPoint;\n  bool neg = point.y < 0.0;\n  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :\n                 -(point.y - vLength)/(1.0 - vLength);\n#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\n  if (neg && length(point) <= 1.0) discard;\n#endif\n  point.y = min(point.y, 0.0);\n  if (length(point) > 1.0) discard;\n#endif // FAT_LINES\n  \n#ifdef ROUND_POINTS\n  vec2 coord = gl_PointCoord - vec2(0.5);\n  if (length(coord) > 0.5) discard;\n#endif\n  \n#if NCLIPPLANES > 0\n  for (int i = 0; i < NCLIPPLANES; i++)\n    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\n#endif\n    \n#ifdef FIXED_QUADS\n    vec3 n = vec3(0., 0., 1.);\n#elif defined(IS_LIT)\n    vec3 n = normalize(vNormal.xyz);\n#endif\n    \n#ifdef IS_TWOSIDED\n    if ((normz <= 0.) != front) discard;\n#endif\n\n#ifdef IS_LIT\n    vec3 eye = normalize(-vPosition.xyz/vPosition.w);\n    vec3 lightdir;\n    vec4 colDiff;\n    vec3 halfVec;\n    vec4 lighteffect = vec4(emission, 0.);\n    vec3 col;\n    float nDotL;\n#ifdef FIXED_QUADS\n    n = -faceforward(n, n, eye);\n#endif\n    \n#if NLIGHTS > 0\n    // Simulate two-sided lighting\n    if (n.z < 0.0)\n      n = -n;\n    for (int i=0;i<NLIGHTS;i++) {\n      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\n      lightdir = lightDir[i];\n      if (!viewpoint[i]) {\n        if (finite[i]) {\n          lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\n        } else {\n          lightdir = (mvMatrix * vec4(lightdir, 0.)).xyz;\n        }\n      }\n      if (!finite[i]) {\n        halfVec = normalize(lightdir + eye);\n      } else {\n        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);\n        halfVec = normalize(lightdir + eye);\n      }\n      col = ambient[i];\n      nDotL = dot(n, lightdir);\n      col = col + max(nDotL, 0.) * colDiff.rgb;\n      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\n      lighteffect = lighteffect + vec4(col, colDiff.a);\n    }\n#endif\n    \n#else // not IS_LIT\n    vec4 colDiff = vCol;\n    vec4 lighteffect = colDiff;\n#endif\n    \n#ifdef IS_TEXT\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n#endif\n    \n#ifdef HAS_TEXTURE\n\n// These calculations use the definitions from \n// https://docs.gl/gl3/glTexEnv\n\n#ifdef USE_ENVMAP\n    float m = 2.0 * sqrt(dot(vReflection, vReflection) + 2.0*vReflection.z + 1.0);\n    vec4 textureColor = texture2D(uSampler, vReflection.xy / m + vec2(0.5, 0.5));\n#else\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\n#endif\n\n#ifdef TEXTURE_rgb\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(textureColor.rgb, lighteffect.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = lighteffect*vec4(textureColor.rgb, 1.);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb, lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb, lighteffect.a);\n#endif\n\n#endif //TEXTURE_rgb\n        \n#ifdef TEXTURE_rgba\n\n#ifdef TEXMODE_replace\n// already done\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = lighteffect*textureColor;\n#endif\n\n#ifdef TEXMODE_decal\n    textureColor = vec4((1. - textureColor.a)*lighteffect.rgb) +\n                     textureColor.a*textureColor.rgb, \n                     lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb,\n                    lighteffect.a*textureColor.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb,\n                    lighteffect.a*textureColor.a);\n#endif\n    \n#endif //TEXTURE_rgba\n    \n#ifdef TEXTURE_alpha\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(lighteffect.rgb, luminance);\n#endif \n\n#if defined(TEXMODE_modulate) || defined(TEXMODE_blend) || defined(TEXMODE_add)\n    textureColor = vec4(lighteffect.rgb, lighteffect.a*luminance);\n#endif\n \n#endif // TEXTURE_alpha\n    \n// The TEXTURE_luminance values are not from that reference    \n#ifdef TEXTURE_luminance\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(luminance, luminance, luminance, lighteffect.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = vec4(luminance*lighteffect.rgb, lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n                        lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(luminance + lighteffect.rgb, lighteffect.a);\n#endif\n\n#endif // TEXTURE_luminance\n \n    \n#ifdef TEXTURE_luminance_alpha\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(luminance, luminance, luminance, textureColor.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = vec4(luminance*lighteffect.rgb, \n                        textureColor.a*lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n                        textureColor.a*lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(luminance + lighteffect.rgb, \n                        textureColor.a*lighteffect.a);\n\n#endif\n\n#endif // TEXTURE_luminance_alpha\n    \n    fragColor = textureColor;\n\n#elif defined(IS_TEXT)\n    if (textureColor.a < 0.1)\n      discard;\n    else\n      fragColor = textureColor;\n#else\n    fragColor = lighteffect;\n#endif // HAS_TEXTURE\n    \n#ifdef HAS_FOG\n    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))\n    // In Exp and Exp2: use density = density/far\n    // fogF will be the proportion of fog\n    // Initialize it to the linear value\n    float fogF;\n    if (uFogMode > 0) {\n      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);\n      if (uFogMode > 1)\n        fogF = mix(uFogParms.w, 1.0, fogF);\n      fogF = fogF*uFogParms.z;\n      if (uFogMode == 2)\n        fogF = 1.0 - exp(-fogF);\n      // Docs are wrong: use (density*c)^2, not density*c^2\n      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58\n      else if (uFogMode == 3)\n        fogF = 1.0 - exp(-fogF*fogF);\n      fogF = clamp(fogF, 0.0, 1.0);\n      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\n    } else gl_FragColor = fragColor;\n#else\n    gl_FragColor = fragColor;\n#endif // HAS_FOG\n    \n}","players":[],"webGLoptions":{"preserveDrawingBuffer":true},"fastTransparency":true},"evals":[],"jsHooks":[]}</script>
<p class="caption">
polar zonohedra with 5 generators (left) and 25 generators (right) 
[both of these are interactive WebGL widgets]
</p>
<p id="rgl8754-aria" hidden>
polar zonohedra with 5 generators (left) and 25 generators (right)
&amp;emsp;&amp;emsp; [both of these are interactive WebGL widgets]
</p>
</div>
<p>In these 2 plots, the black dot is the origin, the 5 vertices nearest
to the origin are the 5 generators, and the white dot is the point
(0,0,<span class="math inline">\(\pi\)</span>). Each of the generators
is assigned a unique color, and every other edge with that color is
parallel to the generator. All parallelograms with an edge of that color
form the <em>zone</em> or <em>belt</em> for that generator. Each belt is
a topological annulus. For more details on these polar zonohedra, see
<span class="citation">[2]</span>.</p>
<p>Print the generators of the first zonohedron <code>pz5</code>; they
are the columns of this 3x5 matrix.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">getmatrix</span>( pz5 )</span></code></pre></div>
<pre><code>##              1         2          3          4          5
## [1,] 0.6283185 0.1941611 -0.5083204 -0.5083204  0.1941611
## [2,] 0.0000000 0.5975664  0.3693164 -0.3693164 -0.5975664
## [3,] 0.6283185 0.6283185  0.6283185  0.6283185  0.6283185</code></pre>
<p>A function similar to <code>polarzonohedron()</code> is
<code>regularprism()</code>.</p>
<p><br><br></p>
<p><br><br></p>
</div>
<div id="classic-zonohedra" class="section level1">
<h1>Classic Zonohedra</h1>
<p>There are 13 classic zonohedron available in the package, as a list
of 3xN matrices, where N is the number of generators. The global data
variable is <code>classics.genlist</code>, with S3 class
<code>&#39;genlist&#39;</code>. The 13 matrices in the list are taken from <span class="citation">[5]</span>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>classics.genlist</span></code></pre></div>
<pre><code>##                                   fullname generators vertices edges facets       area     volume pointed
## C                                     cube          3        8    12      6    6.00000    1.00000    TRUE
## RD                    rhombic dodecahedron          4       14    24     12   33.94113   16.00000    TRUE
## BD                   Bilinski dodecahedron          4       14    24     12   38.83282   16.94427    TRUE
## RI                     rhombic icosahedron          5       22    40     20   64.72136   42.36068    TRUE
## RHD          rhombo-hexagonal dodecahedron          5       18    28     12   72.55309   48.00000    TRUE
## RT                 rhombic triacontahedron          6       32    60     30   97.08204   84.72136    TRUE
## TO                    truncated octahedron          6       24    36     14   53.56922   32.00000    TRUE
## TRD         truncated rhombic dodecahedron          7       32    48     18  110.72888   98.76537    TRUE
## TC                 truncated cuboctahedron          9       48    72     26  123.51034  118.22540    TRUE
## RE                rhombic enneacontahedron         10       92   180     90  229.70563  318.88544   FALSE
## RH              rhombic hectotriadiohedron         12      134   264    132  869.36961 2367.25310   FALSE
## TI             truncated icosidodecahedron         15      120   180     62  697.16812 1654.42719    TRUE
## TSR truncated small rhombicosidodecahedron         21      240   360    122 1336.66780 4497.87138   FALSE</code></pre>
<p>Extract the matrix of generators for the
<code>truncated cuboctahedron</code>, which is abbreviated by
<code>TC</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>mat <span class="ot">=</span> classics.genlist[[<span class="st">&#39;TC&#39;</span>]] ; mat</span></code></pre></div>
<pre><code>##      [,1]     [,2] [,3] [,4] [,5]     [,6] [,7]     [,8] [,9]
## [1,]    1 1.414214    1    0    1 0.000000    0 0.000000    1
## [2,]   -1 0.000000    0    1    1 1.414214    1 0.000000    0
## [3,]    0 0.000000   -1   -1    0 0.000000    1 1.414214    1
## attr(,&quot;shortname&quot;)
## [1] &quot;TC&quot;
## attr(,&quot;fullname&quot;)
## [1] &quot;truncated cuboctahedron&quot;</code></pre>
<p>Create the truncated cuboctahedron and plot it, with filled
faces.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>rgl<span class="sc">::</span><span class="fu">par3d</span>( <span class="at">userMatrix =</span> <span class="fu">rotationMatrix</span>( <span class="sc">-</span><span class="dv">20</span><span class="sc">*</span>pi<span class="sc">/</span><span class="dv">180</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>) )</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>zono <span class="ot">=</span> <span class="fu">zonohedron</span>( mat )</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a><span class="fu">plot</span>( zono, <span class="at">type=</span><span class="st">&#39;f&#39;</span> )</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>rgl<span class="sc">::</span><span class="fu">rglwidget</span>( <span class="at">webgl=</span><span class="cn">TRUE</span> )</span></code></pre></div>
<div class="figure" style="text-align: center">
<div id="rgl43555" style="width:768px;height:480px;" class="rglWebGL html-widget" role="img" aria-labelledby="rgl43555-aria"></div>
<script type="application/json" data-for="rgl43555">{"x":{"material":{"color":"#000000","alpha":1,"lit":true,"ambient":"#000000","specular":"#FFFFFF","emission":"#000000","shininess":50,"smooth":true,"front":"filled","back":"filled","size":3,"lwd":1,"fog":true,"point_antialias":false,"line_antialias":false,"texture":null,"textype":"rgb","texmode":"modulate","texmipmap":false,"texminfilter":"linear","texmagfilter":"linear","texenvmap":false,"depth_mask":true,"depth_test":"less","isTransparent":false,"polygon_offset":[0,0],"margin":"","floating":false,"tag":"","blend":["src_alpha","one_minus_src_alpha"]},"rootSubscene":174,"objects":{"183":{"id":183,"type":"points","material":{"lit":false,"size":10,"point_antialias":true},"vertices":"0","colors":"1","centers":"2","ignoreExtent":false,"flags":34816},"184":{"id":184,"type":"points","material":{"lit":false,"size":10,"point_antialias":true},"vertices":"3","colors":"4","centers":"5","ignoreExtent":false,"flags":34816},"185":{"id":185,"type":"points","material":{"lit":false,"size":10,"point_antialias":true},"vertices":"6","colors":"7","centers":"8","ignoreExtent":false,"flags":34816},"186":{"id":186,"type":"linestrip","material":{"lit":false,"lwd":3},"vertices":"9","colors":"10","centers":"11","ignoreExtent":false,"flags":41024},"187":{"id":187,"type":"quads","material":{},"vertices":"12","colors":"14","centers":"15","normals":"13","ignoreExtent":false,"flags":32771},"188":{"id":188,"type":"quads","material":{},"vertices":"16","colors":"18","centers":"19","normals":"17","ignoreExtent":false,"flags":32771},"189":{"id":189,"type":"quads","material":{},"vertices":"20","colors":"22","centers":"23","normals":"21","ignoreExtent":false,"flags":32771},"190":{"id":190,"type":"quads","material":{},"vertices":"24","colors":"26","centers":"27","normals":"25","ignoreExtent":false,"flags":32771},"191":{"id":191,"type":"quads","material":{},"vertices":"28","colors":"30","centers":"31","normals":"29","ignoreExtent":false,"flags":32771},"192":{"id":192,"type":"quads","material":{},"vertices":"32","colors":"34","centers":"35","normals":"33","ignoreExtent":false,"flags":32771},"193":{"id":193,"type":"quads","material":{},"vertices":"36","colors":"38","centers":"39","normals":"37","ignoreExtent":false,"flags":32771},"194":{"id":194,"type":"quads","material":{},"vertices":"40","colors":"42","centers":"43","normals":"41","ignoreExtent":false,"flags":32771},"195":{"id":195,"type":"quads","material":{},"vertices":"44","colors":"46","centers":"47","normals":"45","ignoreExtent":false,"flags":32771},"196":{"id":196,"type":"quads","material":{},"vertices":"48","colors":"50","centers":"51","normals":"49","ignoreExtent":false,"flags":32771},"197":{"id":197,"type":"quads","material":{},"vertices":"52","colors":"54","centers":"55","normals":"53","ignoreExtent":false,"flags":32771},"198":{"id":198,"type":"quads","material":{},"vertices":"56","colors":"58","centers":"59","normals":"57","ignoreExtent":false,"flags":32771},"199":{"id":199,"type":"quads","material":{},"vertices":"60","colors":"62","centers":"63","normals":"61","ignoreExtent":false,"flags":32771},"200":{"id":200,"type":"quads","material":{},"vertices":"64","colors":"66","centers":"67","normals":"65","ignoreExtent":false,"flags":32771},"201":{"id":201,"type":"quads","material":{},"vertices":"68","colors":"70","centers":"71","normals":"69","ignoreExtent":false,"flags":32771},"178":{"id":178,"type":"light","vertices":[[0,0,1]],"colors":[[1,1,1,1],[1,1,1,1],[1,1,1,1]],"viewpoint":true,"finite":false},"182":{"id":182,"type":"background","material":{"lit":false,"back":"lines"},"colors":"72","centers":"73","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"174":{"id":174,"type":"subscene","par3d":{"antialias":8,"FOV":30,"ignoreExtent":false,"listeners":174,"mouseMode":{"none":"none","left":"trackball","right":"zoom","middle":"fov","wheel":"pull"},"observer":[0,0,18.11631202697754],"modelMatrix":[[0.9396926164627075,0.2418447583913803,-0.2418447583913803,-2.785693168640137],[-0.2418447583913803,0.9698463082313538,0.03015368990600109,-1.022253632545471],[0.2418447583913803,0.03015368990600109,0.9698463082313538,-19.50827217102051],[0,0,0,1]],"projMatrix":[[3.732050895690918,0,0,0],[0,3.732050895690918,0,0],[0,0,-3.86370325088501,-65.30721282958984],[0,0,-1,0]],"skipRedraw":false,"userMatrix":[[0.9396926207859084,0.2418447626479752,-0.2418447626479752,0],[-0.2418447626479752,0.9698463103929542,0.03015368960704578,0],[0.2418447626479752,0.03015368960704578,0.9698463103929542,0],[0,0,0,1]],"userProjection":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],"scale":[1,1,1],"viewport":{"x":0,"y":0,"width":1,"height":1},"zoom":1,"bbox":[-4.440892098500626e-16,5.41421365737915,-1,4.41421365737915,-2,3.41421365737915],"windowRect":[86,109,342,365],"family":"sans","font":1,"cex":1,"useFreeType":false,"fontname":"TT Arial","maxClipPlanes":8,"glVersion":4.6,"activeSubscene":0},"embeddings":{"viewport":"replace","projection":"replace","model":"replace","mouse":"replace"},"objects":[182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,178],"subscenes":[],"flags":43331}},"crosstalk":{"key":[],"group":[],"id":[],"options":[]},"width":768,"height":480,"buffer":{"accessors":[{"bufferView":0,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":1,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":2,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":3,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":4,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":5,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":6,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":7,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":8,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":9,"componentType":5126,"count":2,"type":"VEC3"},{"bufferView":10,"componentType":5121,"count":2,"type":"VEC4","normalized":true},{"bufferView":11,"componentType":5126,"count":2,"type":"VEC3"},{"bufferView":12,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":13,"componentType":5126,"count":48,"type":"VEC3"},{"bufferView":14,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":15,"componentType":5126,"count":12,"type":"VEC3"},{"bufferView":16,"componentType":5126,"count":12,"type":"VEC3"},{"bufferView":17,"componentType":5126,"count":12,"type":"VEC3"},{"bufferView":18,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":19,"componentType":5126,"count":3,"type":"VEC3"},{"bufferView":20,"componentType":5126,"count":12,"type":"VEC3"},{"bufferView":21,"componentType":5126,"count":12,"type":"VEC3"},{"bufferView":22,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":23,"componentType":5126,"count":3,"type":"VEC3"},{"bufferView":24,"componentType":5126,"count":12,"type":"VEC3"},{"bufferView":25,"componentType":5126,"count":12,"type":"VEC3"},{"bufferView":26,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":27,"componentType":5126,"count":3,"type":"VEC3"},{"bufferView":28,"componentType":5126,"count":12,"type":"VEC3"},{"bufferView":29,"componentType":5126,"count":12,"type":"VEC3"},{"bufferView":30,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":31,"componentType":5126,"count":3,"type":"VEC3"},{"bufferView":32,"componentType":5126,"count":12,"type":"VEC3"},{"bufferView":33,"componentType":5126,"count":12,"type":"VEC3"},{"bufferView":34,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":35,"componentType":5126,"count":3,"type":"VEC3"},{"bufferView":36,"componentType":5126,"count":12,"type":"VEC3"},{"bufferView":37,"componentType":5126,"count":12,"type":"VEC3"},{"bufferView":38,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":39,"componentType":5126,"count":3,"type":"VEC3"},{"bufferView":40,"componentType":5126,"count":8,"type":"VEC3"},{"bufferView":41,"componentType":5126,"count":8,"type":"VEC3"},{"bufferView":42,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":43,"componentType":5126,"count":2,"type":"VEC3"},{"bufferView":44,"componentType":5126,"count":8,"type":"VEC3"},{"bufferView":45,"componentType":5126,"count":8,"type":"VEC3"},{"bufferView":46,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":47,"componentType":5126,"count":2,"type":"VEC3"},{"bufferView":48,"componentType":5126,"count":8,"type":"VEC3"},{"bufferView":49,"componentType":5126,"count":8,"type":"VEC3"},{"bufferView":50,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":51,"componentType":5126,"count":2,"type":"VEC3"},{"bufferView":52,"componentType":5126,"count":8,"type":"VEC3"},{"bufferView":53,"componentType":5126,"count":8,"type":"VEC3"},{"bufferView":54,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":55,"componentType":5126,"count":2,"type":"VEC3"},{"bufferView":56,"componentType":5126,"count":8,"type":"VEC3"},{"bufferView":57,"componentType":5126,"count":8,"type":"VEC3"},{"bufferView":58,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":59,"componentType":5126,"count":2,"type":"VEC3"},{"bufferView":60,"componentType":5126,"count":8,"type":"VEC3"},{"bufferView":61,"componentType":5126,"count":8,"type":"VEC3"},{"bufferView":62,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":63,"componentType":5126,"count":2,"type":"VEC3"},{"bufferView":64,"componentType":5126,"count":8,"type":"VEC3"},{"bufferView":65,"componentType":5126,"count":8,"type":"VEC3"},{"bufferView":66,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":67,"componentType":5126,"count":2,"type":"VEC3"},{"bufferView":68,"componentType":5126,"count":8,"type":"VEC3"},{"bufferView":69,"componentType":5126,"count":8,"type":"VEC3"},{"bufferView":70,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":71,"componentType":5126,"count":2,"type":"VEC3"},{"bufferView":72,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":73,"componentType":5121,"count":1,"type":"VEC3"}],"bufferViews":[{"buffer":0,"byteLength":3,"byteOffset":0},{"buffer":0,"byteLength":4,"byteOffset":3},{"buffer":0,"byteLength":3,"byteOffset":7},{"buffer":0,"byteLength":12,"byteOffset":12},{"buffer":0,"byteLength":4,"byteOffset":24},{"buffer":0,"byteLength":12,"byteOffset":28},{"buffer":0,"byteLength":12,"byteOffset":40},{"buffer":0,"byteLength":16,"byteOffset":52},{"buffer":0,"byteLength":12,"byteOffset":68},{"buffer":0,"byteLength":24,"byteOffset":80},{"buffer":0,"byteLength":8,"byteOffset":104},{"buffer":0,"byteLength":24,"byteOffset":112},{"buffer":0,"byteLength":576,"byteOffset":136},{"buffer":0,"byteLength":576,"byteOffset":712},{"buffer":0,"byteLength":4,"byteOffset":1288},{"buffer":0,"byteLength":144,"byteOffset":1292},{"buffer":0,"byteLength":144,"byteOffset":1436},{"buffer":0,"byteLength":144,"byteOffset":1580},{"buffer":0,"byteLength":4,"byteOffset":1724},{"buffer":0,"byteLength":36,"byteOffset":1728},{"buffer":0,"byteLength":144,"byteOffset":1764},{"buffer":0,"byteLength":144,"byteOffset":1908},{"buffer":0,"byteLength":4,"byteOffset":2052},{"buffer":0,"byteLength":36,"byteOffset":2056},{"buffer":0,"byteLength":144,"byteOffset":2092},{"buffer":0,"byteLength":144,"byteOffset":2236},{"buffer":0,"byteLength":4,"byteOffset":2380},{"buffer":0,"byteLength":36,"byteOffset":2384},{"buffer":0,"byteLength":144,"byteOffset":2420},{"buffer":0,"byteLength":144,"byteOffset":2564},{"buffer":0,"byteLength":4,"byteOffset":2708},{"buffer":0,"byteLength":36,"byteOffset":2712},{"buffer":0,"byteLength":144,"byteOffset":2748},{"buffer":0,"byteLength":144,"byteOffset":2892},{"buffer":0,"byteLength":4,"byteOffset":3036},{"buffer":0,"byteLength":36,"byteOffset":3040},{"buffer":0,"byteLength":144,"byteOffset":3076},{"buffer":0,"byteLength":144,"byteOffset":3220},{"buffer":0,"byteLength":4,"byteOffset":3364},{"buffer":0,"byteLength":36,"byteOffset":3368},{"buffer":0,"byteLength":96,"byteOffset":3404},{"buffer":0,"byteLength":96,"byteOffset":3500},{"buffer":0,"byteLength":4,"byteOffset":3596},{"buffer":0,"byteLength":24,"byteOffset":3600},{"buffer":0,"byteLength":96,"byteOffset":3624},{"buffer":0,"byteLength":96,"byteOffset":3720},{"buffer":0,"byteLength":4,"byteOffset":3816},{"buffer":0,"byteLength":24,"byteOffset":3820},{"buffer":0,"byteLength":96,"byteOffset":3844},{"buffer":0,"byteLength":96,"byteOffset":3940},{"buffer":0,"byteLength":4,"byteOffset":4036},{"buffer":0,"byteLength":24,"byteOffset":4040},{"buffer":0,"byteLength":96,"byteOffset":4064},{"buffer":0,"byteLength":96,"byteOffset":4160},{"buffer":0,"byteLength":4,"byteOffset":4256},{"buffer":0,"byteLength":24,"byteOffset":4260},{"buffer":0,"byteLength":96,"byteOffset":4284},{"buffer":0,"byteLength":96,"byteOffset":4380},{"buffer":0,"byteLength":4,"byteOffset":4476},{"buffer":0,"byteLength":24,"byteOffset":4480},{"buffer":0,"byteLength":96,"byteOffset":4504},{"buffer":0,"byteLength":96,"byteOffset":4600},{"buffer":0,"byteLength":4,"byteOffset":4696},{"buffer":0,"byteLength":24,"byteOffset":4700},{"buffer":0,"byteLength":96,"byteOffset":4724},{"buffer":0,"byteLength":96,"byteOffset":4820},{"buffer":0,"byteLength":4,"byteOffset":4916},{"buffer":0,"byteLength":24,"byteOffset":4920},{"buffer":0,"byteLength":96,"byteOffset":4944},{"buffer":0,"byteLength":96,"byteOffset":5040},{"buffer":0,"byteLength":4,"byteOffset":5136},{"buffer":0,"byteLength":24,"byteOffset":5140},{"buffer":0,"byteLength":16,"byteOffset":5164},{"buffer":0,"byteLength":3,"byteOffset":5180}],"buffers":[{"byteLength":5183,"bytes":"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\nPUGNQD1BjUDzBLU/PUGtQHqCWkDzBLU/PUGtQHqCGkB6ghpAPUGNQHqCGkB6glpAO80TvzrN\nE786zRO/O80TvzrNE786zRO/O80TvzrNE786zRO/O80TvzrNE786zRO/O80TvzvNE786zRO/\nO80TvzvNE786zRO/O80TvzvNE786zRO/O80TvzvNE786zRO/AQAAAXqCekB6gmpAeoIqQD1B\nnUB6gkpAeoIKQAAAgD8AAIA/eoJaQAAAAKYAAIA/eoIaQAAAAEAAAIC/eoIaQAAAAEAAAAAl\neoJaQAAAAKYAAIA/eoIaQAAAgKUAAACl8wS1PwAAgD8AAIC/8wS1PwAAAEAAAIC/eoIaQDrN\nE786zRO/Os0TPzrNE786zRO/Os0TPzrNE786zRO/Os0TPzrNE786zRO/Os0TPzvNE787zRO/\nOs0TPzvNE787zRO/Os0TPzvNE787zRO/Os0TPzvNE787zRO/Os0TPwEAAAEAAKA/AACAPnqC\nOkAAAEA/AACAvvQE9T89QY1APUGNQAAAACV6glpAPUGNQAAAgL89Qa1AeoIaQAAAgL89Qa1A\neoJaQAAAwCV6glpAPUGNQAAAgL96glpAeoJaQAAAAMA9QY1AeoIaQAAAAMA9Qa1AeoIaQAAA\ngL86zRO/Os0TvzrNEz86zRO/Os0TvzrNEz86zRO/Os0TvzrNEz86zRO/Os0TvzrNEz86zRO/\nOs0TvzrNEz86zRO/Os0TvzrNEz86zRO/Os0TvzrNEz86zRO/Os0TvzrNEz8BAAABPUGVQHqC\nakAAAAC/PUGFQHqCSkAAAMC/AACAPz1BjUAAAAAlAAAAQD1BjUAAAIC/AACApXqCGkAAAIC/\nAAAApnqCWkAAAMAlAAAAQD1BjUAAAIC/AAAAQHqCWkAAAADAAACAP3qCGkAAAADAAACApXqC\nGkAAAIC/Os0TvzrNEz86zRO/Os0TvzrNEz86zRO/Os0TvzrNEz86zRO/Os0TvzrNEz86zRO/\nOs0TvzrNEz86zRO/Os0TvzrNEz86zRO/Os0TvzrNEz86zRO/Os0TvzrNEz86zRO/AQAAAQAA\nQD96gmpAAAAAvwAAoD96gkpAAADAvz1BjUAAAIA/eoJaQD1BrUAAAIA/eoIaQHqCWkAAAIC/\neoIaQHqCWkAAAAAAeoJaQD1BrUAAAIA/eoIaQD1BrUAAAAAA8wS1Pz1BjUAAAIC/8wS1P3qC\nWkAAAIC/eoIaQDrNE786zRM/Os0TvzrNE786zRM/Os0TvzrNE786zRM/Os0TvzrNE786zRM/\nOs0TvzvNE787zRM/Os0TvzvNE787zRM/Os0TvzvNE787zRM/Os0TvzvNE787zRM/Os0TvwEA\nAAE9QYVAAACAPnqCOkA9QZVAAACAvvQE9T8AAABAPUGNQHqCGkAAAIA/PUGNQPMEtT8AAIA/\neoIaQHqCWkAAAABAeoJaQHqCWkAAAIA/PUGNQPMEtT8AAACmeoJaQPMEtT8AAICleoIaQHqC\nGkAAAIA/eoIaQHqCWkA7zRO/Os0TPzrNEz87zRO/Os0TPzrNEz87zRO/Os0TPzrNEz87zRO/\nOs0TPzrNEz87zRO/O80TPzrNEz87zRO/O80TPzrNEz87zRO/O80TPzrNEz87zRO/O80TPzrN\nEz8BAAABAADAP3qCakB6gipAAAAAP3qCSkB6ggpAPUGtQAAAgD8AAIC/PUGNQAAAgD8AAADA\nPUGNQAAAgL8AAAAlPUGtQAAAAAAAAMAlPUGNQAAAgD8AAADAeoJaQAAAAAAAAADAeoJaQAAA\ngL8AAIC/PUGNQAAAgL8AAAAlOs0TvzrNEz86zRM/Os0TvzrNEz86zRM/Os0TvzrNEz86zRM/\nOs0TvzrNEz86zRM/Os0TvzrNEz86zRM/Os0TvzrNEz86zRM/Os0TvzrNEz86zRM/Os0TvzrN\nEz86zRM/AQAAAT1BnUAAAIA+AABAv3qCekAAAIC+AACgv83MzD7NzMw+zczMPgAAgD8AAAA="}]},"context":{"shiny":false,"rmarkdown":"rmarkdown::html_vignette"},"vertexShader":"#line 2 1\n// File 1 is the vertex shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\n\nattribute vec3 aPos;\nattribute vec4 aCol;\nuniform mat4 mvMatrix;\nuniform mat4 prMatrix;\nvarying vec4 vCol;\nvarying vec4 vPosition;\n\n#ifdef NEEDS_VNORMAL\nattribute vec3 aNorm;\nuniform mat4 normMatrix;\nvarying vec4 vNormal;\n#endif\n\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nattribute vec2 aTexcoord;\nvarying vec2 vTexcoord;\n#endif\n\n#ifdef FIXED_SIZE\nuniform vec3 textScale;\n#endif\n\n#ifdef FIXED_QUADS\nattribute vec3 aOfs;\n#endif\n\n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\nvarying float normz;\nuniform mat4 invPrMatrix;\n#else\nattribute vec3 aPos1;\nattribute vec3 aPos2;\nvarying float normz;\n#endif\n#endif // IS_TWOSIDED\n\n#ifdef FAT_LINES\nattribute vec3 aNext;\nattribute vec2 aPoint;\nvarying vec2 vPoint;\nvarying float vLength;\nuniform float uAspect;\nuniform float uLwd;\n#endif\n\n#ifdef USE_ENVMAP\nvarying vec3 vReflection;\n#endif\n\nvoid main(void) {\n  \n#ifndef IS_BRUSH\n#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG) || defined(USE_ENVMAP)\n  vPosition = mvMatrix * vec4(aPos, 1.);\n#endif\n  \n#ifndef FIXED_QUADS\n  gl_Position = prMatrix * vPosition;\n#endif\n#endif // !IS_BRUSH\n  \n#ifdef IS_POINTS\n  gl_PointSize = POINTSIZE;\n#endif\n  \n  vCol = aCol;\n  \n// USE_ENVMAP implies NEEDS_VNORMAL\n\n#ifdef NEEDS_VNORMAL\n  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\n#endif\n\n#ifdef USE_ENVMAP\n  vReflection = normalize(reflect(vPosition.xyz/vPosition.w, \n                        normalize(vNormal.xyz/vNormal.w)));\n#endif\n  \n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\n  /* normz should be calculated *after* projection */\n  normz = (invPrMatrix*vNormal).z;\n#else\n  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\n  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\n  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\n  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\n  normz = pos1.x*pos2.y - pos1.y*pos2.x;\n#endif\n#endif // IS_TWOSIDED\n  \n#ifdef NEEDS_VNORMAL\n  vNormal = vec4(normalize(vNormal.xyz), 1);\n#endif\n  \n#if defined(HAS_TEXTURE) || defined(IS_TEXT)\n  vTexcoord = aTexcoord;\n#endif\n  \n#if defined(FIXED_SIZE) && !defined(ROTATING)\n  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w;\n  gl_Position = pos + vec4(aOfs*textScale, 0.);\n#endif\n  \n#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\n  vec4 pos = mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w + vec4(aOfs,  0.);\n  gl_Position = prMatrix*pos;\n#endif\n  \n#ifdef FAT_LINES\n  /* This code was inspired by Matt Deslauriers' code in \n   https://mattdesl.svbtle.com/drawing-lines-is-hard */\n  vec2 aspectVec = vec2(uAspect, 1.0);\n  mat4 projViewModel = prMatrix * mvMatrix;\n  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\n  currentProjected = currentProjected/currentProjected.w;\n  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\n  vec2 currentScreen = currentProjected.xy * aspectVec;\n  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\n  float len = uLwd;\n  vec2 dir = vec2(1.0, 0.0);\n  vPoint = aPoint;\n  vLength = length(nextScreen - currentScreen)/2.0;\n  vLength = vLength/(vLength + len);\n  if (vLength > 0.0) {\n    dir = normalize(nextScreen - currentScreen);\n  }\n  vec2 normal = vec2(-dir.y, dir.x);\n  dir.x /= uAspect;\n  normal.x /= uAspect;\n  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\n  gl_Position = currentProjected + offset;\n#endif\n  \n#ifdef IS_BRUSH\n  gl_Position = vec4(aPos, 1.);\n#endif\n}","fragmentShader":"#line 2 2\n// File 2 is the fragment shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\nvarying vec4 vCol; // carries alpha\nvarying vec4 vPosition;\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nvarying vec2 vTexcoord;\nuniform sampler2D uSampler;\n#endif\n\n#ifdef HAS_FOG\nuniform int uFogMode;\nuniform vec3 uFogColor;\nuniform vec4 uFogParms;\n#endif\n\n#if defined(IS_LIT) && !defined(FIXED_QUADS)\nvarying vec4 vNormal;\n#endif\n\n#if NCLIPPLANES > 0\nuniform vec4 vClipplane[NCLIPPLANES];\n#endif\n\n#if NLIGHTS > 0\nuniform mat4 mvMatrix;\n#endif\n\n#ifdef IS_LIT\nuniform vec3 emission;\nuniform float shininess;\n#if NLIGHTS > 0\nuniform vec3 ambient[NLIGHTS];\nuniform vec3 specular[NLIGHTS]; // light*material\nuniform vec3 diffuse[NLIGHTS];\nuniform vec3 lightDir[NLIGHTS];\nuniform bool viewpoint[NLIGHTS];\nuniform bool finite[NLIGHTS];\n#endif\n#endif // IS_LIT\n\n#ifdef IS_TWOSIDED\nuniform bool front;\nvarying float normz;\n#endif\n\n#ifdef FAT_LINES\nvarying vec2 vPoint;\nvarying float vLength;\n#endif\n\n#ifdef USE_ENVMAP\nvarying vec3 vReflection;\n#endif\n\nvoid main(void) {\n  vec4 fragColor;\n#ifdef FAT_LINES\n  vec2 point = vPoint;\n  bool neg = point.y < 0.0;\n  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :\n                 -(point.y - vLength)/(1.0 - vLength);\n#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\n  if (neg && length(point) <= 1.0) discard;\n#endif\n  point.y = min(point.y, 0.0);\n  if (length(point) > 1.0) discard;\n#endif // FAT_LINES\n  \n#ifdef ROUND_POINTS\n  vec2 coord = gl_PointCoord - vec2(0.5);\n  if (length(coord) > 0.5) discard;\n#endif\n  \n#if NCLIPPLANES > 0\n  for (int i = 0; i < NCLIPPLANES; i++)\n    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\n#endif\n    \n#ifdef FIXED_QUADS\n    vec3 n = vec3(0., 0., 1.);\n#elif defined(IS_LIT)\n    vec3 n = normalize(vNormal.xyz);\n#endif\n    \n#ifdef IS_TWOSIDED\n    if ((normz <= 0.) != front) discard;\n#endif\n\n#ifdef IS_LIT\n    vec3 eye = normalize(-vPosition.xyz/vPosition.w);\n    vec3 lightdir;\n    vec4 colDiff;\n    vec3 halfVec;\n    vec4 lighteffect = vec4(emission, 0.);\n    vec3 col;\n    float nDotL;\n#ifdef FIXED_QUADS\n    n = -faceforward(n, n, eye);\n#endif\n    \n#if NLIGHTS > 0\n    // Simulate two-sided lighting\n    if (n.z < 0.0)\n      n = -n;\n    for (int i=0;i<NLIGHTS;i++) {\n      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\n      lightdir = lightDir[i];\n      if (!viewpoint[i]) {\n        if (finite[i]) {\n          lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\n        } else {\n          lightdir = (mvMatrix * vec4(lightdir, 0.)).xyz;\n        }\n      }\n      if (!finite[i]) {\n        halfVec = normalize(lightdir + eye);\n      } else {\n        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);\n        halfVec = normalize(lightdir + eye);\n      }\n      col = ambient[i];\n      nDotL = dot(n, lightdir);\n      col = col + max(nDotL, 0.) * colDiff.rgb;\n      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\n      lighteffect = lighteffect + vec4(col, colDiff.a);\n    }\n#endif\n    \n#else // not IS_LIT\n    vec4 colDiff = vCol;\n    vec4 lighteffect = colDiff;\n#endif\n    \n#ifdef IS_TEXT\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n#endif\n    \n#ifdef HAS_TEXTURE\n\n// These calculations use the definitions from \n// https://docs.gl/gl3/glTexEnv\n\n#ifdef USE_ENVMAP\n    float m = 2.0 * sqrt(dot(vReflection, vReflection) + 2.0*vReflection.z + 1.0);\n    vec4 textureColor = texture2D(uSampler, vReflection.xy / m + vec2(0.5, 0.5));\n#else\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\n#endif\n\n#ifdef TEXTURE_rgb\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(textureColor.rgb, lighteffect.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = lighteffect*vec4(textureColor.rgb, 1.);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb, lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb, lighteffect.a);\n#endif\n\n#endif //TEXTURE_rgb\n        \n#ifdef TEXTURE_rgba\n\n#ifdef TEXMODE_replace\n// already done\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = lighteffect*textureColor;\n#endif\n\n#ifdef TEXMODE_decal\n    textureColor = vec4((1. - textureColor.a)*lighteffect.rgb) +\n                     textureColor.a*textureColor.rgb, \n                     lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb,\n                    lighteffect.a*textureColor.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb,\n                    lighteffect.a*textureColor.a);\n#endif\n    \n#endif //TEXTURE_rgba\n    \n#ifdef TEXTURE_alpha\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(lighteffect.rgb, luminance);\n#endif \n\n#if defined(TEXMODE_modulate) || defined(TEXMODE_blend) || defined(TEXMODE_add)\n    textureColor = vec4(lighteffect.rgb, lighteffect.a*luminance);\n#endif\n \n#endif // TEXTURE_alpha\n    \n// The TEXTURE_luminance values are not from that reference    \n#ifdef TEXTURE_luminance\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(luminance, luminance, luminance, lighteffect.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = vec4(luminance*lighteffect.rgb, lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n                        lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(luminance + lighteffect.rgb, lighteffect.a);\n#endif\n\n#endif // TEXTURE_luminance\n \n    \n#ifdef TEXTURE_luminance_alpha\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(luminance, luminance, luminance, textureColor.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = vec4(luminance*lighteffect.rgb, \n                        textureColor.a*lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n                        textureColor.a*lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(luminance + lighteffect.rgb, \n                        textureColor.a*lighteffect.a);\n\n#endif\n\n#endif // TEXTURE_luminance_alpha\n    \n    fragColor = textureColor;\n\n#elif defined(IS_TEXT)\n    if (textureColor.a < 0.1)\n      discard;\n    else\n      fragColor = textureColor;\n#else\n    fragColor = lighteffect;\n#endif // HAS_TEXTURE\n    \n#ifdef HAS_FOG\n    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))\n    // In Exp and Exp2: use density = density/far\n    // fogF will be the proportion of fog\n    // Initialize it to the linear value\n    float fogF;\n    if (uFogMode > 0) {\n      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);\n      if (uFogMode > 1)\n        fogF = mix(uFogParms.w, 1.0, fogF);\n      fogF = fogF*uFogParms.z;\n      if (uFogMode == 2)\n        fogF = 1.0 - exp(-fogF);\n      // Docs are wrong: use (density*c)^2, not density*c^2\n      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58\n      else if (uFogMode == 3)\n        fogF = 1.0 - exp(-fogF*fogF);\n      fogF = clamp(fogF, 0.0, 1.0);\n      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\n    } else gl_FragColor = fragColor;\n#else\n    gl_FragColor = fragColor;\n#endif // HAS_FOG\n    \n}","players":[],"webGLoptions":{"preserveDrawingBuffer":true},"fastTransparency":true},"evals":[],"jsHooks":[]}</script>
<p class="caption">
truncated cuboctahedron  [This is an interactive WebGL widget]
</p>
<p id="rgl43555-aria" hidden>
truncated cuboctahedron &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp; [This
is an interactive WebGL widget]
</p>
</div>
<p><br> Some WebM video plots in the next section are made with help of
the package <strong>av</strong> and this function:</p>
<button id="B-spinit()" onclick="ToggleDiv(&#39;spinit()&#39;)">
Show spinit()
</button>
<div id="D-spinit()" style="display: none">
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="co">#   zono        the zonohedron</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a><span class="co">#   id          unique ID for this animation, a positive integer</span></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a><span class="co">#   fps         frames per second</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a><span class="co">#   duration    of the animation, in seconds</span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a><span class="co">#   revolutions number of revolutions</span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a><span class="co">#   vpsize      viewport size = (width,height)</span></span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a>spinit <span class="ot">&lt;-</span> <span class="cf">function</span>( zono, index, <span class="at">fps=</span><span class="dv">5</span>, <span class="at">duration=</span><span class="dv">8</span>, <span class="at">revolutions=</span><span class="dv">1</span>, <span class="at">vpsize=</span><span class="fu">c</span>(<span class="dv">480</span>,<span class="dv">480</span>) ) {</span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a><span class="co">#  enlarge viewport</span></span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a>wr <span class="ot">=</span> <span class="fu">par3d</span>( <span class="st">&quot;windowRect&quot;</span> ) </span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a><span class="fu">par3d</span>( <span class="at">windowRect =</span> <span class="fu">c</span>( wr[<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>], wr[<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>] <span class="sc">+</span> vpsize ) )</span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a>pathtemp <span class="ot">=</span> <span class="fu">tempdir</span>()   <span class="co">#&quot;./figs&quot; ;   if( ! file.exists(pathtemp) ) dir.create(pathtemp)  # make temp folder</span></span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a><span class="co">#  make a lot of .PNG files in pathtemp</span></span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a><span class="fu">movie3d</span>( <span class="fu">spin3d</span>( <span class="fu">getcenter</span>(zono), <span class="at">rpm=</span>revolutions<span class="sc">*</span><span class="dv">60</span><span class="sc">/</span>duration ), <span class="at">duration=</span>duration, <span class="at">fps=</span>fps, <span class="at">startTime=</span><span class="dv">1</span><span class="sc">/</span>fps,</span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a>           <span class="at">convert=</span>F, <span class="at">movie=</span><span class="st">&#39;junk&#39;</span>, <span class="at">dir=</span>pathtemp, <span class="at">verbose=</span>F, <span class="at">webshot=</span>F )</span>
<span id="cb10-15"><a href="#cb10-15" tabindex="-1"></a><span class="co">#  combine all the .PNGs into a single .webm</span></span>
<span id="cb10-16"><a href="#cb10-16" tabindex="-1"></a>pathvec <span class="ot">=</span> <span class="fu">dir</span>( pathtemp, <span class="at">pattern=</span><span class="st">&quot;png$&quot;</span>, <span class="at">full=</span>T )</span>
<span id="cb10-17"><a href="#cb10-17" tabindex="-1"></a></span>
<span id="cb10-18"><a href="#cb10-18" tabindex="-1"></a>webm_file <span class="ot">=</span> <span class="fu">sprintf</span>( <span class="st">&quot;%s/animation%g.webm&quot;</span>, pathtemp, index )</span>
<span id="cb10-19"><a href="#cb10-19" tabindex="-1"></a>out <span class="ot">=</span> av<span class="sc">::</span><span class="fu">av_encode_video</span>( pathvec, <span class="at">output=</span>webm_file, <span class="at">framerate=</span>fps, <span class="at">codec=</span><span class="st">&#39;libvpx-vp9&#39;</span>, <span class="at">verbose=</span>F )</span>
<span id="cb10-20"><a href="#cb10-20" tabindex="-1"></a>res <span class="ot">=</span> <span class="fu">file.remove</span>( pathvec )  <span class="co"># cleanup the .PNG files, leaving just the .webm</span></span>
<span id="cb10-21"><a href="#cb10-21" tabindex="-1"></a></span>
<span id="cb10-22"><a href="#cb10-22" tabindex="-1"></a><span class="fu">return</span>( out )</span>
<span id="cb10-23"><a href="#cb10-23" tabindex="-1"></a>}</span></code></pre></div>
</div>
<p><br></p>
<p>Embedding videos in the HTML output is done with the help of the
package <strong>base64enc</strong> and this function:</p>
<button id="B-video2html()" onclick="ToggleDiv(&#39;video2html()&#39;)">
Show video2html()
</button>
<div id="D-video2html()" style="display: none">
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>video2html  <span class="ot">&lt;-</span> <span class="cf">function</span>( path, <span class="at">attributes=</span><span class="st">&quot;controls loop autoplay muted&quot;</span> )</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>    {</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>    <span class="fu">requireNamespace</span>( <span class="st">&quot;base64enc&quot;</span>, <span class="at">quietly=</span><span class="cn">TRUE</span> )</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>    </span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>    i   <span class="ot">=</span> <span class="fu">regexpr</span>( <span class="st">&quot;[.][a-z]+$&quot;</span>, path, <span class="at">ignore.case=</span>T )</span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a>    <span class="cf">if</span>( i <span class="sc">&lt;</span> <span class="dv">0</span> ) <span class="fu">return</span>(<span class="st">&#39;&#39;</span>)</span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a>    ext <span class="ot">=</span> <span class="fu">substring</span>( path, i<span class="sc">+</span><span class="dv">1</span> )    <span class="co"># extract the extension, and skip over the &#39;.&#39;</span></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a>    </span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a>    part1   <span class="ot">=</span> <span class="fu">sprintf</span>( <span class="st">&#39;&lt;video %s src=&quot;data:video/%s;base64,</span><span class="sc">\n</span><span class="st">&#39;</span>, attributes, ext )</span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a>    part2   <span class="ot">=</span> base64enc<span class="sc">::</span><span class="fu">base64encode</span>( path, <span class="at">linewidth=</span><span class="dv">120</span>, <span class="at">newline=</span><span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> )</span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a>    part3   <span class="ot">=</span> <span class="st">&#39;&quot;&gt;&lt;/video&gt;&#39;</span></span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a>    </span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a>    <span class="fu">return</span>( <span class="fu">paste0</span>( part1, part2, part3, <span class="at">collapse=</span><span class="st">&#39;&#39;</span> ) )</span>
<span id="cb11-14"><a href="#cb11-14" tabindex="-1"></a>    }</span></code></pre></div>
</div>
<p><br><br></p>
</div>
<div id="colorimetry-zonohedra" class="section level1">
<h1>Colorimetry Zonohedra</h1>
<p>In colorimetry, an object color solid is a zonohedron.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="co"># colorimetry.genlist[[1]] is a 3x81 matrix with the CIE 1931 CMFs at 5nm interval</span></span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>zono5 <span class="ot">=</span> <span class="fu">zonohedron</span>( colorimetry.genlist[[<span class="dv">1</span>]] )</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a><span class="fu">plot</span>( zono5, <span class="at">type=</span><span class="st">&#39;f&#39;</span> )</span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>webm_file <span class="ot">=</span> <span class="fu">spinit</span>( zono5, <span class="dv">2</span>, <span class="at">vpsize=</span><span class="fu">c</span>(<span class="dv">480</span>,<span class="dv">480</span>) )</span></code></pre></div>
<div style="text-align: center">
<video role="img" controls loop autoplay muted src="data:video/webm;base64,
GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAOphEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHWTbuMU6uEElTD
Z1OsggETTbuMU6uEHFO7a1OsgupL7AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmsCrXsYMPQkBNgIxMYXZmNjEuNy4xMDBXQYxMYXZmNjEuNy4xMDBEiYhAv0AAAAAAABZUrmu4rgEA
AAAAAAAv14EBc8WIc7bNvB0VgvOcgQAitZyDdW5kiIEAhoVWX1ZQOYOBAeCIsIIB4LqCAeASVMNn13Nzn2PAgGfImUWjh0VOQ09ERVJEh4xMYXZmNjEuNy4x
MDBzc7JjwItjxYhzts28HRWC82fIoUWjiERVUkFUSU9ORIeTMDA6MDA6MDguMDAwMDAwMDAwAB9DtnUgoBvngQCjTveBAACAgkmDQgAd8B32GDgkHBhKEALw
f9X5vo/ndm9wfE/f+TpHBPSam8J6bwnxfyck/J8TtVixcd618P13wOnOZ1a60cpWTbuvNwPgF7QkWH5nRHwF145/TP1qvi8mlio316rn+n0ADe/zSki3xixv
pv0AAAAACHtoJ3yFFSWtmG0knKVb9p4WFH/PHO+YbBHw8XKbKnBl1hXb2kaioizXYCbCyYf2bep/lq1UJaltMV4rmtLxSXAr4Xq6rf9vMKCSgT+pZXLYNP//
u/NyMw+EjsioRqd0CW2TgSuDj2yuIxnLtWMeNDbQ86/HqxMzzxRlUO6PQ3GYjOcbkYjQofsV5YHc+r0mlpI85MbTQBTneJHDqGVr/CUR8DHG6SMoNgm5gPM5
yrhVNE7B2DN3OQEL3fPMGOjlDDzBtInjI9vyvHQ0HngWv1qsHNIV8Z244z3g2mkGxCtNMEVTYN4b4hcn5pTxdZKrLfQmxp5roPGs+/MYM/AqfitEr+ADMnQQ
5zXJR8s+LlQrRgHF4y9LpIZWCOsSShQzjvkArocLqwVAHeRkL7IoP8L5fezZcgcr51UHuH/8EZiVMnwLi7byrsl3iweVU7t9823UKGrWIX19xDCSonTc56Hk
0IU8egoztrgiVTwsnmMcDSi9PrPUC1NTZZloGFUXsfgTgGclcYybG8amG1FAuhSLgN/RZyR9ZRew7wLMGG6fEP/OD/1OBowlpS2wim/HvMMar/VqX1xotSXF
zHLHAAlaDDzkJwA4zcYUgVcecg1ljSnPTP128aAEN7mq8lVKTAx4O4Q+jGhXKbbP/GYjpfhNaekvYs8TJV2V2wJKkFkjR3+sj4f1n+9zVmT7TWUFZTVfVkW1
o1+PumL0uQO1PdoyBJMqmgoSHW9qf7yFqBEm2grpSmzLVBZzgFTCzSUido1s1Mz+Bnl4fkUoIc95hE/Ydb1TbTdtZmQb5lNROqpgnML1LtaNuLUQd3M3oLJV
7ZtrtOljjGlH2kr7BUX3fl6YDBm2gQeLHTzqHi1+BKnoAI7v00OLk+oPiGCqrPdVNgavvtQTRq/pWDREG6zz8Vs43ajhWc0FTAGb6XYXjppPorjgswu7DTWS
GDitTzwqOPFo5qrqtjy7C691TZZy4CHqKeo9oGneIEOzRV9LIHs54TWtJULeYl+s2OoEbqEcNzKonJVooTZdgtE8mtqM8vwiPPfBwOMMnk8NNd4gtqbMFfOP
IlROu1qOtmgWNlDTnIFiOszDliqYta7Fy34bBdKrDNDCF4BoAzSSkOnhkx+exbK+1qIqRZAU780iJopI9tQvtKMIWkSmVfo8UY9mQB3gmQ1wlFvltQrOy81F
HwBaQlM9kINVsCMYFxcXkG1/HMCYk7ikeUtxAYgn4AQyasGWUibLEdquMSHhn+pBy41jo9ESKoP2H3sRRVeJtMotj17j9KER/rGI77nbuRdJxskWXznElTOC
eQVGrxaVG/mPUF6KXa/s83vr+GxdEGIvCnfcdSJTZRzls9w08KOG0W33zkufU9A8kaGLZOzp57COLLaBfurIrSk0y5tVhndJNfBb+o25KV6zrTHrxVDqqfgA
qikC9WXcx2EOrNhfrV5j8XtYviSmgRbF69gguqDN8t9Yi8HHiEDcMeyCXwvP1VMZyh2DIcD5XEjjpe9ZIfmv4VNw3JCrCQbkxEbV7OIfcnHOzEu6xzNFeeMi
ozHFJvsnY1KG3pVTmoLyf84WIes+cEMive+u+Px98mpgwtUXupMQe0xmrfHwzUuHtAXngYgWvLtPiGUkZHSQU7CG+S6j5CLXmKuu/8P9IcDwjLbMiyrXNys4
GAG070Cc9DSVhHxv5yCdQ5FRdUsgsQ4XNsHYlG/5j0K3xNJubvNQL8GW0pxC8SiyOt3EljVUfCujrZcrd1QgO8zncHi+OE2yAIT73JcO1JLdUFK8f0CL/i3D
Pa30OlF4kIfBrOoh4WHCqOMNk4uvPB5OirSK2XgDZzaGpQQQbFiraEUj5cNQFCO3QUmpS0ybrAn6tkcSLEmGGUggjFzem+5UU08IBpr2iT8jBOYwMHrwGDQj
KkQ+mcL0Xyj7kztx0p8EwEMb0an7s41CwwPXJPE+gawaMCZPMkU/RUxVAVHUJ6+4ZMUWzFI+Ey8R5osb7p0aLpobT+njUzXaJkcdWNdrKUCgm7ft04a4HUDR
QOVSoF79cAYdcsdJHBBS7YuBTfuInKcnyuk+GHEN5WOx8d+S/9Ta5DROnZ0yao6P8EVtGTm5tc9dVCwtLASXpVylDybQ9h/CnAuWUMW0V6Xy0huSEB5HsimD
9tt/K6Of6PAyATEcqwG0kutVwHnC6s9z8MrxvDGScS8hRXrRyNfAahkNu9/cDq+9gDuUrlHAXtJTxVm2HCX3QSOBm6MApNdq4Vqste2KNI/OXJRaCmYwF7F8
jpN1kqb1tcwUK6DTNMjLCAi0xzmUW1ndPzyO3Ycyq9LcFnur9GU/mv17fhKFP20kTWq4MzdUM0+W3xOTSNnZsQAW39WAKuqPtesOR3J85UkleyfpRSjw/8zG
qAGOg9vCrLtbBBNvzZZMRck86vGERYB0BwDDulXXwyPXl5D5XE2GlZiBLbkUv19zNTqJtKKPMui5bC94ZXQByDj7C1iz4J+QV6c9+QOR6dNgCoonOQwjX9mb
6YSXPIkpNWcfuNqzCe9E+7Du26XoqAj9NIczbytiVr/Wvl7tC1aInPftgQnThGahuPw/OOQMuHIep1bTM3tdVDG+fqKGFe+pDDt8fuyz71j89LG98MyhqpIK
ALcszqZQHq1bh1I4jj9L42DsX/z7nK5iUpvnIM5SLeCFxjVphY31p+4RZ39hx9yfQsu5IA+42iMKpsv9XtvX0GH73G8hc3BSSr+L3DEnIXj2ygAOB/dUWIU/
VyaY8r9s4zzeNzQ9VZnbFw8y57XizuF8S8e3ZCpG6m5bjaBwkjzJzRrm/3WDjGOIBpsc2/ZuVyQlQ4zn6ugvZocNCYIVfhpCZLXMn4agA/tnltEtXlt1TkuM
nd1q7ErPRq8dx13NoOalu/qwAGgnfIUVJbUYx0VbQtHcEY1lKZiOyqQrP/elwFm+iUpUPGczQ8DhxKZg5XnR5fEuyvTJfV7lBYV+ecGZjlhUFP5xwZzUief9
ZhGOiXui8mBdRs9VfoHgiGMlGakdSAw6YptvBgJBnbAw15524j/yaF4/72l7Yi1qJ1tJqBbxBR4vVNEJsNalbxacFDg59kYM0it5WsZ4vtPBWV1zyprYnejf
7IeiNZy7eBEXC5/E103UcTO7sPpLTSuvQc5EowgN0ZsWKbfZE7EcP2iw3Ivzu9f9a9yhWrprDFFfMuXfEdGbQtCly9a71bl2X0qH/X3W+JIpRGwmiefDF1OQ
3PUxsPLxV9tYb/YJd39gU8m2UjUdC6J6abcnWc7K898o/HU542SiJn53pzrNsXsjFZ1MQJpmAsUpBdORMpKiohELWch1qfAbIUipBDmyEEwu8wNGTNarRaSd
cJUuN2z1x5NA8q2ZsGXRZqSJUsc1m9eEFtrCBVGpXR81HDCdoM/2X/DAl/j5kCdm5MFpYHoLO4oPc2rWzZxwsCFwCEgXIuvi1NYdeRP4MW+2RTre+5/A3hGI
z+P5nyBZ72EN0QQ1vqUSKhJm1XFOqXOM7MoSElTpmtWzmDZRUbRtN8Ynou20xjs1TMq3gV8EMJUo7R2noBwDV3ECbixKlMf/eHsyLZOraq8S+iE/+DjOPeRH
b53ctiR8qm6ZAhydrf9g6jZegGz+OTKiZwVBkxRMb25h9Ls86yBJ7YiooZbHyIyDNA31P/hQVEbLDDAQ47uxtdu5t48YriSylXw6fvEX9bi801arAxSiJM7b
+BxU16GQne6fwjgl5LCEuC3ArJzdyVnqocMQuDR2Pvn3YNkBW9qC+PIh2Xq20tQXj6XllY0P3m/3u+Ck2OsqNCcAZMF4LEFn/j9gYRGYUc5ZmfxN2sZNHTAA
3AyNmCazcHzulwA1jI6/bBGl/I3CHrXUD1D5bWoQB8/zPPz5DuS0McmUDCHv+Medk+9bEZl6bV4Sz76mJxDTFbXqd9VBOPE8Ftl1NLVOZXhv2kw/glPkblW1
Mu+IxJLzN2cuPzPkBUbQWAn3l0Ib0+7hKQed0ZYnhjlAzOCLgh/gNbEOYKf6Sb9oY9C8uIDYqMBLHvrC4sa/i3SspW6YPUv7uRl/5JcD2br8aZ6aupqfbhJR
x9T+t5J0PhFMQARyd0w1QDpk4EyBQDOpfwneghJDMVBAUuiz4UxiyJeraMlApJiHG4kSy2AHaiQ37roQEsN8hsZnBALjCsOw/Aw8pRMaEqXbsBEIUjG4WLX3
XotfNTgCL2Fo8dM+7Bf1EJqcrByXJjSDNdj0XM1PRc9sZ2ZTMG3qr+zDqiSJ0TJPYnsF9kuwYwZxJAYn0jwnfnEx4mE/d0BnH6fzqGWKR3+K1RfPiWCM8aXW
EvkPil/fjLZQoIU5GI1XVcEoWupsr9iC0iuoXLyMAqeXfyR6goOyHe9opb1dcwbJafMozggOTdUUkCCAqLCBkOmANRElw3GqIb1v0IHztEQMuoSFHmp1D2h7
4UuKRxZIhBM2UW8p8v1gLwImdQoht04iDusfWNwGLrpzfDnaEtnxkxaVbn8ZPHfvNLlxyk03446p4CxmUtaGOxMxnUX/qY/4BXuBDrDHtYFHeqoaCKUnADxf
OVe0YS016WNfZasHairIa9pcFcc9TFjvRAr0jpXt8kMhyz/lsjOjqhlFhkJaYW2PTSbwaH9Pq8Aq8tGKPMhHkAhrCBvlmE44z1A6cXE7N53eiQmMULocXyZu
9gfsL5tMSX/H8mFj8208wFeUuty0aUZ8FJecR4ex/k9AFtJMW2cRkSdeMXD4setVMK3NXuE6kqNi6nvfwiaOILquLrIZTKIw1+hYpsECwCuLri6dNYk3goXs
nc4ZCUZhVdDyvbcPJ/mXvQWZIxKbcuV95Hqo680GT17gaY5q8OwDTgWB6VB2fAD8XHH+IPqBQvhSG8CzQ+6228H/AwJPAGVzKGfwD8zEeAW8xEkae4Sy6iyq
WOxOPA+IOFDhuhl5/j5NZHworQi7Yr03e/SPHwCjQ0KBAMgAhgBAkvIxQAQAUnMEX/joMHXiq9AGaBg9+UE8AeCu6xHFvUMmC1lf/2LKVN6OoleyvbQAAAAC
FFy/UlzcdFlJAYG8+GkXa1DrKxJZJz3yu1WKtytpYotP6Sn0NkEhliwhP0OFupR+9Eu51lEohkl1cfQDsoiCKcMDMqRdVQUciPvCw8b6B+/OFsvKi9z5hvVX
Iwi/6UjszFKvCJDxfleNIWbsNQFqTnpSSp5qjoVSZxdg9Y06rxlebsWWsjDzs0rW1nVV1Ll1pO1+YD9psckPMF11pvaBpGuu9aQA2JFQpFKa1m6RWsGvpqbh
/fsec/moiKBmiw8Fsb5ZdDGWVsAO9mjzL+gl4cai8GWvZmDOAhxJIFpggqs1jFrjknFsTkN5lc0pq2GytpEFqgYQFQdGVuSKOJHN0prUynKcrTtHNUz/o039
tSi2jivDU7sWWhxGCgljQMx8w1Ty/2vb7k0YzTbkFBk/YDhsAlZWwhL5dN4GdgZh1aTZYxDBYDVtGu8eLmPhVOhhIfUiTuY6aQWDmAORJSDj2a/QqfZ6wQZl
ly9NbmBvU+Wym9z/EAr131Gb5Qq5XC590Xi89XNJdYzTdriG+j9VyQ6GjfreL7IppLXLzPOlCgJfaFVvh7njphSCxQuHXFPdgIZTUa21VlAsPflWSCjNacb2
Q8Wz9ShWLT8ib7/XsZVlz/Zncv+Mbn9VDbKWFQSMJQdzLtPJNTPx3O0Mt7rJ/F/J9sI17Ob/x6oW7i0M20pQzd6xWHbIeajKI9DbUqMCM4wsEXhcpWvIlx5X
bUxjyqWLXFVY8Q9ulYKnqotALOSaYJnGeDbpsF1ZjalmsU8VqkgSewzL+iCLiFKhZuqKICK9d46EZUgS6z/5jPSxNZ8T50nB/L1R+SzF81NY6rPI4x+PVHk1
VCMRcLSymSnBZ8UXLJpMJNN+8+xnYf1wTAV4AmDz133Y3bJjFB5l7k20+92RgadxptlMwAozi52422Fwegd9Nuy7VRAM9o4NyOfOeEhPBXtVm8IMckFPpr8u
ce9OrXph+ESrgO7QyckRaLn3/xvi/zd/GMO+gY7QmQncPDcZr2ewsU0Sg1atwUXdT60hK6i3XpyjRA2BAZAAhgBAkvJRO4QAOHdnoN7/QfmFKa58OcyxhhiW
FBFMAWshsidxcgAAAAKqXKCYCMkD45jb5S2Jez+aKedACWOas73ONKBDG+SktrNVh78fTn7PZPDHm5fC9qahvi9eI6pCP3C8pBlNqcPOBUvmTs+fZI60PgC+
JTSXnHMvdtmyg4iq7Lo/HHDfiw9nnq8nPT2EuXyXfBT00NpNPtCGx+O+hzazgphLArwkQG+KCuRIOlcJvcGr7opBo7KGpBMs+P3fNyPbVfKF3XUgoMOCijr4
QmOq+7BstSidkL2ILs6uXBJgIVeptoOx/VDHQeZPOfcawI5+mRZY3GV6keGI7RgZkpZZZXdQOTO7nFFgLSekG7zB6AGVXkzkYFqzfRKnF9+ZgdHuUWB4JDuU
plOrrzEPrGYseilw1TmSDmPmHwhvCtBPCp6a5SC8nfYyud4/yAHTDxPWVTxdsy1AoxTmFX/uBmIuJgllJutv4UBeaCuGXqkZsyNtnFMaXgv7qDAWocXERODx
WAHcAGeVJMhu81B0dbYXTB6jb2kGrPalmfp4Rnvi1e0Nrj0ibGBrxJvS4mqSWvzIStNucK0YA2onmhpBdNsBS7xHw6Z85mvgywQA/qAXOWg49sdTo5Qop8Ku
jiiDqeNYKWX6dle3ocATWH/lD4d3FAbzwDSAlS7cb5DWYwfk1YD0JOY5u/suRIlTi22QKVLR5zRzyWzN8W2FygPNgCo1IxHzC2ZouWj5VmX9TeSBC9pkcygA
GAhMfddEcphkp1LwZy45ETqv38JCwqNQzRrsJDi08v78TSM38dX6XiWiFk+EUpMfxBV5ptXqcaS8d/kEjwiTcE499wdrrcr7NJSt6uE5WLY8vM3dVcqGOavp
ZVhpi8WtdmeEZFc/857wO3pf0Rq8a1LA85W7FNIcGK/eOzGEu4zVtv6TJ54c3go1/1nHD9k53lbY/Og2d2SL2LSwMFyKURZm5yS9pyTxtocVEme7QF3A2ssq
cU08NCFyhtNApjd11/JKJS6u7FOUtgSKYn/Q6QQDhp+A+ovjCj3KqJPBGFpZOJDnDmcEG6t/kyMSmkGc9mo9H5TpRFrNebt0qDRd9skEApvNm5X8ex9TGfCD
fw9Um6Tpwr2UlQWwKtouYf6zYJy4SEgG3qaSptvFuoMlXQT+GRGJEdJucdviHj+fuPjxLC0+kdPd9u8mffHZluEnXm9ooQJ8Z2vzaKDAFMzblMQO4nE3aoHH
EBfF+hoWfrE6SHSE6GPfCR8o3NIPD3P1H/zVJ7k3wm887v2v6p5VD0TUIMA8KSFvZxJUC6gkFCWRU0VDfyW7BBftgMCAdHtVjcTB5F2BnKxcq276rxz8XSIY
/nu44+k31ESBZlzqDNqlsKNDRYECWACGAECSnIBQAQAGAHHTsATreXDWF6CAAAAAAk9iytaBLF8WMIAFkyLY9cQfU0+WQIPjB8IPmnQWpZBR149OpfKG3f5m
/pyxiLwyPnOAwfmTQB/mTuHjSpcusViPcCp4LLqmtgM8OtStqFW8FbdDNWoShLxC3iRd4IRDAHZ1H7n5Yy8BBgvUuq8HmFkKuyuUVnkBQMEkt1W8yoSD65pA
QOZHVADlvdcXUtohwVCEOPqwpfAmnZ97RGB+ozTRRVJtn/E3M+J4sBAG7rjO84UWrtavhmbc8AOr/En1wgDm4dEwNfQkj5HvAE5g0ZPSa1yXxuU/0SNZBzde
qcB9yT+WQKoU5ZSxxFyFxkHv0kCbjxBdXlGqD0JskSlp8T4fX5hWwM8BBUrvBstzGUQCd51vzNFn8Y9iDTg/31NM9U7xyClofthMI/n7KmGaxnvlrdPdzVG0
w3KWeQRJyBjTmLX9BAKML39NAvtUAskWBXWhXt97EPqRs33wBxq/zBVSSdHkCl4MNQ3GfbJ5wrsEqlPBQJHuNLnXqPrmPN+8fUAKWy5scvIsLYUf46O0OOiG
LuI40uhMMb5fJDmvI79K9184ICLtySA1IFT5wbRn70xZY7ubTHu8zQ/vGjqHvdkGTo7b/g8KwwLVXrAkEWdBFuL22eWcE0J9JShoxF7sIYNyYkFtDb4jUDQU
st/YbKs+6hcnPlp0d6bvJ4lDiUfqlURPt1fxUZqTSqS6GNGXU/QVSVFOfNTT1DfQIOMnRO8ISh5Z0I+StW0Jivbv+W6YcWs+5Pnv+DzSDWrMln4zHX7E4ks9
Lu98xRwOymBdHABimflqiJTv51UYjEI7F4d8+wiFB+N/hsAQVm13hj+QHDWf/KWdR7x+oNRdbSQQEWNszLgGGP65sATjZadsiXNFk4Ynh8GRgXFBWVs8tV4/
9SquuCwTevz9MkR+JozCJRe9GYGipeT6JApaHnhsx1/uUswSZYRb0RmN8M1HnsrRGNl0QaLnvpWGHY7NrwcCqk2IHB+DjSsa/PzkoP82YdVICm78oe0+1cpQ
kcgJBGZQ1yuS/5kHaXjTYxbEKsjIj3S2OvHwfYhWZgAeKBsvgbLjL07jBYSGIKNE8YEDIACGAECSnHRNQQANAH+MevY1DSQ6TvQYTDo6CeDACVXEJpZ9TgAA
AAADQWLItLQIa7jChNpLY+PeD6egGDx8e1YNlW5upRQDbu/r2FDAO2ulgUBFbhI43XbMODYKOpHvRDssn6zbH14FifkT0lp7wmdNjbhUkQninN3CjMyTWbUn
d9WzEuCEOHbDfIQY33kRRVk+bsBpgtH+ADoSyCr5CyO0qFccZBk8ZLH965ohgbabNrF3SJY18hrM0sn+Ya45gQdh2YNESaUwdNyplpSC8kFUiUkXizaOzZ9h
XU3siUkzKNjCXv/0tBy8UPoyNzdby5qRwwVvqDFUIZOI1V2CrBzS75hijZxBcrZy/dKkbKx+OAlKGFt5bQZ2z2yI/hugMFjCBU7E2HwTk9wzRM8gQ9zEreCU
5mM4f7e6Q8+bXRnC7PB0XUWOR9WegNnEr7rzJUNNqVhQxpRuf6fcSC67vuFvynUCact4slRURVz4TGAoaJuRSrCJe68M7fdRffAjhWDTiiqb19/TsXTcsHr3
GR/mc1Ifw3iP6RwUehNVHUY4d5g4eVIZFc73D2YbfTgDWPG3C8UT/zAaeMDOAq8r3OlCNgTPZE22gVaSfglPAOetA1ayRgwCVIfHIedUdmfJk9dVsgVZOlWl
cki75BDXvSICNp5cTQk3nozJQ/h/40FfiAD1pH4QWNuewogUfuiuRac4hgpdBOEFXQ17UZ11lb8zYv7JlRam/pi2JTq83MjRj8AYtVWJeRAQ8LFSVe1Xruwl
zvcBwB8RPlJPuIYK5r0D0L8xg/IDErSJDjbIvqVl1K80p4EBJPh8re6pFTUpt1/+VSrCSyBr/Kq2OpzDI11gu48wo824dboEYiSheINU7L8YrIQL+awFdzyk
mgjj9JQrlEYM9r5SlJPcJILx3hLzlhOKO6a3Pql9bYej0/xLUn4zVlMutCUwfKwNcuC1E+9RhduDys3Bc3YmbeG9y0oc1jexgHiYG1Vrzm8eKje+kvAS7vMO
TK/H51qt/eRYS8Iw5zr027e0KO2r+tdzpe/x+tNFTViYdBwgSVCXW09bEKDxPqjM/UoMOWHGcJaFBEaDSiZyvHPMWcqf4CyBAAc4FAy5ssdq5idWIsk+3MG3
txvg0adx9OwH7gmkwHZUBeZp1Pt2E5JPFBtmYpcHV+7gLitK5AzG4VFzuY4/cWwKVAQkl76pNZ2GdPMk+PNgV6X7MjRto2Rw1B2ok8izUhDP2oZDR4AhJYoi
OsF9w1JWcoVlKWSR1UD1cEgcJQ2BTdvihLbptOiM2LzMcLbqzJ3jK9pL2gqogIyVV+GfIkq19PeQsbsZWPZ6PDKZYeLZnyHPNHLHH/k/BPStmgx3Ybopxvcy
4Uu2rxhKGfVdz9SFzzzzcSQREJtM6h9qOL0sY/+5HexJz/0Vh0Z1yErqlQv6a+9f7wbIYlrJLNAIO4lXx5TfKhqdZDRck8+9o1tDVZmBfMqXdDiv7wTXXT3s
UeYHL5PlM57hwdVzm+Ltl355PXT6ct4qrB4CXFxweGmh6I238OEVi3Xe+u4y6hrbx4DetSxfYfI0tCuwTdl9MrTFKNjPptcehY3eq7cPri3nK+Z9N2mHnqF9
5TFQqpmxeIfgAqudBbVAS46PZTN8tDKZ6rftDGcm56Wmxf2LB+Frsbhnua7wM5KMgoejUvUQo0L/gQPoAIYAQJLyUUAEAAxwIZ/DQAAAAAHSXJtQdb0XjRKQ
M/Rlo2JyumzsH2arVEx5ViVQsqiaZr98oSTy4sQKmrMnBBmnpAa1JzbjiaZ/cc9WWxN9CVbzHjTmLvWzqjsVwc6o+jxCkCQ3elLwMqqzpC0WipFv6OobetRt
F05luHn0AFNbqjUVGv2LV4qajpPOAkoAJUW5Q0YXufqsiV/mBPSsSHROs9EhJzR14epwloJ4UQIySK4BIugxSwo0K2Cd37ZUSoxYnIN3S5j0/UXuWf/iuBoj
QFX4N34LkAdCNXAnDvKl4KGWi/l5n7O2nekJUoICXcyYug3IoHDVwudeW94M5Pzscb2ImYEhPC3BH/E1r2YqFE+8KHj0d2M3Ogxz1NI6JEDy9tznYrOX57lq
/c7zBi/iHi3PVn1rWJQU8KOUwmx32t6eA3mM0dPY/ytjRrfA8p5kWcej+pFYBZLBfQvl3IgvK5WxLhCxKnVjTKC0VEs/+/w21RSxtuFo1AF9/nYWm6ubWAvo
ao00nsgZp2cqW9GXCIXnR3j29QYPu+LMFqCoaS3IKmL4r40IzXJx9/2xSvDYoafcbSSj/3T/6kojjXKIQ5ErGO3Lqvvdy/ijfwYlkv7GIjqyKaKtTMyxlwxE
vq5qdeyoMFyITfHLxSFDs4Bi9qMPv3Ld7cyp+fd+hU/NaD9/g+9zXICOTplxxgCA7t3ikf5IHv3cyz+lrg0wTanBUCjWv3Sefuz7pcca9kAzWIGiFVRJXAbs
p8hgcN/XNcoGFgaYs9YrftujEmxDeo6Vkbo87jSoovvvYLiSRzHt4nW1R+5j59jh3NFqi+SEFuIiXXQps2hwtFBAgk39clzYPgMUZKjQ7vBJr5eFYDKD1grT
s6nHa+hesoz6LzLbjYQxl1KzSC1BApN5ow0SKbXEIJJu+jnzsnRqkJOb41Eq9OWfpYmVMSBMimZOiTcFXMEhBO7TK6vNnr2fxv/ba/4FP/ba/L4/GdGBohjs
YVdN0FnnoTLle7rZwACjRDyBBLAAhgBAkpyATuEABwB2hj75fx/VgaTr21VUAAAAAkRgSvciLQIsxRfTGfhJj8B+DMzLg3L+IKXE4EeSzd/NBtJDMWtDzXxs
Nw6kqhA4sK8VANXQldWhuS5RFB1rvTmxEGtBuv0WQZIml2mhYpDhkoSPXXNBURHRRSfHzWNjDKhcqgSuRnTg+n91GcDeWyHNtuD7ifE0EN4ATquYCHNBZMvo
41utSF9RhqU+mU5sQOX/YLce3jaWVXINIo3/7HAJJRG3RJYaulMX5ePCg/KKEEsfyCGN/soUS7x05giLGy4KN/p8c/dvlajK57MdN/FIFYX0Gmm8Ga7X5J/F
DRDAhJmSyGZqiWxGjpg+eOndEgTe9ISpkAizHE5PJ14Kzs9BigEjxLA4xsIRnOBZ+pZfSsauHhWK74o4ISzxHLAeM2tr4i1gUMyduPS8LVaGBOGUp3evLcBb
Uv40+p/xs6eA7QsrCgRFrHreLPuMy8nbqlN73d4X77ltaZIPBBdSR++pIcETmKME48Jx4Ul+L/RJweFDCBfzEaAu7v79aPXPhJ1idnR9rStn7FKDoykFiNrB
MYlTAEvWr0Twkmf+2j1mRFcqAO2I83wLXZAaBB6ItE5rIfhwvxEEM4T0ef4vXjK5iPl+YgxUgacNJ4mghtePJYd6nkeFNRlE+gXQhugopygb0UyEe45lctw8
lgAn9254hPOcCoWzadJOGYcQ9wtTeDdDiu40PSgL3MAiKZk+UqkwjD3K4wM6vF1J2OuRepnqjf9ulYfgF79gUgeCWWl0uE5n56qbM9GGlubghgXcjp/v3vQA
YCTZlc/80+39QcrzX4ChOZSgwYChM6Z/7H79wbkvfDXMJppq5FR4VYJXRknI7f8BSEBDJLN2hUGLU7EjAqGLqyrntdIhw/oFCNl327ykQYNlueANd80JCKxj
yH85PeK5SfXOId+E6pB3LlECaFpsQAUHBeNM3hkB29ifrDw5nvOo3CKpJ0dz+enGd+i5yxLD22VD2ctB1Yr7hJoPPH0oCKEx7NTd0N3arqKlFDRgggWloQqS
UkJKWV9vqonBViuMi7KM3g0XGZyDCIAmnKYo6/Xir1O6W/hUjBnldd3j+opTGAiV7N2wi2evcMpGmQIlBVAUkTMpoE+DN95HWdzjGhyNEppimDAQRKQGxQjv
P77hiZ707sxakQPaSKGli0NDHnk1uT+McrwAvGblniTI1O4sQwslonx2hOiu69TyJX9ZJ9izaTSPk4i6JHC1Coete6GCT9J8TCTs9dgMI0wcaZ/Av6Xb5Qrl
bwDjAM2mUt9WjiIiwd8S6y9sspBpyd4eYmLempaM3qxYjr7im5jGKJJ7rA0Wj9Hw0j+FS5o3/XMPejtaw6IAN881V9WUbjKmqVan7ZWaxULVsB4fVNno3Saw
nAka1dDsdtHZyguWf1vx9d38RWQco0MJgQV4AIYAQJLyMUAEAApwyQAAAAAAAT9ZjmEBkvGSIVJDAiVmo6M4YpGBcEf4CdOayN+9GYGyexzQcmHs3GI+WFVE
S+Y9fcpB6eVtSFnW4UxsI/wTzRfj3U/EojJr1wvip2YelNJf7eqbczsGJSnsYoR+3zPJYqJZ3EDtnqChVd2qenoOziy4y95IGVJ6+4ZDEouSput1CyBoOrs0
IYzq2cnN3vI8BEzdbT1a5fRSKlr6wDftZ1I/6pBpEnGDvIA6djvMW5RWATV1954zjd8eTU6YQ7wf5y5m2Wlg2zuB7Rg/TBBfTS+G+lUjrEdN4K+u2xGSwkUy
0BdgAgzyNVf9oJnfojob4903mgdON6Ya1slWdaTLM/eL1GOU3+EIa+m6vPt482bdiRgp1pmq22OQHBSrgjAG7rLfj+/nN0YyyaWM5L8KTu5znbQm2izXiIbF
0wR/DxwAWY/fokEhqYDVezkLQYCRgyAQ+W5fH1yVcNo/a64rv65eFXuuD75Kiyywm9cm/7Iwe9KsSLza//FaYagWB3G32+OgWVBQ7jU3v8YZblIzTm4ayHD+
NAEE8vFh6TfpO4WMKG39uFFCjTcJMJJNYwYWCzbl6uDCzRRblmAY77/JYZ1PSc9OiQhcC6t8D5mLspcVVmBz2DHOvIvUIRAEk1zFVEL5AVNvUA0Vz31DIp1d
EX1m2B/ghFoOVwhSRgGQl1nUADw4zI9J9uEXZSbcxZaghkybBqkZMHazRaJ7r6zkpbGyvY8rsu6o3g9FvOz/eNF2uwerJpEHI60XOylARceVQV/MkLQS/BDx
MJSWbFbQKh+6d9LV5VtdXfFwxYcu/9whrXd4EnDiUFHMAwV8ObebydgWPtVcBD0ciLxV79FurqUj2Z7lDK/6TrK+ge/P+gbQc+JyhzQTyya/axihRudNgexb
pk5P/4VBBtVmPMayv6AquycyBDYJVJ/sI8TGm7wohRsD6rZMKcqwV2Xh49UQnIJNsRgcb3AVuTXSajTyOvV4NrOHo2p6G2hsocwZKFjUi3Ywo0h0gQZAAIYA
QJLxcSiEAF53duVoN/P8fV7pRhtdMDQvQimk8sEjQ4AToSgi73wM0cc1GVv7DMOaBeqpL+tgAAAAA5xZl+cSwNsJBX5OAhMr9Ftv+s9Vz5n5OkxKx4MMxchu
0SOmwZmYPJU0VD6V/Fy4RmN+8ZBXOGGZ06HamIjkeE9MC2yBnL93ZBdJrOrGqQxuaI4kTu+8URC/OV84K28IwnAmQdVmv5cTgwTzPwgzaNJyzdwqVNNbVia3
5Kbn+khm3aWZaQntYmjqIVfXHdfMVpuXurJ2AJrVqBWS40swYGMFe19EwSVlIkZQerS0JgIGKWYI0TnQm+dgpl1SXAfyh+3vur+WlJFcvS17THQCGHXMSj0N
MMfEyb6MIGoHCtIelz8WBJXOHKPGXAunMIwSE07yavQgLXrcC4CJd3mqNWSvUw3Mjdi7rIW+R9hFPzSkjzMAMzA+nmQ5cCh6w4siqZxUMrIKXBhYCOcov12M
DhWGQR+6D1B4OIJiL2CzPFUW1CjdnIB3465FAVd6FjR2dwMf3MS/+pePrII9zBRfqVUR06s7+/SGZIm+Up8SDnzeBtds5ND0IXkWK06jj823LCFmecNemN85
t+Daw1wnm5ZjiBGXJEcIOZ6bzJ7xowDlpCrFIneN6x8+N3lyRBzWKnpGaXX1mWkpG0HDx4xsgjrhtiUlT9MJCDEl7acGZniNb6jZmRdWMnxw7Af3ThzzY5Sk
XBC7q+Ljx0taxFCO703PFX1zAnBRg8clIbZxDKVgvALR0azlCek1e3OKiPGqMuWqcAq4bhAiyhIWzhyA2TNbl32UBLdVIkDY8vQhnH/2zz8R861DCJJn/ogo
r9z5+BhxRSdGRYw3FuORepGrvC8vxgq69ijaG1CrvPAbGKfw/M2fWvxZjyY2jeHrpDpiB8XVgBPHKWShtmUINgmDch+ca5u+sXcKZOjWmK9zSQLjUsYKCcBg
0q1V6JZDVXM9YVzqOxmGpkk0lBlqowdwtxnd3b79b90zGhYx7hE8Kjf0agx3o4gwayOgnlmberKfm8A5q2REaEmqX4DISDOsgeePJBLU1sSKgJAhOUJgGkJc
WHv2yhkOXxHzZTREuh74eLUgP7cVS2MoxTCayQWRrdp92xKMxiIjp6IIevc8hIj+yPkNlQzNtCHJaPQ0/itl0i8YWOEgoSm/FATBJGZ/iyRYIbB6AapnJiM4
d2b681gKaQ0QhSCDtBoQNcNwjO6zlVmMb3tLVi+rNGloI9tsHZt44yNKZ+a4VD6oHJ/ERcmlgs2Fd3Ki2CziWr47dcbSgoyrOLYDZbXFqrEjd/BZj9t6kA2W
FbjRhC5ngbhCABU4gVp3uqUk3Ux5aXDoqi/Jd9Q23t+uoe15QP/0X+csDHiAHZCuWF9ndKHWEQBwkW1k8f+2yMhqOKrkEV2E1m2AGPc0j+2fYzmSeL71TFFX
NZWLANWB+8NOSXnEHnhbeSk4RvIpSbo3l3FRDnUmPGNT/YFsL6KdDKl71AakCm24rh9UAJQuIsjKwrBiCE4rVrQoDEJbfB+OkXIsQ3Hhl16KFSAYvQe9Yacq
zUMDQbwga74Se40kC5AsGlG0IS9iVMm4XQOlvc3GepEzfa1y4E9mYdbNlqecya2mHIZrD/C73LweB7i9C7EJzCt9g7pZuwwGCOHG//nAYlYR6X3T5FWfHdUI
D308TQhjThQSTdoc5HMRzXNrlSa3AOCYHdQnpHTEcIlMHTjOLx9gxnjyyIU1JcWDf9fLrU9iEEpCJZHhGjkuAdEp1bSy61CDt/hGcs71mGzT+R5SBSiASlz6
2pchjS2+Ult8xGTk4Wb6ywQGr9RDQRlYFf3dD1W5x9glC5q8le9MUYsfIaZYONj7XfLdVeZXbQPXzLBgHGHSU7k3niNpiDc5grvCFn8wztAQB5KxpgSYRcBV
TmR2qPgjcq0mWCa3/fAq2sYatshe7mXABp50HTYYwyLmJDCnW1ZSmACOkI6IIDVLBK4RWYYBCKE3qbZsdSrc+MAbqwUUjejxanAIfIbU2ekr2KJftK4pULbm
XFUbPn8k9x/2pC2UFIJ7+dnai+WZOnwLZCyuV4GFvFbjElb/cUbWRLjEO2DcXMcBVJ2aD2N52To/6s2JeTMAQwFZU6OJWZQCRFlehkmtFLMwn7YNeL62qoF3
sBW20LX1i19pHVEdhyspqhvJAkCwACr/FYxN9tHnWMwh2Hah7vr8cYuQsFto7O6jECyFZj6QgJ7ldHTdRKdLkvzyKjcQQAbvoNHgn5RJ2Aw/9Z00Ef8yhE8V
KUx2uCfqOL0fAOU/s9ld5LcDKZ0fWuiadm8Jj9vkDVEVQeh9duMSClCLcps/jvDg1JypTGE7TiWWUdc88bdq856LAKYeNAsyo52wiF2ZksZCtpN7fptDdvj5
s1Jrl5jOqKLo2DEvzmCaCAF2tEn7ORaMa0hXi9YFzrWv0uyoihxiKGdcVF8Xd1/Hv0H3nPzCIcKiMqgXheUZLJCMpTAunTGs6IBBJWLvwDNZPI0BtYO9nUHG
62feza73drIT1mMYWn7IrXNWVpH/G2DwyDTX2h8ETj+OejdZZCwiYA/PH55WBTocp6cSSdF7Ve9MF3LfUvD/hrQh0iIwiWMIGinYqtrBAzIaaeEch1SLj/NN
ElymZ0rHDU8Xtz68T1Lq5mfMUgrK9gRPAp9dFDLsdxtkYNLfGL/Vn6mgZcBKddznHJNSU4Ajjy7Dz+xyuGTqsfML6SV5DOLfH9F5uRo4lb55NIJncEvN4/v0
r/P6y0vjyK8iEQECdY5hthPqVmR7iuTledYH2AczN+ihrMf3kmFChEBn/oKY1spr3SiTJJ4PocqF/b0Xgr0r1z+w3gdX3bDyDMbqd/48L0BBi6ac7RPgIKNF
EIEHCACGAECS8hFABAAweUyAqmqhHeve0iM/4+OY7wAY0e0U1QAAAAAB3FmYBorNSeZPx3NcN5mTs6Gi3yfy5surpHLEMipj+jIpMUwjaK9lBdVtEw5773Z3
sEivvjwcHlM6dgH/FSLvPYGKJ/mbgRXXIZiE6MGWDgx3mAJQoilzUQ7AhqKTj7WfmXXqJst4COlPHj9Ttq9wWNuLMPdxvC77QRMxta4A0r6LZqUmsGyWZvMB
A3QVo4XGdHiNTNb+4EIB10zBp++Ba0NjdWDGItq/6+M+hW2+mCFUuk2HYA0/8r+ZKiJOjQOQR4pXYK2YY72uPfIABzazZl+ZF+uAAJRVPq/LE2v82dNDwaJp
qFdF1S8OOw5IqGfeEUYhm/fTXAgcudlqMBMfyUFejXhe+jN5tDpcrjtTx1vBoU6FgXUEbVCofF7MTjkzqRYhF4yl66ycEJDKBCQBxd6KRLgYNtyzJJ77nrKi
kl9j/Dlk+R63OEsSG0LS7Mct30+tRiJCP8DqE3Aa3q1kVSFQvdnm+keiB/xV9Kyh7dKIr4VpxWqWbtqsLjSrIfQfnsc7Q59hBTG8awgfWf7tI7ZQ7KTQOGcb
1Pgawwq6aPNIqXRJ0qwsSU3R0A/NiwXyrsl3O53FRMZFn6GD/SlIn5jPj/o1MzHNnstnUUqxjX0Fb0cIm5gNm46jmSsAWZAmC5/svTngW2M56Rf19sJsJvb1
+V1AvejivfL6oegiPXE2mZmH04ivAEEGKwgvE1ltuuvSTaPVqruVc/2l/SZ0UQBFpnUN5ZOii8ku9wlioo6Cq0zr611hr1hpOsSEPMeeUAAoZqS287cJg1Q7
B/6PdFHDUO2YPElCUa12Vr0dRAAh28rj+q0Ro07UuG1vV/6Uv0VXeR3i99q8osRRRyWfKFu8vv5V0kIDNIMl3qtEqZp7ZtRb6eIQf8Ac2HOkC/3BslcsYnWb
0UJXEPajF5Bw+EMI2ZHlFRr72TCA8MqLquywAIuZScwn8CcLAf4RAVl79euCKvulCIYUCDvutH7tIIIJnQv9xETXRCaYLRDO1xDXd4f3wbFWaUWVhhqDcvNi
55nnKoI7ZpJFWI+zsvw959gdGJ1vMIzPNlkaeagDT5CzCJ2woBaYEsdEY5R5O0XpIXKRvUyQA1sgDh+ZwhztUCmzDFidNI7TGujNiWJlWIreBtIzo7bKgdzK
3d4zdpmh+f1VGv32bNbulni0/AnlB91yZJjuLa2ep9eS2G/3Rvv3V7viOAFdD2Tm7dyPc5qyNViFCJekrLQZdUr7Ku4Y2P5VMensXDPh44ghCvgfkQvD4ZmH
5FtAfVFix1lBLm6FBJWKmyJW2COYq+ycBb2aDhEkj90pB9yhp+E7wAKSi1BdOmoHApohi6T6lcF6Upy2Y+gP1aGbU/wjoZxJB2ampGI20ITN3rOC3Kh9QP+6
q9wIvwdtWGQh9enxFfonvxd4lc7uNWYOMM7+IMnHn05PB/EdRPjSsj8o6IKCzU8S42kn2N/8ptjLWfPRsMAKgURYSzZV7IU4SntBoIlMP9x5l1aRr9IsR9LE
V9xi30An+H1TMy8qO6yol4nE8LiW8xp+bFCvL5UYikaiJQoIZIjku+IziUEUVTDi30FEsPFW0MMB71zcWRee2fM/NVpJ+RgZkwchJ8yCtV4tWsXoqD2R150J
k66BwL/lAmtJpxlQRmCvFN/K6r72XelLNH+67pT553rjjxjgAKNOgYEH0ACGAMCS8MEohACGf82Y/xq8HuLkSzF48JwMFIaCws16rY9+gIvezT3fdUKd1o+T
0HAsnundR9mTLvrG94+o9mQ6FX3XYb43ZtTyO7oSAAAABupauAUBncPbF9yprIjVh8hYroAlQKm9unSt1zCvKOfehQeIrDgV6B5uK66UfDstRv5j7vsor57O
RDXa6grk5zfvW8TOPMhX5/IoZqXn7djtCAjGJCBOGELvtKkH1aHVYwokDy0813BCysyqGSD5w0XetKKQHSA7oklmVjvri+0QO8y6S1fP5Y1w5NkXpxzom725
6zx2jZaAX3BdY//XYrfQJy04DUNOCsbJAhVo2cAPBxfYgrTzdwLf6CqVDQL/om6z7kRfiZkJXHgfEeH9bSf8a+4+CZVeVv+YAjiZTWNJDYwCRWw+5jk76x4I
f/pbAVeTaa7+/XY66txvHFraAPDYCSzSCrBAP57qOnS1FWTlHRpPj1czcAlh4ANyLDlWgQe7WKkXpQGClBka2mcFiyvFakIQc2r9iVUOMO5vYiIX5PxJuwjs
JkjkOXGAkxoqAAC8Qgp3V6fl7grBK28SBpP1N38wvma8aqMdPmGE7bSFBVOpjDSJdNdXF9CKq3Z3fFXqskbyDwDWeAU3tdaiVa+BsyuLFZjF5kMZQ9E+lYxL
trj7M0EiuavI1uY3R9grUyTFKGYl1EIAkVjrsPCGpuSlfizBJTZGxfRg6Hsxg6zrZuRELqvoyEMYnFzeoDxcLd3n0g3R/Aaazx/X0T5HW1V413ahtFoRMBGp
8aiaLfEp+nJxTjSB7EFPx8KgpFsgjnTYkzRo9hfgU0+u/G0sAJz0kddJPJt9cR8gd0pYXVh3eqyaGNcThO9rmfZ+ma+c0p7nLi6nbahGBCxSM9dPNAhFXi26
eOmL5BFmRbJ6toweAP9ogBLYgjg4VdYYA2lGP6AJPQB3qRE4fUO1EfPZtOUSYRb2LbZa85r+uBlmfjprYHJwB4uXQDXFoKd8cuNiGEVZCShpy4e74N97R7Xz
oL9o3lhE3TOuogPFzRElLNCOnhzE+LXbbskeecjLvoLBnA7ZVS0EFj6jTLEuv6vHXsbP7rqT8ooYQuVTPjFJkT4fu9A9N3A/kF4pIJ+UrZlqzDV5vWWXtQVH
tks8et5ZQkxfMxhg8VeWM7w9PuoOHgW4pzvVK85P+JJCvcsu9TF9thBGNAMYbuwjJ8kTJLDLSHR2ei21TxXSByv6TXP7lq/r6DdvmgN1hMlliwTINcZjJPXO
/4PbzwYcdGojOAqRiFZVKDi+oF953rDgFcKWPhUj08GNUwhpzJzZeTdYBiMFjMezE0xfof7y4no3IlLDw3oAho6BGv2CCxtXD8ZmovWbB/3btz/NBVsoRlki
My+1/vBkNlcC8+tin00VMsu0mX3nU1xLkSzhP2Fkdfesd6ztQhCMSV6Gj0qX/K2LIIEXn43Quoq1MLWjXBuSbO4u4/sSSd+c6TscFfDUz9eZjrMiIE/UQQpG
bWA2vH975/CY+EVDZy58wZL/3qfaAAXX8bylgk50IQgKBfN/ERDqIS3V1VJHgsHLun0LjgCMWUwhs5NS+L5eBUGjyglb9dSsRl9LCTg3iFGtkKakPbln1Dxx
D/KgTF7fCCp/6/1ZiUDOuYxbrKktnNqPgGOadaZJGTY0YjAPQyXi+lRS0siEdnRXl4+vgfbecFC2f5vjLj1L4fwIp8W6MH7xc3zzj4pS9l/rlZ80rHJB2Wxm
KH9FvnpkPb2bLGbVNQpRc05hUgtSAL7UvZoaDT2LQdwV/F9ptMxgN6X47gT7MF/DKHIY+NaUhmQo1y4nVss6rLIvlPbfhd6BQ9fgPweh7lr06mfJNw1h9VMD
DOhZ4+ImUtxZkitQks/IXyi4RoZDpIiAEMafxeCRs0oz7WTOQPZduNHc/nU52dydW7Mw5MMPt9XLHrIJxreX5kcaPux07FPkW3UmMEZNhhoCGG2TBdWsEQEJ
ywOJdRU4gdC8UHhoRJrPXfP+ZfOEcpLKDQOkav5OIzJLQEFrhV/TDI7bSkfF6XzboeEp8jTa1/3aQRK7yT6RklGvKymr30ddqTYwBC4qgVGGU+OHTLwyx6T7
WKj8MHHWkimUplsNDudnjshVBHAH1mhL54Eock44yd7khIeMg7ExiyFlhshMBu6jd23rklisDqueYyhrkc+bqZbNzB9xVPUdbsvhxSfTmG6gALeZE36OioAM
b1LE4NtkoiSeCXZZQULkKAcYAoz9+nnqoZq/9VyOYbPVGsejsjCJ+xmaRuuHpiVELxkQOnWqAGKL0B7VIFF/B96aEH1NdPEQRUlng6c913fHy26FK/gnQ1xS
BwNGRe12jAolMRfXtyrN9a8r94AoOZ3i0uGAWSEN64NHxg0AvOLG3swAtMJUsbuKj7PPeUnuOPTa36xwERZaroeoq36OWXlJP/hxgqotTmlWZ3msR/YN3dp4
/DIZcQBaqnsEj9+T6L4yKRfpB/abtl9k+SMetQELn0Y1tJQ67Z9f2P8Z2UlAwOHkNsIt3qIG+1b/c9WBCGYUsZ3x43KPHgB3/h6aunK532R2f9QCg2E+fIcz
VwrbB5Bjd5EEh3tFB325l3LerEVPoQL8Ud45tg3Gx87EoA6xqM6CAbRppm13QpjM/f0QzJMuNgIpnzmLaaB9E0MeDkS5V9F817XHAwBurJscPPiwf8bCMjHs
1vMqCWLGv5sYWK2BdiAqT49IcPp8anyLF4DHmekVJDBA/Cfi9yYzyRGEn9GIVq6fEk+7h+jBrg9T9N8W1ri7BQLQLjdQHXhPAOF1gJRHKVtACAN0/cPfiwIr
MtIwaoaet2VZ7Wr78un19y3Lld+krrM2fv/WpF9TosdZoFoS4GHgYtV1HaZrnXRFQxCc0rToZgv2Tu+HkMeEFF7jq3j1raPopahb+h5MG1QJ7on90skiTDR/
aqmUbCm/8iRCpKOEDTAaOsiHdnXRtrNRZhgwre7QMRijyVCTqPU+nuV2LEqDIECnkEByM3Uk+NkcWguHVltS86SHhszvDHGweQMbUq9b2A8j5QlQX0bV6utm
096GIIfdHZfMjng7c0WN/408u8i7s/uBI8rcYesYNuQv4JRkYrNUQJdXOAH20+QRBs8A68S3KCBXcMktdLT4Szr0Drybj2O/xm3SPY8V+1TwduyUbyXwmMQO
K/cA3oX2JWBBr4Q+dEvvhTJLK8I7kNZhlx1Y2VdYuUj2ci69miiPwOxTjtlutcO45jNL+a0VsFBLuf2K/Ov4U5QltOqAQRZ6FWEFvSGWhcSIXFKjW6Pw9N1h
5XUSVRuIqT3OEl/76Od9z9hMzJfNXqXQyGLPlEWwfJiLcsnRaxFHpya7P/K9EAteqGuhYBBc3wg4MKDpyxyYCiSeJKJgeH2LMazvsGjbPPZAmN3cthcY+s41
M781qFUPTeXzd0Z0mYMKsI/huP88v/cX+1FlBrBuNB6szVBB7fHCQtSAJ2ncneD8ryqJSHPHKg1kQBfB7Xxct/gHDIFhBoW4buRu8XtA2dd9N4DfRNcM5hOj
ty9UMZNTB2E2p480jglN4mwvSLRyK7yZpSW9MNDaB3QpkqIGtKCfeJL0fLM0bsBdfvU48bFlodaD/w/xqhOugcmLbLvuCZ5owGCAmuIKh9Cyrv7dTnNuOoI/
duub5Wn/b22aSJHDiHVni6QVYR+ZJUEDAW7ycCntqF8wROa4pedpwzyLIx1M4OuBVt3aM8cC4x+aTQPEaDTubNjpblUobXUFn13UXRkf2s8dGhj6+YcHLiTl
zqgKWFTj/WSNHyNpKOd/YlXEEWJGP06jUQAo9yMpZc5dl3LS2mRVVTUGqNVzEiRH+DkdLDszduGcxDsdyI56fLle06qWHCHB4lPivhukD3DHUaRCW2jLoVwK
2LPcVgBXWNTjMcrHs1dycaUkE8d/0SHdulTzefzYTduxdxGhbgqb8is5rcV+gUjWkKsRZpYASOym3di+PMgIpNefYQsUY7uMVr0oEyV6U/+QYfO2d+TWpkb/
eKNxMfdgGfsSvaoFNCEbRBES/ROUT/BWqHEHa3OcLpSb0qGBQhsvfQh69fEpR+WpIsCRZjBczrdCrF/kjVIZLO+e8I26wLCZGhGaEz/5IcsbNPG9tre7AtSu
u5B4djYcNTWkXWWMqjOMKIP4GQlQM2mq7Qht/0Ew71ybvtNab9ZwHfRvFplEar0TYK+u0//Af9LdCVsedqFViXdFNQlmqG7wmnhEIfJ18GWS14ezCuqhGE8Z
rOyhg+wQun6BNS2NK4ttEIfpMNOqwZlJcsfcfzhjXu4BiTRMqcGk3LFyFoySWtLKBcyCBVIgTYMI5aEqHm543R5P2BVXdQFaEW+3fNBRZL95KFvp56fq3i2d
Cn2x+fNkub7qRpe9Ij0UJh5h2rbxuMk5JtmsMG/YIctoJHOZbnH7bvb1W3D6l3BV232WcuSAS7otox6IyAU7AUiYEiXXyIsxJELAqYnTxmugSk9kMz0DPgj+
GD6ImIrKWFhpIq+Ps6q50w2xwmlE0JeGZivO9QAjMs2E90QPvcc29xYQFazqnWuK0JZNdMMM7EucThXd7MHrSLdMcmXvejWgwt4qqD1m7G6Xj7qmXMgVJAlk
UvLIdiWCZaS59AvsXCw/L26rUgN//yH/b5ihWNNy9tqQmGQEThoWiqLOSNpYvekqslxxah1hCcfxZYBWPdDmmtL7F6fR7mR9/62PcJ65pxY3K85sANKXCEPb
V9OQlj45YtNOVu8r9lynMUrmEOnNtwKRLaNvTIYbPfkdvVhMHjz8vlteNrh9548apRKjOaTYOS6Hg23x35TUBEAXmxUmrx+4ptcCUQckha7C6xmQ9VYyyRqh
EnGlLGNwUZIAsFTRw2MAYIpw7VbA4axxqUe0OJL1MgiFj599HNXw27ZulWr8NIa3Nn/TmNN2mZY6ovQ9IlgAo0dqgQiYAIYAQJLxIUAEAGZ/jaVeKASNHVR/
0MD4Ht/dfG9vqPgfA94zAUYW0I3yR/7p90DEvuXtN7+AyxSmpL94QAAAAAORWrqUQRqRkbsNfxatIboVGuDpkExzXoeIYgj9spMUXfSOWFnCFBfxb+BaT3iY
ZpYvoxP6Bzn0H7zIq8UMQotEe9K0g2jDuoL0NgT8jdudYrPtDUnzsbAhNIN3kMJ41vUhPBtdE4j+ZhOO4Lo0IhwF/IqqK0V+1eCeMWlq0LDeasbm+1TuUWj7
3ql24dCSsK2PnoAG7qVRS+0cZMZ2NNf/eSlbHdYrtGdcks0EES2JmbsEYOhute1rxStTVrB+IhtOo1L6wOXDbfSvBrlOWGcFGukKkb6N6DByijxxFeSivYef
m7oV3uUAhsFGIT5P6Cetq3uEeOlpIBalt+8vfqsKoh39RqRlyJv+RUnnUUA6fu5tjZ+LcdRfQWOV3oyfydrIa3/MwpabGr/9nVoZ+iglDpQ3YCnS3MNKTcuI
UsKn7ftsvcIxlavSacpU8nu7DX6IwfF7hlmZpeGoACUBX2Vj2Q0RoxCY9AsT9lIx1Pc+hOiuOJLVrSuBpp9/M5XP6crdmwWxIJycRydzNPc2KkNgq/12izbu
mhPku1dD/k+eLBLLezupfNq7B5MjgIhGE0orUMHLTZ9/EMSALy8e6YRJyp9OwlrK5dpDw9LSUMdH/QwUcY+xMhDCHdbyz4wpJUIboQ4yUiraGxhma0ddl1dr
JotpHTTY4lBbkctnLo2JXTr69xC9yH9Y7HKgQSLys2fjJTN8GEWTl4eJgfW8M3DBR5NZmVt/radLWPmIEQr/AxyuCMksOyIR10GV6BoP4MKZe0pGH0vmoK9C
SdpV/nlxe+EqE8EGYhbokd1cozjTbWRX64jr7uO3hBx8MXt/nk8NSQCn4GtU98FwOOC/1Tb+ivn+jAKBc/P+lSDncndpH53yD82UQzniR4SWBtVVQ9gLfSVs
9CQgI89hi/aoxEhYUyvczR4KjTO3Wop9aEMhoMuish/Wxhlgvmc1UX480xOkYvTrrhzRYXiQNe8pnBKhw0QNPDJu3jFt8gBsdZGaYZkpcHzf3huK6olzgEhI
62R3Ba2lMVHOlzwi2lpKlZgI1PXV4Zdy4QLeRSxiFYBHfVWkoEiUURFcaHvpsm+dDKpuMbtNNujcFmgT8huo02G3x+VQPdLFrEjzFe4P7/7ssTgWpgQzwJau
+t3/QHoQiLUUO55Sj+1udtpp2xI3xy32WNHOE+ZC85+XLEKJPuaRcwc0qMtsQkLYYse1uC20T3DQAFqqlPlJj479CoOO3m4cCwWQXPE1/GiKpZv8B1NmAS/G
10bv9aeYPFh3ctjvlGW/mPXx+mUlzYxRHJ22e1pG9U6d25MhucxTwK0YZ5WObfDmq4OLrnFB5tBQb0AEUFTUdx/ApQGFpU24QNhfwe/+VD3K7R3WMgC2mXmr
LUsPY0XgEZY0LoudAN8H4hIGyWaKKMMSEwgG7xAkC3R2RCf5n1QMBOnIQRrw61cfV06hJksqt5Vxztc8NnJrw6PSZoAoAyW4KNT4gjoTBB6kCalKGTe4eXKn
yaxZAXeU4t968mWFIDF+TXkgdTqZN7MTudzveqOs7NJ1vUDymcqH+L+RZdxEjeZRh8HbKuZLKGTaZDfQ8aGkP51+OAb0540O2xgVvmKBbufX8cVbt0npzPXz
gyvD9nC40dbAYN79f2icgH9FdLLCo7eyMKXLhhUifE6xF27a+EoK4q60+FNT51IGx0uPgPSeMO5dcSPqRnoe10MQXLZiZAX8MjjhdR4rk+MizUqfUoeP8W3G
GaA2YLdyvjm/02O4lQcRjf1uxrZAT2GKHqeNJgYxnka+1XApjS5YdrBmlvTnCrRazDswLOYVQOZROqNAhilIKMhpIh1AU2jVP/ftvQUtJ2cwt+ta4DD7j2hU
tFXsl+XdFgSxgH3MQk8dOLiUiv7MPYDUvXqjO9q6B+xhXrL13ytcErxWo145UQQyyzR8WamJ+LuTp1IMZDCkG1SQCqxODJ3YzTpONR/eLxpLqwDaksDPgCon
d6MkZFcVJ8wgecxJD6O0bwfFBl9uVDqGqEJ/9FJEf8+B8TEODVNTdggZIp1VUDUzI9ghSvEaXzaPzYUE8BQdI1C3DbZfj1tU0+Oeg3/2kHCED3OyXDzzDGtB
vkHOGm9G1TaxoYC6odMUjwfV5fFHAJdoHd7QsCr8+vj8y+i9gQQFUCNa4c2G2JJn4VGPn6jK+mS+YIN/4eesYZjChsJprkmmvcTM4bt9FYtnFPNYzxdcUsaN
wUtRMyxoSMzzjAYPq+zas3BSbQlIduEugOMcSK8+1VIgwRPyJN/uNBH8sYhaJglEmgJJfLrXhhX/25QY1/g7OPCTjkV9GJg9OsWwCqYV0PQwFmffbqzrCpIM
JMWx9JL5XTWUGm3LeWaYlISIem5TAjZRBzqP84/xhJVCHQfMPW9MhL2tHxed+QZaAbdjYH/5u4fE3+l7xRqCjdiZHNQ4soJOnwCjSSOBCWAAhgBAkvERNQQA
OH+FmXXkU3elHXZUV7jmrSVWHL0eQBETMN5hgAAAAAWaWrqT8eyz8CqCMbscKaIWtzsBDaSJAFcKAdC+WtsaB3vJaNGsbc0EPjVHSZofozQhpELYM6gUNjtE
RrMuo9O81r0+tkd799jlff/8wvaF+bKA4awZQK42B45mimUrTdXnMGt4x/rGdC1+zyzUAsLRMosycSwG+hnxgQ8DDHm5WWiqtqQH5xCIWPTZdh9OMu/rdBuv
XNR3Vz8ZWgiMWiDHee8jsGNro1fnGvMK1rgvADoECb9AgRx0/NxTFEAEsNI/I7Sl3U0kHHJzEmPnp6T43szadejuVoYlgL1VmK6q7YTp2jnskR3tYMC4j+on
OOYbkn1N8gc/MwWQXK8shjm3Z0zSrXeIDTP5RHyeDzJDggPb5/SZVKhhu6TOF98BznuhybcftGR7whUnzsI6hl/hVvAUDuQ9uONR+S92coGC1Z3pKM0pa9rg
/QgA1g2dTqwGs3HwOeoFXwoiiMby0lBmJ214yn/t/U2bvW7x2oSZmcUSbZTKnCtY06AdAShydP0U7hFTzpTk4Igh+fzGq5HMmCGQZEqr4RvNtay7HyImTdj2
/OQyOKaj7UkHwoLKIld6I9zaPj4ELYDHoY91B2W4u+oF9r7UuInmRx/Uz1UISiWIpOWY0fCHEYp7vM6Y0jYFlWAoRN3ecr1AnWV7W2oOGmWEIS5Qy5WUtyod
Uz4SWsihmJTwC4/XMQUNisOV/LGfdFlAQ6FqVUmhDK7fwGlM/wSnl0LwGowfzt8qV4W1kEJ4an0he+pRprVSgd5Za4gJVryga9hR8jppilT9Rr5luBqpyL74
Z26qjAhTBc0F9vfUogQvKbACzz3ABGr8whhz2XPhf5rPKFORJ1LZfAkjPsTx2dqmoy3gOMVfxWYzJLLK2lI/8tBY7WFAR4Ip9ZUQqbpLowrWwCXfzALRydVX
La5mAgTAlsL+JbpvhH2csAisULSgACDqw/o9JsK/XrMzcp6C15Qpjhge1ziCYIAIcwYJQGrDy323aIz6WJWu/fWf6AqKjiMS2gsd6oDIJqUoIviR4LsgD7IC
I2Wf6TNtTQXVYuwEHYtArQl1W2K1adIhFDWUixRM2nDODyFvLpHO5uZLKcg1D7DjsMN4PVtJ1BmIfueRiWT6R7oijWWqO1xj4HwHmXSnmUNUrMkA8xvQI+yQ
7a2b/8oFzfpDMJJq7aPsP0hYU2FqRRwVPtcpUK/M4UnsgXz7NFPMzLtWcsnQDkrn7U7jtB+mJtRTKXfoWMuHc1LmyiBsnd4ogsQ6ZMKpwEIR8d9hl7GMqxTO
qBuaWbdNQLHoIYNfXM/2eivittze6V1OAzAPg2dW9SJRz4WFUkiL7rBmxY/ivbc58MoYl2gjhJWedk4Oed+fZZC03uQjxblkDJ8pf+K4GBAhe7hCv/obWIzY
X8AhPpf+VuFMbYB0itd/wS/o6F+U3wD3mPN0n6gQj/FNoxT/81/mGblWE4zPsXdq8JOsJo2AoiXCA+coVpv1c2d2Vdq7DIL+KWhxmw3pm7NSEW21CaaWQZQ/
HEDSAZKNk8bsX9TDd/dodyMg7wa/peEKhWU0mRqxFLTkuXdrEBEunR8imGstsa7O7QKhnBNlxRtMklwXLPkL609ui5mRqPaWXwG05mW+S6OEpBchumJutygX
NYhPJ/5bXsoQei6IQH2qJN4A7SBz7ZPSaQvnoctggUg+wSDvcIdOutZF6exxRANkSEAQskVlBL08FnxJ6WiGfFgErPTf+8V0Bq28lV3U2nhm7INYMrvrj33A
dTO805P7k9tcDIXoexjaiXuKh8bEAKaVdwhlHknun/IXlwm08JRXHJmeg9aOp+K4TBtKZUSgoyBePXmMDOjSKAEARonZkZwst3xvymiv401El0OtdxWgusjZ
gUYOCZzcJQZDyS3pUjjAIbLN6X8/pQWOTdqgWqrJn1z4PG1QAsUcbwvjzQYKkC5NrGyshU3pw+fsxznpWArJasBuCdfcUATjQEBQ8RMsEAesIUTW3KGadEvP
j3E2RaXffz+FlvWhAKCuyFVaM3oUCKJNmiGAkHvG40bKq+FgJdfsthlxjdVbC/YxXtP/EqumY1OcAV1b4QmMzG0uM/pGb7lX6mtUZXAXde0xEFni8CE1xZBS
+3r1CuQK4ZRmb1iVmRMp1fueO+paQuxtQS9hb5zsstAOrQbQX0wKBgzzHinVndBRdSXYNVvrxWVnE7CaAb0ktO9dA+CWYWQ0GTCg6uL3vT7on9RZvOxvatOQ
O7tRXJpXdEE/4gGDTE0ikgnKwTVs9pon50rXbEoXCKZhPkrcCVZLLI0Yfyav6w4wsF2jHVGDguNaHqu6Htuo+SSL+74aOICBG8K+BW93sReylSyaps9nknB6
1u0kgRImP5UCA+jb2qgNi9GyvQ6mMt706adGaYqlT75op9qRRfA6BTyzKwRD/2D/ivX/oPV8MrIstRiTz6o0emsnOLkkg3MoF7jmVhHVn0GgIlZA6sl0p4O+
irSYqgzDQgRpD+cQ5wMa58+QPL40S8ZKmwMLvWBxoMHDptzirzV1ls1B8F7m6wM1YPqdScW2F9UhRbA68fqHkjiL34rXr4Gf4TmTkAymWr6VsmhSJBAA0fnA
vHGQq09H9DJ4XrpH1/FRtqkUQlnbxr3EN9PZny0wiVQJDztXcL3FyRC+t1BG//4GQML+zMH4ER1ROFf/LNKP1RIDgJtDxptStcup4kMWl6/Yt0SO15PeiFFN
krrJ/OQH1GRdv69Jx4RrB1nDJ50P+uO2jcBWMxSdIDPx+SEeo9fVnsvKsuMlu3U7gA3ieu64oQwebDClU5+8ylKqFXHyC4qaH8I3uiX0ykE+zw1CJMFCeUpk
R3rCl0Owjno/EubEGvifM3eUmFGBRTr78zqhBcQONoAeUfD2z6yZ53dY4rEW2/JhOdlDsc65PlLexxFjMeMnWqTwwK2PoXKg3n0PF1Xtpc6f0zxwJNCp9Wi7
aKHFJMaWHv0WV+8yKu4Ud1wmfGbU+0HosRS8mYrTO8MU7GrnuDTk/s9YialO17Jrewme8B4I7DSoQREh+5NAKaUDg54C27ZhRyE2IKNE6YEKKACGAECS8bFA
BAAOcGHlxHTwAAAAA3xd6pTCUKW69B5vPrg5MVCmPSwEpMy4X0bCQGBGmRay1DmAjz/TJGrdrXp+wdlIiIxDOlncnYh/C+VVkpgI+OlJPfAeEea6M/Rbc6r2
danrRuBjj/5g3PGSxuzwDCrzY4c1KfQyoAZQCnVWCQ2rIPNa/CUvSdE+Wh9qqS8Y1vM1rA9qvN7D3CjwDqW1EcvdkjPFejMi0418ROiWwzVYxadG/64XFXEI
A9jimPtQ2HTRBbhbzmHGi/66Qe1v+CUprkSMXyXF7rOl+L/DVRYoNhnfC2Tr0lIW+MlbVP7bu6GSH3xUQ7QWW/TySEPPFmEVMUuu9JlOlhkX3mXXEohfpCES
5sC+K99YQgXwwYWvWAj2Wv1vW4+1Jcqe8Vf2Hzkp0ZZCgfNmIqqqIEaG434VYmXpiFVHcqwyViead9QFdzSkDb8zRTBU0uFQkNkdYqkgJhqDcDo24gt7SRy7
dcwp+SB+Pes33uM42Mrk4EAW2xSg7obmB/pcuWZCn1J+IeogOWn69iSAT7/fm7luMh/trUKLt0oReL1uoALhAyRAdGLXendXEzy+I8lBckfc+6V3aKVp/Kjk
QJPb+3+RAJpp9pnA11CFXuqZDpWd6I1LxjwiWCwX44LD8WL2B5HzUGyt2oqa1KuxCmwObAlPgDCQDbeu9F064FDOFK7UvPuckPQH89nXhs/QTvUKtHlK+yTa
pIedoYqJkuKyfXttlP5TbWWhlz2fRa78MypxR7l0iEPlk9IguWg2664qEkUidsKhBoOfqoUpIeYlkCU4JrgZGZ4e8bpH04iuBf+HBSmY7l7U8GyuUGG5v2U8
36rP+RmPoGh4LbMC79jDcNtuyNXap4dUz5lHen7mtOaNwxpR5Jb4TYiJoKqfGKTwsIo1+L2L7f0J+NO6JKWjJHNAESAdqAMJ+rZX3FEwu9+7dbjgdfX8rYK4
PTHElmkCmryq1P7MrbgX0PkECJOCYgxaJKD6lfASOxoHh8SfpgSDYDUy/mL+pp1ni94a1m9OAtA++TSRfr2l39L4v0BExd8NOK6LitWuAggaM8yZRX2UswGo
TER/U/UejvLv32wpbfVDS34AdYQvb2wIK8we26Y0kLhax3+cXlp3DBcChuPUD85GBTlT9ZCb2cExXS9Pko+syr1qlDwa+hS1CfsguH0z9jSWzfjK7H/cHvHL
tVkNWOckXdCb3IoyC9uAPFYYFp8FTWdva7ttp3tKw/2iCQOOkHdUOBeOjIE4r4WGekVgEmezdLHSqyTyXiHmA6yWYpXtuLxOJRjrMT+5UIIapW1ddnsUnQzu
FxqrlXmqFCc8wj8ktGeYlyGrU/AtgowTXsserhNj/PI7F0DQ9w7pk7jldJKf9T6ZnFsvzR+apKvYKlipo1qu26TKlYPCemEV6nY8WbH/+1RqHNbvNOPNe4/9
6V0IxAfJ8mup2nX1cPOOS1xpIRgh/ubtu+X/W+R4wVDeaLkNPPHc+T1c4zgERcP61YeyLI7tpRmSRi0xn/FwqVWKUypXpZ/nvBgIdBAMAAw6wW0SCCdFn9N1
nFou269ceRKFl+HRl8atvN9X3yiN9iPGeyZo01lNPdNRDmNekRfSXSiasPn7EvkUam/+5V3RCzwMthqTwElKC3icsSGCUvm9gV1KAKNFMYEK8ACGAECS8hE7
hAAYcYFdhKRoA7lIIQAAAAAD3V3qlNOWID6+IpuIX+dSksW2mFbRGS7+2sCZ3opXVFhSWBgokseGPiZfCmtB57Z6GQ9pyu4KnuWFSNpPX1jPYdhaj/+pAs5c
LB+KPkfIHLEBAvndmKhmbN3axRre5NNDyWQtNX6W4hl5bF3+A299MJOgDg9ZDL3YDoPPxLj7L12pGzi7xFEFzWtoqqGteQ5sJYvScvbR8yB3pi7BZX9zhVy+
rE44r6B8/npBeRZeCOW0ho/iDIa/8UGIxU+nAoNvs9VG0WuzuVssUkDiHqyIekbxMog/CHluWbgeg/B9zQTlzzi5+QuZs7qYq7ycqZ3UAXHQb3fHaMe6zeAz
+ctKaRXtUtq9PukFPfizteopa9AMFKNhPvSd9gsK+4NIqCANVsCooDqr3dS5sRC6irb5XwkOjGK/GgQwZ6R8IBgusWvpNQBsRP0P91HjrtFiQ8Z/zDawI2TF
u5Y3tgrhSNyc6GTNTdaykPBSRxb6hTETKqOuxkki+CMPaVB5I/VZ4ekMKzIHpqZh6+sqBE1mt4qN4/4h5wcylN1c7K8GhFNG8DrpQoQSYdSDnSuXgku9EkLp
soK9/gPDHn2ddSU89KUubCra/PRsFFVzjw8K5E0B1/mLsBLlfCYaqnAF+GHduuC+niVr92pFxcGc+PkHnAqFnGAMbp1L5s1uEATA8lMuQudB9Z8hvK3Zl6dF
EvVX6XbepVLBXlY+5MetjBiRXnGV9wWKzmlBVgpMKQ4uiobHEZzFN83WaJWKJOpYfwALR+RX3ryXg08rmK03MfAb8uAGm+i2XeGTjtcPPDTfYSAsnbGgBiRA
LQZVNX3SHZUQ4rp/ojMZBTbpC+7xff2dQh9T6QIqRavQfFfPlN7FApFqNgbrd8w3Cg6nPezOL8lHFXhuKUQ5V9anDGXILmc7wY3V5+VRL6sAZK/BMTueervj
v9KhPdDoeXeEtH3ILStC7IlAGfM62VhKWV29KSwd/rnq7ro3av5Z7g6FCUfytEc3Rp/S4pSzasN6AIrYOuudJqoDoUxFy5UwKLo661c4NBi2zfOTTazk5UMR
j+UqoVhdiPkU78NVBNeZvzc7XdS72f0TDh2lqacRfUm47xc+bxnqO7GYXNrJIbrTvG6fI8st1NfXAsaY1NbfASD5L3qkx9L8tnkS/g+OdhLqgES5dcVhPFfu
2+kaMhIqyiMsVbOvqMuIXdkp0Jf/42hiC4FP8lnvgMSkgg39Okef2q93DxoG9lT8PeLZQIzmi+MS2t2SBCn1ivLRVnOLhlHogUhdeO5ab9M5n/m0Bwdi9bZl
jOpBqCJNYrs/lHmqKLLG99AAXdCQjZVpE/b+dICPmO/0ATB/FV1wtr9KkDWYcxku9baOJVPpJU3KCD68ofoZuKkMtKlg+HlcE8XAGdVx0eAOZSZTD3/1K8CJ
6XEnYo1Sz1mLw/ZVVfip2y4hqmw1nUGTs0l+Z1a7gF3jPU+m6CbVhAlrmVRn9rA6jTrT0IUdY2f+fwgO/DIcTtJ+21z3AJopVtpX60J/2IxOGojQCKEjpgPk
0AgI3v2QVMHClRzgxTFgNoB9RAiHjjYWxwDbB1cAzwQtTiurb3JYV29HMPW5gIsUJfCVNVZ5oUzhP0ivM5nr2cvfILoyjBL2YUiYXRH/gHRf70VfwSa/Y/N+
cN+5fRhX1YUHSSOrRRNW1iKU81dLfLwsMIPKRTpj/KlOccFDx9lE4XLUksNLR3OGTmmAmC71W4RLAKND+4ELuACGAECS8XFABAAwd2t4HBYNVptq+JaJwPtn
ser2EAAhEAAAAAADE13qlI/Wocpt1rQwPo5QaTZUetiT8r3r+CEBObP3ew26AV291YPizy7ZXgPgokUyqC6pSlNY6OTop1KX46EXaBOvpTKTJpUbiAOviFgo
SDYc2OHW+HwA1pAfVRgOAbIPPulGHjyDUi6I9UFcclD5ESXEXXJ4B/A/JoRolnABdkX87DUN6pEkfxFVDq3gi/seGcW3DFq6O6UlIdoUubf4V+NyAiApGguu
SzEd+EBhda/Pff6NWjGJGCEoXk424zvyOAshBAt9/JAZ6CQD8x33T6x8pN1r+SKc63V5FOvy9gDeizU0Eyk4LeQSZqasqn7BiG0rDzh4KrFbTLktCrffoxtJ
5ytQ1/KFa3UGn0cWxLrGOmAduJNJUNw12dkfTw0NrLajWVRIBuFsat+Wixb+lScrlQAEdekAOEPKjggihn4vkwkq6BjunE/p4OFJgwpUUY+vgDFVtGfNXnfz
9flwvf08UpM/BxUNjiWB+WZJAu09JStZ5qg/wvIS3GyZ+AWDFxgktTqsh76bqoa/mrx1EE29Exoyyzs9ATuZzdm9y7MVs1GrDiGvoqi3OGSLYDFQxaxGyi+N
ZpOPM+nLQRyFYLqnbQtu3CEo2reoDLEu8KzVTXaliYF1UUfwArLoedJwAnNDkGRXu5gD2Zcsyas4+kSErby+50WJtZuHI7LS9s2QQztushEjRuoGvVsKyX3I
gyoA6VmBkK+ArMeurGVhGQc1R6ZbSxzkI/9rWRRtD6A9D/jc2+TNtAcdsLLfGzz4y79v7oefhBye31eq24FIU1whBqWUXq59COzzHe9lEBZ0aViSXJ4XwTHx
s9WFJRM6/f/Sbp0bGkqjKGdEOU1tsPdhs3RQ1rvnjlNLSXPdRmhzWPRLhXH+w+SnRKCFvnSYAu9dLpRXmnI3LSDNqJSlFrB2cANqUkNPZnqrcnRWDyAJIRqo
Njqi91dcIJqLtYelp5zyzmSdQK0IEkYOXhColh+zFvSvO2dY7peBOFQ7yW3ZS9g1zsp65FwbaXy0sYQLzZUIio4e9VjRGFi7ES9X5dn37gBd0LEnaVd+8srP
jLlkp/ce84wzP42ocamuY654NrGBF5gRLNGYsfJTxV0OtMOCjOpeW/vwBvFzp6utdnwbnylOMaAABrZN8vC/eHYX9Oz0i3UHLIMzrOjTys6H9EixTGyzRlKW
FbS7/bRaK7wpswBckkv27Wwd+6B4IFzmfRtcWopE3NF+a1p9eyT2KG9hwmvUJ//DMcOTMoyGuBurGO6guO4q89wk6g/Y0U+uriJrZKqJW9YKfWuRwtby9Ohw
o0hogQyAAIYAQJLxUSiEAER/h/qryI7e4/TyXA0KAsKyo50s7kcSGkuMxlA+DimBnsAAAAAGKl3qlLxDys1lkWxBQ7mOc/IH9I14GJJJYHsbH3oTzUPVeVtA
JpHYxuYmr2PDbK2AjmhlsuVD1Bca+XO0T3sJcQef7awz5d4WNwIIcaiFOffCteS6MZ1JcO0GIwKwtjEDEr8kH2LbtFUwmOmUX05b4OxJ/e4h/jsfK7KpcYvV
7thZPRKqgoepFxkm9ERHomATi5dwEN+jfQVqwodYRpHSzmZF1LBlHrBeblJEC9Fl8e9ghZURhS8/jaaDwiTrUJBoRjodv95SE4iByJ8GOyQBfPym2fcdo/Rf
3FkjMxvxv0TE4ewBwuL0LFwmN4pdzZWNFiPe30b4G20Lg98pxdRQEpeosiluEzDeMGjAIttvddocVTzU3vEkIdkDOGxUBN7aGD4puAoYWcBOMyyYJuOlLSz3
jFIjk/SQnXuJRbkn5bpUdfH5kU9Y36MfyFQMDRgTrOPeo3cm4aWoD2/6U0m1Ao/Hnhzl6L3jPR+Dw5gZv8kUzKpfxMgygS4EHWCoTNIQaL0Q+6jz60GXuz3y
KzfZPRtEeZXOCdbiGPcgmGz3wLn/d9EzPGFYTZUx3bnx04qub1TUeWMbmzAxADectPDIDTd46CMsn081nyePVc9PkK7Sbj1C5H8m9+OZvOUyKgSx7mF3jZmf
hFCMwTM8qe8pNl+AmPTQn4Ljz9ErR0wt8TlW+0QfnBS5Cu8hYM2q5tSmCvScRvJcKG3DZUG5rh9Sr5thbsbZiu/cDvFP9vPPQPUHwTHcZBk/q5FhNuvRWfcb
jFcfyaBddNsa1NVDSksw24fd/Yfj7Bt4t1Vz5cROIZo/wENZ5trmgnmM1F0QwFTTa5kaRxKNFoDXWYxzrhq43pk/dRhBliJS95Rtgr4d2c1/Zi3triP1fC2E
AA9RE0uAIV5AlXgqbZLwHGOiibVOyynDKPUJrzY8xVNZN0Q/AC8j81jWuWB9oIoDv0ifXr4kyOq6PFjPMGkv5DCxLKvockLbYFSPGWHcuxqaYScpamQJbjAO
TPYD4KVzEbyTrifUky+Ns5JyUgTqPBcmkUIjwhmbysW2j/gQNDOTeCy9sdISw/HPZ0WC7q+/7XzA3SvofrAT0d65TIEMK1BarFpnaC1dkgXjPybHxZKsxgAu
QnoHBR6nUnDEF6nLhX/ph1hzFCvVQDxrYN8EwdJmT4ym8WBUo9jgTpzOFn+mXgYTg2QSeRTfIM0qKEw1mo5Bta/CivEkoq1HPnUSjXQuxmQM+LE1pHj8dC8j
VQDqoFihU9QiUS3SR2YSNmDVYM6Ekw8FzTuLst2l6qKnRUP8FODrLQpTfUEJpd8HaFPW38oRao1z+ouuJWZUkYfnkkNQJ+KtrHamPLUSFADjJ4kHB2wBy+6u
OY8LfuItVePueVMQBprvOi0UbW/clIYHray+7LvYkNR4gfiaTuCnaX8NzB+tr2mS2wibDf2+W68yEl0ujC5IHOqLOMqb/4F0eUpl2X5MAKhIUMJu31/HhHcV
w+XnyeyMu8ISe9OvSN13FZxjYBwE9psEPMndUA2Uh6bswOqCUlddeQey/ZSAvbcuSiEo66+dAUzzvnPvo6/Jqad/QOKOuJu6iyFPiuJ9mn67pyJseso6f7tD
rSeG9mQYzZf8QhI7ZJOUeCmGyDpvcm6QSozit/XuIuVx5QC9HdwOEI4ok3JeucnDtBvRIcZF902GlAsIhYqxiyeTlUwgRELg3Rv2uNCY4D2eQ/zJjrJcI2mt
30hSb+LOqS/2U694OlX2S+F+tEm2TGy4BSvkedIYewoD7M9YlSkglhZy9ntNurKx/YbTmgYICbCTqFfKKgyhWSauC1LSX1uQiyX2aJc/gRWnsG/c5xcvTxDV
RfrJ/skXdSZnuVReL5qlhi9UU1FBJaqVuk/EOEZiCBko5tvWRmy4AGLNXevBeQx52R7yZtTzNyA7M6tuse2r6fZy0hNna9PdGRSDJbF4AH9UuHXBZKaxpJLb
eJLCJc9iV+RJmjKyaLGo8yQHmOw6Nf1BXlyGCal49cQDn6sZ2RByU+3fw52Qf3ebVFYjwVVApvnDmXGrBUWISFeiO6Lcx5qMUHxy3zKVk+jvvhsVxyZ7bif8
KloIGWnLrc0XU8xvoF3QvvbQOkM4+TG6hEUKSTQ6fsjzxBz4quyNaYCkvPcGG9UlP9x9HlGUFL3wziXe0jKYoi7PQY3xmsTN0tMfyiTe7Ufl1++7jtmpxJmM
BAy/YyPRW1e419HdpwHiT1Iv0svu5Im+yYjaC380ZGE60kWIgIDeJSYYaXYfEgLwdPloojPgpjRaNfkCc/l3xIX/JQPETpYk2MpkGiDYAUILbADDbDn20qgF
NkFOhxj7M6IRgwFqypf0jFujvDFiXKHBcJdshX3lMSC0FdYunKSLtXiyLhuSqIUi7KL1j3a2hoSyj0VjR/Oo5/ifSn53S/LQTRgGMwPJs6N1dCGxChTvgRAt
B94sTxdWIG5mgSsuOxXa1i5CkSIag0dhjYIXC8wmOie0ts8LxkmYhrgv1kTiApxeMpiasxsj6NlxqfXJou+CIRKPxVfveMnFuech43XT/Z17P6SVPGswvJaT
xfMW+qAifOICOhq7mjsilU0WFYwrsVrLtnHcNTovf90axu/ruKdR76CMrhz/D6U0kb3dn+Iun+yjsgx9Jr4/JwXajwiRo8HWHEsOseipUUSwUP8vBvKgnRph
L3yCN+smwQO3OvZ85uggPRdv6kURx01wI66yWCfbpLw3dabOfyXmI0etw6kcCnnRro+VFzYsj7VLqEt/5zc4IEE9PobkCA6j16EGtR4I3QDzfYdZiKNDy4EN
SACGAECS8ZFABAASf4gH/2979iAAAAAC5F64s9AeLrbwwhAT3XuBr6GtSr1qChPiaBwl2EcVL1qvFDDNRRvGwT0wsRTUyYlH3GE9YoGbUOgl8/jSK7W5YJYT
0gUWavd6DddYf9pLhvkgoMJUiS59UbbHaNqi3e800kQ3uBwgf1gIfqlhWrwtURUt4AUqeFEiFwKw7J7UVZ67ldSTIRo+TbbBD/lXUeCO2sqRNel/xSuzly+a
Bon8UUnvujS6Rj+zpB6BBBMWa8sws/e372zOP5OwgxsHwtSt/+sHXj+9/i4nG/zSWtGDSrRVG0Lc+D1R6QJVdqyqIjSqzeTzedX/UEIIt6El1XCeK8ivXYTY
nhtpFOdwqk19L3kN9SVbDaIENFTIeYiSP/FvbmXjZiFdPVXTAGQDq2bcpB/u//iNNvKresYx92hgw0wHZTWyG/MCkTzG3wieIELWySJBaoNn/eKEsEhdUGjp
q0BZLRfOiOsbU64gSFrKUJK6l0AY1x9uqYcWUcYd0kzKhWDGWJnDoCp+l3icbdS8UmvGpDegeNHEz3PSxz7SM1Y7yPNNxKD01qO4ZEvNY6qynUA9Q2mnxkl4
AytK9A0nKbgmh48xCQ4L+5GfHdBY81+F6Lrv4IynVv8YD7ESF+OB4aey+NwpHCCJgnJ5DChdSmkybblj8WIZaSpYnr83qpqoj+nXYdU5i9y4gx8yQFo7+mzp
5b3uXUxhzRLIMpkDnQAlqPh17iJkTU2/NSLNfE3/0Ef7cE4t2PqBljE1d59gpFGZuBIrnrN5DLAy5mrK0jLRSkJz9Pnega/dCV/YWO6aN1rq1q93XzAf+Hjp
ZX6MNqf5DtpXwLkEUsS7OIrBLp56UKRXMHuyW/Huy9m4U9PaZyljMnbAV0zmPOZjFfjCYM9i0oi2MH9JDTCAH+hThKkoPzr+mjNjMmyblSTqn+kJaPSr1Pkl
LD6Ay4v+JE8Wyu1jJlhqOCv+axmIVcmxI9mNKDxrL0N7IBqgvb7J7IM6rfwAXdC/Rx9smJRmL55uCbmU2Ps+xVTx46XYwrNIlZEnogLQxH1U2jWeUkufEx2k
cK2YnXSkgrZpR1qn6c/pw5U0oRr3SiiZIze0bVZ0ErF4eKQb7CKeUCnRT2yTvvMjiUrPC/CJpmAkgheRhuL/rsA25QZ2A0ZVlLgQRVXak1jmazjh+ZiLavmA
ah71bS8wuIDg6EnA966exp+cPpGJMrKs8fk+i9cxGI+svXIYhLVLy3gEAjEl+5NUVnvkyc37IjuzMZjrjP5GwJGBL5+Ao0TjgQ4QAIYAQJLxkTuEABJxoYbO
rBeBAAAAAAPVXUB9NTYLJN9pIOeACc6Zus06OUon2K3OJGF3/RyKpjIyP3r+zqj6pG/BCLQfN67IrLE8xK/75fmG2aV9tMFCxip5qOC6q4HRIHdLkJ7/FDTr
TNKk7bWadddQtNqFu7dG36NuCPuPDZWyE3xxX5RfR2CNVnwG48FRWAaK4HJqnmivoqH5m0VyuXWi4Q58RTtTusU83OxI0agfDHHe6xXkHIrvmPfExE7ocmBd
G1Jjzemz3KM/1hks6RrDI1kAmcNb5A4JDvpQ/lOeHyQZCHypbQABQqAhvUM7w6rB/Fdr7+TQvDxtobxJVaG45uG5wf4PmImEi3Z0RAf6GwpljSVh0QwMEjBS
QqVZK3e3M9faj+eJqYbp05Xd05/YQGPGfW0k+Akr9e8UA8b+GZejmhhibX6Qz/H2juXI2htGrUwAoB3/YK2y/pI8sk5YKmIOSSU9z4jivGHQKH1Va1T+eUwj
b704Vf6ZipTQqjiAsN9YMCiQXC+FRnrRvizfazflWsGf4A8UviX4PD3CKZ+9Re1W0DNmE7B8vdKho19R/qGtm5XFps+hZR+uYG9nyq1nt39+/4LSE9gU82YP
6o2XqT3RV8ecoSOPacsx55CtgIu9GIQ0x7VxxcOSrguofBJbXWKb3yWWRezABdR2T6oE3GLL8P6+6FOMSG58nZjeJ1Q5X4Sbx/awKiErgA8bHqqYBclLXjiq
cysq0hD43wAEvG8g5gWpSsF5dyMy1qHYTJkrDx5O8GcnnfZVY6HRa1epY8+PZShq9STLe0IH/XAl7BrZCUhd9IxkzykqujxNlomYkyXiLLZEzYTPU9oCiuU9
TsBv0a0T7Xey6KRF+xtPsJgyrjdT4uSgNDWcqO1ZNt3mzfpljLdCCLboi1+ZZTx41QzSoiFO4D7e2Em+hexJRIkz4OVsgOxEMX/A5DfIfvWwDNNzkfNugoLu
BGB5QBTetxRVC8DvZrqvq+rLbOrzE3yMBn5gLma6g1ns+oFEGKPZnumNnaDko8RlHrvziYHrOKaWRhkkuHa0/xJiOGetezJCrLxoySTij9AoExQmX2SXfT9Z
QZ99MiFfx/MnhQAR5t1tPSUmV2wIahsvpAIPVWFMXYhyOrTzb/hb7q249PnaSbD7OgWelZj88GlPJ3U3JkJF3Tf6TcrkAjLLl7SX8gR/eaLkhQLGhS0kaLkx
WL3ip0Ku0jhE1lK1cNWY7TaYD9uMt5SI8Ckc37pVXft2sR430TwYrDTXRvaf3HpFUVHp6VnTbKCNo6Xtert26lq5w7YNkS1SBfaCcs75rbNyROYkSHBjM5JY
Xc++uvJJRcLbBmD9qmhGVRDikBAqkHekvw52f920WYLYzMKGcA+vpNUcxyU7U3Y7dWc7WWeAIlmdx6a4BH2Thc2plfXh5EMaaHcIlih7z1TMcGNIBYXjMFtk
pb0nV6Q8BneNOujCFr9VChZidrI5WNSYIHWHHRuJedLMBU7EaQ7FTKBFG0NOf0+PExejoLM7XU3OWrVOOmvX+OakzfGs9yPItx27PlxtzaryREEeIBf4qwE1
JLgcjb/GpUNNhmsvIH0YZ9xPpuD9Fbl1zGbbYfLMI5H4dG7o80M2A5OUxidGi+R3sL3q+kta0xK8rBh3nhNwo0TFgQ7YAIYAQJLyAUAEABJy7N1+cYAAAAAA
AAOxXeaPe9k6eNwB2uwjnnBAKaLhEuLJ7XP4GyRujdiU57UqYQy+emCfAZ7uL/8cWKQVyUVLPbSsSFq+CrkleDeoJpRqVKeGNl2/SWYSE5aSxWR/CHGo0mKL
Xa31svLQKYgefYSozM/dUAJi5v1Gv0tc/oLxJ3mzlQlPT6hfRSZlsh4GSbfoLpBri7fBjFmwxRfLANj0lbbUKUPslLFDcvFhJUxRvEG9W589CIMuILFaCJGl
zw+8/HvO3PLkwLC4hGohlIj+Dfu5j9fbtHFtiqApqFGxpRx/+5Z5BzUpv3wZmwShdw7yoFAySHc8sdu03Bw7xJ5M/Ye+DNmLG16p7g1qG6wGdlOtGY7XUOd1
8u9dklAbYnI0R2ekoxEHtFP/9LfTCmJrO+Uq3Nra8O0BuFtmTIS/Lm9kiprfdY/7PNwymtPDT59ugHWTUuI0QIAUq1rQsrNprclrt4XUFl1NznrBqxJuBSfs
wg1eVeU2Qwvkf6ugiRX8ULX7l0mI9TzPs+3JpUvR6mHXUrI0IeegBRQmMwl/11pB7O+OYpvSezsOT0ramDYSm8EvAvUVkSwj8kixCKLiaui/i/cKxzxNJYdr
xiehgZIe5vz5OPu9W5UOiHzv7ETRKl+1t+YpVzzpe1tKRLwlr10EBrou0RgIanMCjdbxTHYJqAWH8MQrsL6JO+a92LrbJY1Q8L9ciL9YYkh3EItGclWPdOaw
XSdbqjYUUpXufGRzqszuuevyP9Ut26Agc05NNqbclXFiovm/UeXTyEnTvJAyUFHkcgOFjO5CiSK7p8or2mrOYU0NKAEI6DRmoyn8U5hXUQrKY6mIfw28JQtA
fL7taWX+HWyDQoEn+Esb1nAANSCE/cAhd4xIyeDDEAWqWrDTIyRE6U1Iv+e31ENQidhAazMY8NxlQeVgQTVz7kSDXVj7lin6dMCdcrmZCnS/mLSz/bJXcADW
rQKQkj8o7A27Ke7BhM4AwAUzuhOmadU92/G38kDZXsianu5PyuMpnJEgy6KYkd9idp5pf1L5Q3VK0Qy68SgsTcH5zbs6J8U/oTPUblWVPBSMP/giRpzyt/VQ
8RHyqd1nV3E9L3AZ+mZQ/yo1NbQ1chOx2XVtXgfmvVFAeI/QdIOTF0vXURO3W/bcFHoMASoit4zOikpnPpCeCZKa7l4QHtnQoUfwL1HiIwcnDLgOmQhVKFD8
UnKSsN+w5w5F3QWSrTojpnh8VjWO0T3u/ZGI/u34IeNx26Nwy+utPWavF7ebJaxcXdC/LHEwrD/0I0axOgwAVSLflsB9WmkdJS0VsK/FZnyrT1eCQuydpgtc
ApX8/kOEWs4sSLfk+wgVUa7riSsC1qA1EgjBXfKGmnbt6RAwZCshFzlllJriyrQye4L0prlLJS3Fz1nBmojYLTItb3E5klALdqNMAfKvbezR2O0sTRYkjmGO
Pq692/fAtls8uSWQlcSs3XYP76bqeDU0pMxZNGaBMVLGz1sslMxjb2fNIALvcskmomp0Jai170BzeCUqfGbIN2zDoABphHxcnF1ZNaj3WxrHH9VS6SItThc1
Ge5xvlnCIOLvCNY18VHVQDdnADQNh1nHtVDwo0n0gQ+gAIYAwJLwoSiEAEh/iZW7PdI0Uu1LjaeBcTfKYgCRw2NIuQhp3o8XK+vtiTezgAAAAAecXeZCRJmP
mbn+DzCtFgPfO851J4IMerPGkxLH3dNLndM/koNumqZuUAY2Sv1q4AiMa4QPIMcBDy23f3QslxtsflV/RLDWiypjvE/vGBmrJAdds6zG/ZqG25VPyJ+bCSVW
LX//uwheYPZ2qb8VzBwL7ThdbPEggkukaNFRIMtSPa3TDapIN0v7jA37qX95/lBFiZkopIoufuF0eMXKpnMbDeXyChvd9No09yj+MV90LW5my6bxX34EJzBJ
pG45W+wAAuRoAERJ/4oO3I3uQVbLU58m4Mx5Esh5LZ3UExTcYQIgpzoCje6LM1CJ6XdGfdArxchRVfytw0eqLF0RvTj/zhTHCjc9n1mklBUGbkHVkpNb1keW
EyWVbzn2Hd6vpKtgbNaHfzM6d4PU5j023MgjsqcfBRcVSwpc5um9Sq8zROUK/zYO8m4J2FtnTkK1d5bmAEocfZz1I8hWJyUJ+yuw/vQXVtBnRh1vpYk4cSRo
UbfIMra4nk7t19ebz3/jfDXRxdROeacW00buQjvjYkAQ6p92raRFiK1XgxRJ5JoGsD3DZ9SQLNWCA/BbovWWuP3926qenVqliFnpxkOkJ8Yv//Fe2SFfkyMN
xNH+9du17VZ1SzkaAX7klRLnnz0QSVW/e/CzczJ/3jjiQyxHIHRStSQK0mS6zVkddwECkB0yo9Z8ND7ITx08IoUaTnXXI0aFIgWWcn5wmOzuZeeoYcFqh97y
swDwETWY7OQayX/i79J+GoSOB1lsuv6edNCiNp+xoSUP6NUgdRs82GTp7p4faVJ31+cS5pgmm4tV71U4uayeIiGQXr8vXvbNVEFmfM++vMUpV9VlpKfcpZzA
ZdAEWnGIYYfqcG1H8m3JMhiSsE35QzLZRUASrG4LyE9l706XfBNmYSI5gn/8sr7rTtAgPhymCwpYK8SkPo8bPGcVRmE7HPADXWVuJj7rM5U/u1rraiSypvcD
gNg6rBw58Uj7ctD6Wdn+hfl0p6DqUOAU/DFSDVil6HoU64dsLo7ZQ5srASpi0DfDZBwpUTOJKIDNkKL2k5OwR+qXLWvAv5L0g8cnB3yIO6DAYmbJKhCZvHb0
t8xXePHRG+M2BmvN+9NgYaLQH76jyOd5FI89JAIHV2wOZ8tBRVGsguh/Mm5TNE5T6l2xLbcu3Isiqr0yVj7uidnsi4u2twAw7vfSE/a7CC6D9CYaybfa2zJv
8Q2AsaxRL3cWIAoGOJUadFJFKNRIF8fhCvb3mk8Bg84zQgTwuRSQB2j+iGWogNnQlbEV86mF7T9Lk2jHhMOr+cb1fYVBjyZWWI4rrqaPe9EO5Dh/CQkMUDbm
XoI3USQGP4lUumw+JGeZ2Oi5uK4jvl3+e+RrMBCTbWQdAbPyUMwHsCm8BnRxkZ1IoaBHC/iuFeKxr3hSAIxvEG+TeMDiVi75r4/KoIWfRfMgsU43PmvwRglI
4Vqr02f3V8a5CM965VA7oMH5UEjKVb5zI2fCq3Fvi9jgp3IbWSDXawx37dLIavLx2+Axf2ACEWFZN8vQdh6GujN7H8tT0AVjlKnBZyaBBlwAvkC3EXsEpAx5
52wjIe1zYD+zJCPBdOk9hruYthSFtDciz+16LjiZPRTc0UL6vC17Ed+lps2/HSdARu1yubw98lcgAG+qFsiac9VAUJgiCsUZRONhZxYNlQExT/mKBMv/6fFG
/9wIZJE33pbjjj/XFajRiwzzimH4EsgbCCHMV82NgChEAQ4TF0Jz5lRL/tbVMN9CrS7uqGJj7MI8OJ8LUKo+jCBX4H9lTbAdTx8ZLYhMwfLUqp6ll2m6neaR
ga9YgygBXnNQCm22vEGM6QcMU6HwX/ceUPUXbKLXGYvxW3Ldrtj07AGs/Yx7pQygnJzVzy3QAVV20H62K7gDsMWNI38gEFC+lYJoIKjEz+8x2sXKiu6KIa3t
WsIoZyP1dn6Q6bI6vvWTrj6fFMlfjE9q5lOm+077LOQ3+H2HwMyBWJl2QAg1b0B1FlDvGeA35mMZc2I6Ej7XHDo6DZP8LmysEO71v/5ESS/zqOfgv/wOIgAn
1fc0H36QhyDsAdT/Yg5+MQZHDl3pssZCbYvXtsY7LKhrrDK0Dd9a8z97IHq1a5PT2azFt+ONm1f8niZoPHKv8AgOzOic1k7lxrLMUf8UKi/mkFBtjC8MWdZ6
2cO/EET4kN1jVUydIh4GU7F+o0ShmuzZONzVs4X0gksrExTsv0KGQ7LR5fDuwUu1+2IP7pz9JavG0O4+/kGuLjSep5Y57JURf6t5RIpka8iYER7ydzaJGXXJ
jDAKWzsxug3I1xWe9h+ZOHisnd+Rifn78Q/cSQactW/kRv5MFOzj2tqviH42Xlz40h9J1lTfbu2XIdDj8kwDNeTSFVP4BiAzD5mIpaFZ8uNu4NXvEiqX80nw
T6ZPLWQQRz/Com+AuAPAZnPKrCQROe+Ww0s6He0DlJeZhe8bJ4PqlrxPLsi4FRFFCgEsM6MlIUkADDoO/237oV+Kf4wz7cobUQmXCnk+tZHZNJNobj6i4Tea
HWE3L1bem9m6wUaBHIZ4RrYds+XCSnc1H8TqHwGa+x2qot6fvMRA7DCprIZcpVJsSML8gF3Qt6q5Vnyv0X9xVIRditoMmoQzqY7zttjDP5SNodED9nAP7qJH
dRfkGXdl6D3XpnF/3x7V1Doi9mUyHudGgsJimh/d5X9h8yWlBCNjf5koJmVzwVhwxO4frYFe2j9ituNefiR4hzga5fQuO/6IWIvZ4dl3qZdEqjPGi+xEO2c7
pXE7FHoCQoLBRWsw0FNtFqOThLHFW4/2kggLsBTrevXmVSgtVdtxw65fu1MA1fBZ5Nj8IHRmSghx5KrpHxlCbK1R8k6ZOmC0XrwoMrKJGXOF0Aq0nHuriQKH
EntqrNDYjA6TE1N3leFJe7+fMc8DZx0+AsxeIK69zgxIXRTrM7lJywsR3dm7Z9yKbhpNGF/MdrUXM+P2I+gEF18QDaRWmr0dqGRM/ehCsxF9rgj1jp9rMca3
8ztvz2v8+FwELdQv2cWJIluWo+ueK+RZgc3BSti9BfkHcjtB4MuvBjCnWlLN576pB6+X7YtyXNLIaIc2J55sJgLk0pD1tftptCHdFsCBxhb6JeCKFNeGVxny
YqNFDu6FEcpVmVUOQM1lqosWjMnx0XxLc9xpNZ0axNtiAgSmkoX2tv0ses9+0/z+5na6T0hIAQb0i9RDpXy/BP6uw9r5XrX2pquSFBnWQZmVy2CEFJaUcXTT
cTM5t1zSAOZehMXcHOSR9Bf9AvFrqqMjiUfoSZr5+QvGrRu5E/Who43Vs5Y9QCz9QYA9KP8PxSlgEKNEq4EQaACGAECS8aFABAAecO6Hd0jP58kQnQTLaGAA
AAADrlzUgJaOsE8qL/r/g5THcd7gQ+gHFFj8/+3Vlua+l9UPaylKoEdXevz5QEdoRJ8U/9owhBKMB7qs7ymoN1k34HWAA3J4YtGS1wJVNPpy7IPaizT+a09C
nQ5CD7nopmV/4fou9Hgaxisr+OYK5GmUrf+ir6DEEcqUVrS0LRgqFhbM6qYj0D1gm66q8d1j3IToMIrbB5RZARYTHFtscOy/02D9prD4vb59Q2s3Mk//ke2U
Pry2+GA+V0eLi8W41+RBOqz0ZIPgrmSqe20C97OCe6XLczuT7gF3mtzu7lByQPoZ/XsD1UUPiOkYJT7K0D0EkS4HzacSNkcguLj85risHLWyFoMrj7XJyWP1
GIiLzqfROdWpIGzzEgO0oQ7eOs5f/hEvD+cus/lC5D8W/vud/KQOgcf4GYwORXTN721Eg/lQBW4uTgtaqVh5r1DU8+tyM18OLaSoYFSwca+AQipw7k503S9a
v04XXa3+MpTEdOD4s6M8pM6y42yATxFtBGYH748a21NgfRYmw97ApuSdAAvLRc6A7QMSk2CmcJEzNoKSbND7d+0M7tUKCULtUR2ncSF3rJrYfuxEC00O0y81
BK8KWmMHxv9x+ue1beqIicJgrX91XHAZ8xEur6DB9Aa2AE+1NSYnN/7c+0tDig9ylKn9yvN7WPLxtR5CRhNXEot8qMUEdTtM+uEalKBO7TCmhewYpWmq+kUc
GObRsVNzotRxTP0kKRS+Y8zTht7ZHm1KfilOieBLJ0rSFxgmBNdj887G1A829LAMamKa8D5AH8m0iLtOcR6za4/PkmCt0yKCB12F8Dg4tmZ0eFjCktib0VFg
JRluaK8yD87STd6p8Z3O80frKB4dm2RywPQD+jGyHY/S5N6TsGCdAjk1D2HQXHpeKd1+44l7YzuFQ0h8MD5pFArQ1Hga0FCgAOH+Sr/t28JHOpfjkRCuijJ8
ESUoB0xq6ubOUe4wSwUX1m1U99HZOs+AbkNaZVuv4UqYLHHcY5d1V1ptVOO5aj3jDlQOXHooVh+o5qgv/V769T1yRDuM3+N/JjIpcX4/ze3PNhQ+Lt8dWhX1
UaxmvaHEXfVIaGWAmXivtFs2cvgDwcz8zXS5O7Bet3RVIemYG5cTwfit/YzWMBoHK8aPtgBFIgqNxKOv5sVVHfxxdbTfrWADT7YD1cOvkLCaJUL8w3DUhbso
+P2j7ZU3an9Ls+dNSXNPw2Bk86kN3u8rQfz+JHXL6kUxpdAlkmWBWnpbElLNgFzCh4MhCBNhtw8aGCA0ubNitDc6vE4F917vzm4drkeVkzjeLHpUxpVX9fIH
ZDRWCkOEa0m+WseHxWIwAkZEI2okH9NAGKc+fXEZSfr+rZhgLv0IeSF/bPKU7AP6mMCHD0Dc4BX51pIhllRqdKHgClLbZulLqihSn+ptusnvlj9UDqS7mswF
c6Dw1UCk21Wwv1KJn/iacZZpw9uahBwpqwbMRn0/ikvV45m9GxL0l1CC7E+PezxyN/brtZTWcnTpIwM+E1tCcMkgK+Id3wpgLL+5QCVhQD9z2OnsgZCjReyB
ETAAhgBAkvGxO4QAFnanZBdJ4JSRpsAAAAADElzTjvnmnXNs9JUsv/7Ox5vyk0OpbNpoC2KO8mJJ9w4wlZQvEP1vpbHdsDHSdQ+Zn5nBIN4iK1GBDtn7LHDR
/eNWbUqCSw6S0mnJI73kJCtsBmTmvJSVZUpBpBPQ+GzbFN+VTLQDA/meyYOk0fIgZgEjrZ6dWM0JiGMdNQngXZ/eEGtEHS88YG4Vqc0U+n8t7U7BKvYGdpe1
9kuStyFCvPsNkNKjiZvQvWmnPX04DoTFeqOwvhVym+FCNz/4PSPpqFM0et9TJqaGBG3Ljzj7fu9vY1GzBqmrW65Yv1vbJFyc5eADNwPnPOpgoI3A+piV57V+
9eRas4XVBh94p0Jvbe8HCtG0ZF1vtaCvWIkWndq6d0EDgoE2WFDavrhkqEsGFDYTZlWjh87bJY9tW5dihE1h36p4oi5xC5fZB8RajKuBnwTbSRDzO7G+lGQ+
423CAa5NComOwFvAU1s/ENQZefhJNfITuL31Yra0Px6yu1dfyjM5m4zlO7gFzKOmFHhIGGbviHCGLfmgF+jiH4B7ek29kKs3zCHZXnKBOE9/+OR3iJtPjOwm
9pN1m9je5yP46RknZMjudSELVRIkCAkI9GyjdPhqBxH4D00UJas/I53v1D5y1dCfZNuuGxehaIWu9xj3o5P6ogP0KXjSwHdvA77q/4W5H/GpCK3KQKDBbN9O
2/Li2xvyGLtpCsdPreI9LBhn8KM4mxQ4si6ontM5ea/AhQHVotC82hnfjpPYeWrbd5ismaBpFCTUACzpX/L7vRUXxU6E94gy3lscY/UT8XzFR/YcN8jOMSnP
jjUl08uhdKo8Q0bZMkZ89RrQh9R7FMQ8Wik9O0WfQUTheFzL6mR8+NXu7d3mRvCF/XcnRtynxWVWbqFIU0yB2JNy6HNunV3+FykinOUhcC1bCVIlOVZCjijS
+J6cN6In0HekgaIA0QaWVTcY+2LTwS9hK88Be1yy5mqIEMc8/rgHazzSFlavDeI7CJhLRMDOz2X2l58zW8Qk724EIN73vxnypzcclXT//9CQzKuyjHUOKSl5
bmhfEFzCO1iRXBoj929towTuMwcazKc6T1qaNI3dRYHCsZn2hhXi511pyF/l1KVyP5fra2FFFO962KkVci3dKU+v1AosFtdeu8MezRURkDA/w5QF+saWGqDt
2y4bjVyBpipdCow8VoVOGwMAZQjlbcXhrznryQ1qe6YFvX2ZB6oUKFoxf7QNPNqc8jvhO3kwIzkYLO5pUvHsaNUKBYZEtjYft09pPjFJma90htdlYES/ZXr4
8YVtz7FzuoB4NdbGkmfxflXbdO3Pz+0ZudUWzTjjrK6dBMkHRhXs6ju6Qdsdo8tYyCo2bi06uNiwc+IBxSjIRYhB2YN+L3m+kthOB1mEpTgl85rCnePjxCRI
Fl9TPpxN+IOK4eXyQ80zrgp2hkL5cSXPnajASk0nGVqPbzKPDYHf3fRz4yTCziZNLxEX4jw9qKWQPO5MY7kJqWMZZ5Xm2qsXMcAE2OlWuXmidG3ye0okXp68
fukUyd922LQseu5yEGuIhtD+7HCmpxp6uGRTixu7InDsBZ+QhgMu3VWQwC9iKHCbuEKNPE82zEwUIVOOfWLq30DWwNl+tBNs6G388G/9Ik2O+p1qxvM8JAF1
+XuxVTkLf7NFZZj571o0Isr+YlvC3XoHhHDHPAjiTjmnx6i9NXnwYrv58jlfWAHsyOsjmhbfAzwnq+2c6H69jRlmv6K8myKy2cjXFjMXH+4c73Poqx92H78U
SX8Qh5pnt+P40AOoyvclZd29A8IMd1cSVbxZQGtXlKDBW00RyS4/jnKvi+X1/jgOI971ZYAQgF97r+wYyZSygS9uF6kGoe6ESKERIY1vvZODUwWcS+b8DyQQ
IAJN8qglXfyGy6qDv4V/mQtGaoADjvxOvIz1p16Zqim0rUiajiC8UifT+k//7ms96yLOP9CjmAKfziqbazNnDX1bV1Vl99L3A1dQo0TvgRH4AIYAQJLxsUAE
AB5zu6BnkRjvXmHgCAqhMAAAAAI6XNM1xKMI/WTSXFIj2+NDAlyEd4LOxE9MPk7vhHXlpxZnE4yB94WZF/Fca4MU1zzmaqiLUvXlM6GMuL26aUd2rk4flgiv
59HbwHEWBis6kR9h+zJ52XVDYcOT5qvHCisx9nn1m9AVx4RZZOUYejcOhg4y+5PWYl5z3OI9DugsifkVb2R6NC6swTvVl4Doobl1Vs7pvS/JHdpE9l9/xKzp
rZiewSJ5cEcG73RpOdYz5ad900g5PKatbQoJ2aKD22rv7tAlEzBGIZhKDOpY9fe8gFAZ1ZtJ+APHhOjgX8w80qwybqLgqhMiYd6az0ZhnGHNxbCcAOgnyqKG
UV4z5GJ7070BkZNK5+k74oNxYLr8wMpPMXeA3XPL0mcJjjJEPgnoV5U/7UYHpGYBH8YCz+3LCwQjiu+J3UtgolBochQ0EbLY4mb8ahV4l49K7gJYNkNzN5uZ
B+ucXIRKhkV1ee0IQkcYtU1QBJOBuN6BbZWIOFO4rS3n+gDNZAkb54XG6vOUCwcPTl8vk46dpKjXC/hN+WE16K/28mFkP7QvNw/4S0FmBKobpeAal1iuFwyE
VtWSafFWsHtNwBFie/wgqIvS/zCEkWDa0W/t4mom1JSGIwRePVjB+OPIm/FgoUnP3v6AVl4pFIoVRfcvtiYgSb70ighlEDBcGd3lWCZs7ICvKRVMywca7nsT
GMIKTRp64+sAyWmmJoXlfX+phqLxdGJZmOSWqm9S8WyJ3vcUi3ILh0LzL4GimroTGABOXMIRiiTOCUZJHhZxSXr+yd0TkKA+44BBaqK4McPNbXtk8mUym1qx
Cz8tundexTNsDAfIJTf8TeyLDOqCD8M/r3nuiUbH1t21zQ5IObzqTxMVICNR0E8u9tSKCNEL+ql2ijONZpCAiwP6sSzjnYavz40+eLZIC/mwLyXhDJDOlsd8
933WODep+K+OkR53GrFthj/KlQr50BfUdpF8esRjk2kcJWeUGZ2V2cL5xn3HJHVuHgTfQpZb0tDT0iiD9U2s4GTNAlaPD5B5xURG7kCiiMG04UIxUAFPYHzX
FS3O1XtO12Q/fQioiAUymWuTRR4qI7Yg+2v+Hy9ZTnd0K/m906uuUcoZBQT5FlKrVOtpQU2cx2l8SjwobFFr1oQg9ehS7FrJUl0QhL616IWIQz9b7pMJKOYJ
zeSIiHSHi/yCHiWjuRj40Q3CkIbtGeHB5fCvQjBPPx7y0YqI6MRjpxPyfaHPEFfA8kcXwme7vv5vptRtHY8vVetudGo9eI9fM8zrXqjkCzyX2wAPB6cO3D5x
hQwABKE+DnW2kSmEn1I3LFdtq14wdPzr3rdoAchfO7/5TOUcHfTNTUgjcm3kdrglMfgf0J675GJdEKUY+cesOd1LMn8Xp0JeAxqLWlbwNVWh7j0D6Jb/FUwF
9SBnXkggHBVw9Tru9sJJlyWJCUGV3vhC4vqtSJgMu9hScrv9KFKJVOw1z9KY9sALJws7Wos6NV6Oxwxr+jByAmxZci5IuVUHkgzw3305S3X9Y5ICHHlsEGR4
ka8qgBEE5D+oizJZzeFS2ByrCtOBQuOBFcvIAv0JVJSkrcohQ2n/4uY4HfKEqWz+7EB3+TON+9uDKFq3Tq06Asy/CD9/nR41RRO/RGGyjYfwo0k0gRLAAIYA
QJLxISiEAFB8qfUvfXbmBn31l8ZG3zR6YNmhQenbnjD4XI1lXeeLACMf9XvlZ4AAAAAFDlzv2T+XgqFmDfoX5LyBvel2XAujd9hvn5580jVF9Dx0nTtl0dcA
brfessXKc0mvYiXFyNB1kHvx5zwb8hsybQwIjEUNE8Nw9Pes7zjXmV2C5PpOsLTrMguW4Z8/Ua+Q82K1qhS2+kbjcd9uVa34vPQnp1pPCo3b+AOQ9oHGhT/v
NWJLrn0mAIchx0RC/UeKBGHsG6hPjHIMhSO83uuzLqSi5jiMfucOXApdMr9CZj1hAvjCh7+QeP2LQQq81gWZJE4K7cBtFb5W4rVdPaDkz50DoNh2oPmZ/Mg7
7h9Is2ij8tvRcEdfnT8CO6SQwx3tFFP56H0EQE048xCVnhHRDOl+B1VDDu9bpvRVb/+talW+bajGefFI9yK3BkViCKrpKxoPQ4RmlIKs2TskAEl/HIIizctQ
3a0yMygBIeo5VkukcrtXDKuO2CsXDE0A/+AsSkmkshgvAL9vR47o2dS8lTIoWVvvE+Knkvbt/QuhKapRb/v2V0rR46fn2osaBcqsL9yXKyLcFaVuBXJSnG4L
Wy8SRFUjt1D7Q8mx72I4Tna3YGd8bYx8rEQKmdvn2f7sDqXf5ueXudH2CAGvqVs2LJmziJaQ2BLwpD9W4XkW1/5LMaSrRFQZa9+eCcyGEK830cejlcc49WvP
dqLLMQIBdmyrmevCA0f6iAVy8K/6CB+705kHHxGc9wyx/KekSwdKwU3XYqtht5a4vI8dig5r0H9wGNmCXQT+NEvVYf5oGP9rw5CEx1zsSQwzd8Too4jx4SsD
7pEUnSX+hHimLeqJXVVWpfqiBAHWIG7++92sNBi1D/rlDVrCwy6FTvGwgI07HVy4EQE5+6bkBPXUGFUS722jpJuEuG8Rf+sWrtM2i21rXkPlXGB2R11yZ+0b
p3FgMbMUGD34EGJU726POSMY9bIaspv+NLweFWNNJCEnWShydeLp10L8F/StPgkg0W7bwgqyOEKI+1cn/4w3GX5Aa+zXf3Cq+KK5/G8GLGh2ERwTEslGAGe2
syc+X6SSevQDB4EdjO3lPQ6NM35+xNIdUUq/n/ZdLxQqEUHTOP/iOYQGvSrP04gydLMi+GzLhcKgzCogVbK/VikQ5GmdNaC2Q3quGI0PX48ERynHdlxGDHQ7
xpP1Pb9AZz9ZHPNcvONIJQUMGta6DiEQ3PDBsgRn1fBOKAbyGVEFqqAw4XWew1zcgbITWUJ04Z+4n3jnqnDCtliDgtD+Jt7XuR0KfrI2Ziws4rzrgRtfPsbC
VHhA0AI/GLCKeYrnximAZKmw2c8/ZyLUJwEV63CMYFnGkMcV2toQnMZ2mI3pnipWFYl0UjoyJr0Jgpvx9xctnZzdLwPuFbYDFG7quFsEJPzdqryn9PpQbcCb
DOWL4gCQGWwncWgkPBIhWnTKNfv9i82sqw7Hy3AzpypHtatjHZXIZ6vcR8J949XGYcNjVZWu9XKAz2d0wu4ucmuuKkeb1JPivkKaFM4fdmFkVHsELih6CVM9
Y57s9ZCnBvJhsFMGzH41E+LzUbb0Xg8OPLoAz+8KdoQCljM98AHItHLDIWvHblQqCbzywRKWBiRaCKircEQJos3PFNlZppfzI5IKewkHcCYAxlD0vJyoCOY4
wKHIel7h6bk+oTlXEep9p0hUR2TH/469HZhfkCN6TovfAvGKAoOeg4RX5TS4DjlFKbLglUfte9HfA3xTGBBXuy+l3WOTdygu6TPIR8FJSgDA/9a9NOBcwh/8
zugCbFeaWaUGAPlkUxlxNhzv9NAH4IXHIvHMWdSw/vtsyAz0LDHH2ChP1M/9chXGMqOrbEkLq10m3OqLS8N8icDNZJg+dcU8WJOMN9rwtiZPMrUU0czc4WgD
PhU0fQoIQn2SGibeNiiZMvNlXMXHvqTJvJXhFyt69Ao0xuSpVunizLpAkR9Fl8knglJB3XOn3zlCX9LhAQof/RI5KESlVSsI/P3CErajSK90oQtXZUIHziJf
KpoJ6o8TC1xzSUt+LsTTNQkQpBbdzO0FlOUvoHSZK4SUsN1TWbiO9yxzEhQwyE7g36S0spkJOj/80Y30IL3ldcTQMiD0JtcldNaa0FPgMldjtxFIEuJ4isRB
sfDCGXNAc/bTikgCKVcS40q0cabgZ6d3WTYurFCYkiX6Qy+Ex7y6YH8UlxR80spv3PtmsWbuTIZ6lVzt5U3DUw2z8GmzuG7pBxPe22K7Gi+r/VSpsBp9eBiq
uWPndV8FuGfrhR+z7rcZqVc9U0+co5MiuGYUK4PLk759ARmbwxzh/rMv/i4vF17gj21GM6tdoOB9tYRFBL9V+joeYW24A3RyRTXoPJ/09MTdHmbNb1259Tzf
SVJgoqtaBFtTHKxo6I0y/M0Q0xXFhyGlHmn51ZI2l0pgAVDmCd/eDPQ+SRqCeOPB1HSZCKgLC23puMLwU9kjxu+QXn4OaczI7rOXyon/xyiS7fNlUeYtyrsb
mjcO/lo+MpHkn6BkyZfNBJ0WF8wXPX/a6hJdD/Q0flX/oOpPxhPgdskG5/d+fnkMtHe3fQjk5VoF3KbPa2NSZEnI1vkS0PNswNOaLa8QSgFAW5MG1d3TG0qK
GSGBnp+W+QYkfGAjyWy54ujsxg0jaFTOhw77eHLtLI3ABS28AFcJJlYj1V/B5VxYz+7nRlLRgLJsLo0jxho7En0nvNdkg/AooOdVBG6PbbX9LFLCJNgmolpR
atC5YikjKLQ8DAXmfoiN108cFLxaEM1Dee2xPNw+Im9Su4GFLVlBWuI55qi1w6vRhsA4182cWKSyoGzvuKgV97rUbb7qbkgEx4aFPq84+I5TOh/3Fd/e0llC
PT0GGpgZgCKm2jeMzWdlxjXMW+ALOydXEHztf55N0aHZpua9I6rtcNdW0DPUx7nhc4ZGfcTJO/chUieAYbeEsrfkv7QjX7IA/RezH+0Ta2eQEMm2qZR0xHmC
PoA/KEOkX0nGj89jObenm1O6PzE3N+aaWznh2ftlJJVaJhd/kFBcJyfa1IsO2jaz6CheV9M6DSnuVMEhtsSlCxHIOW/ALtqQk1tOMFDKh4zDgercGa7R9a/r
mtNpyMlaDnoEAKND2oETiACGAECS8iFABAAYd0+guME6aABeEwAAAAACQlzTljo3uyCE5tVEf7DmvYiMyncY69Rt4fBcWm1su6nlfN69fsqoBUQ/QYkaqVIJ
pxvzorRMfX2UdsEhlZyHN0RLJKzuB/iuMSh4q6VDT1cA8KE/O2YJX2VKYKrFyqnVzDEY7M88xXnwgCgrpa8Zsinklt+3NrYfq6iHOt/ZbVidfcuWQ6kCViEp
SHjNgbV37wVoBjCa2Bn+7Xufop9wvw+FRahtCamy8CBf2iKg+RtoxPXhEdB7VX2jdvI4o++l/l3zRJgV0yXQrpd5ftEHSSzgyu6gQUnKb2Tyrun9p/YRwHj5
9T3uJGo79p+joalI8h870kef/LXOvodIBiGsM3qmcUJg4ombwgcOm17zmN8U5vhA5tF81Dx8vaj1LsUav27VqQZ9IyW69Puj2k7veXdW5sfsQzAC+N/21K7W
mDRG1skpeHiW1Cm4JnXN6UV+SMpRcfpSd4pUsCWBej61QzWlv0ePX07UM91N1QMOKLuDIShA0R3AMVCe+Wp3f68vfivFcPlWhBKXKCzwVceC+krEhUFSQYH7
yF3rtOIivnU2xizYgFSc8euvjC3RYmZM6KwzlSdhzZCM8RrQbSfjCt7rI9D5N2sNGSnqjNglVj+ryGImCl6e6/0syg4Bd71E/V8enCNN0Vr6zaP+lIK/XZNy
Fk6i1EYRZ+rKdcgy9rTKYP7aGTnYa+/p5NEAhZdmrH0gEYhK6wkIjrxLPE/xgXcWDUjrDa8KyfS8dHmvfy5htJtWWll8rTKGAoZ+LQYncoewXMISV10M7QVJ
Znqwv2zAm5BTR8HTUC4BWYM2bA3P8TSxJxJMdb96H7GuUkuoHT0HTOuQC60T5amORN/RtzjA80OcIOPmyRCDNXvapdNw/mlGFahW1rZm/vDOFgyn4ScoxnXj
fYI9jDR+bjtReSZzmC/e4N6CFZYjnjOzmqOEsmeTYIlrDmkGzcMGev00PDRWYpc6dniDEiTaGp6WYvxd+XjDhu9gOZ0RsmhdgV3SkgrXPNL9JgXf/E8khf26
McX+O8J4MuBI++3SJlhsyzryu3ESGgHi9c6+i/cDzB4WcZJBaJ6jGNG0KcvIk62cV/lAIAW4P3KfAJPn2QnmPDWOhdCseUW/T3KHHJwdrKFijaV04FEk7Dww
v8Pv5k/WzbiBBvZEB+VY9y2UZdaQ8oU2GFqvJ8bkOXVn3VX0yAw2CIr+f9WrC0/vr3esi/Les2RhZ/eRD3ozwLqCGKXrkAgS+rED/61WtqhevzOQ85li1an+
xzsij65BSMyAH0O2dSBIs+eCFFCjRB6BAAAAhgBAkvHBO4QACnAsjAAAAAACY1zTlkamNOQ2UGLHQ4Z+MCZ5xLSX86ZfclJ8WrM6pCQTkXGm+721cbzNXGKV
oEkG2WcKf88ygWPS9Hg92WuZbF4RKwzDqYZpvP+U3OxNd4Eg6DokAkOIysYYTwcwWklHgBQ2xegHnc3AF8G2T5ZO3irZ34N8+TSkDn60fTxKBzhMvahDCcx7
bzVPAFfQ8CzA9s++JKI4uko/GGeF5EPrLxK3sBxQRzIBqN2j7P1Xr4xYO+uReCKsVSvAWWY5eFI+hXzhbZmyuo1WoeL5TA/RadQGdE82dgs1C1Po865WWsYn
WfTXSNgzF/LwYYpzCwzRuAIIoQ+B4oXhzMPg+fwW0v3W39kmyCyojNm+oUZkwHGtRU8pdhzaKOXf1vay76co+rE8jL02/UicYQGbAQf90SZ0mtkAeQgUm+vG
Xkv8cJqMogGx0F4ohmrNJB8Gg0KNEs6D3LLQKb9GsNizcBqeVN15FFXa/O8FmmyKzjfHau+zTokz7dK2Wz4xr5fvCnFuKRSvhkg1JPR5aPUmT8DbI5sOC1KD
QFw/6hXwzufIcQ69amx3V1+qY5eAmkFnnT++i0/uow/Qr5OIxPGN8YC630FkC0JF7sL3Muop6nygSml8WObJd/eg0M/kM/qNVSNrnNHMneJ11JQAbMitoMMS
qS3HGcCeUGjEp8uZNQNdpkCE4jk5ko8mEgEjQckVDebkZ3+wgI2JVMeEFHdICXcMTHbFuTbtDiY9f88IWtPBV2Dzyp0kUrf+JPyFahrA+5N6TvWnppGkG1EN
kEd/apDgfE4NhH6SDQNRwvS34DPMaWGWZPsAXMI2QrQS5PWw68KQD/13TVQIaTpEnEHFh43Nk0wFS4crJLOZHbWQ9ta9o4BqVPDlcKpUpZmoIna+QGIuWg9T
ctHuFVIE3hBJSXI3tkDCoyUt+cTKOpc+chgc9lF4jwoQ/0nE/j+uWZkTUgd3/cRCvAZTOYjE95ZehaalXneBhNWxE8lGSbA5W837o4jBvcH9SUdeEaqSbBdm
SFUmyWCjvy+OfZvHZYUxVJEzMQdYq/K6/HX66RfR76slTxyZIlqGQ6jwoDYgK791LshnjHu+eH6rKOiWRdvWd8ugFEwQ/KuJSEHEjbzHNytyx3MIInhc0qL/
3T/gby9HsBC3j4t0NoA4ncsRWTqAYvSor9vpNnTC8yv89sjeOd/sCpAl7XiaGKmuZrpnyBh9KXTv+jb+ujyIUisBlxfBPaAaFKmTbGKLJevwsQWndYGTF0zv
Kkm4maPXKQGf/30i3aZg819vydRqHdQCQgatf6WeRKFxFpWuS9FWu5PzbrBjd1U4iKucLEesvjPtEtpkVEVZDG5yGT06wNG9jt5pV92c65Zw+Bgo5JSgo0Lg
gQDIAIYAQJLyYUAEAAZwAAAAAAHGXNOYGbM1wq54HU9i+YFlyOQwgL36FYwXktQ6eicKQz2j43wOmoT2hRTZaRnKjDkrCM7rDmTt9ob/rEQGj/OLCLR9SI4f
LcdojfJskcFpWT5zd0Lvc1uCamy5EXpQQ3mAtiPfdIAYAA9PMQA+YIl/sWHJwKeXlLEEoxHg60ey0ZaV27Q8GiZtZubolMvGhxoXNcqr7/P8X9qt8yaE+GOI
e8oxLnMDDB8gFswOfIkhd6UDiWKmJygs7XHwYH3kzmh3ZZjeZYmeZySgB2Tb7zi7e5U5kBH+lErOGLnz4vt6yvdFdw38BI4RkGbEgistEimV/AKFwTmEXKHm
w0KdpDqp4PQ0/NSvKlG1x/Q8vKoCpYYZyzOaIBGykAeiJUFPaDY+gG2JPnb/KI5Y8omw6aJTLnKMKXQYyS0T26alDb6Nn+cANoeaeCGcruHVEghANBeku50x
RVYzP9nQ16UOIFG5fVe4Q9/jsflhGgEWtP8+S+65eb1FViwmkJK0+k3tPT4xmWgG/YnlkZDEYG5IzYQFwdRXtBxzNecijVjylrNxvfcCon1iNc/4aqYWYuvC
m5VZa++5QI7gL30iq4jIVXjQV88D/sDYAFy6+gzyerUmL/+Q6OncpA+jV/C4sp+/Hl4/K089oGpBuZNbc+7Lwmiwy3ErqOWlWUeLSO/K+ByhQGCrL+S6BqzT
25jpm37DR4BqvV8tabuywl3JeNOOA/yb+n0sDvf2ZTOVFyS4xodhTHq3DH0fUVNd+W2D8kGYnTqWdbC15ogLjWflPxvJct7unl0kqQO961oj5YD3zXUeEmIH
omLcYaKH7CKmzAFpekCdlZ4CMAdumFgfTIjRcKQkU8l7ApfZvf6YpgVPTLim0hsdYPS9ZKtcKcbThH8znNug95bSuT92CDSogKSTd28AYG2edO7wEkEa+l/X
9EV4u1R5seqTyv7Z3N9/AKND84EBkACGAECS8WE1BAAKcHWgAAAAAAIqYBCVLm9zyUMyd/YLKPXm483c3UwoHhrlDO4rpOYvscN9yUP/rjtQBF5hyVYffJJ3
hr73d4S99Tcn+9rFXKmwdTN5VkaalL6khSW7cdU/o5VCxrNkkr2MoqMUwYXYty9B+aXZq/aImW2BMLXzbPfswbVlf/uxZE3Hmw1aMU2DFC5aV7fba2ouZ/ko
j+79CHuMJnctU22OEi5rzXUqWa/IGOZaMWKHNeDd1wZdc/Uyh8VET5NljBiSqlZ9bBFV8KCjnfEvs0c5SqkCJpF3QvKwM3F7tPJs1IpprBHJCRAW+pnOCmcp
UY+V4A++PaEAOnvgIrsATHhAASCrvcj0d0dagi5PA5zMUG2f/xmNM85D0GP1ZDsRRU0p37C41xUwAEyKANsKr1C5OA+PNqvzvycY8hMFybFeeguE0iSCjI1B
7yfDKks/QiofnpHUIYeytltx1YPfwF64OlXA6s/7UGx8dGIQc5FcdzyICxpweriK94mqZzLjqrE+EQUajoRjjiJir62DdCZeeNQtEtYcxy/LrjedKvvPTIxK
WDmMYlJy/CVutWBr6Ly63wh8czO+1rj/3eXowJ0fSE92j5wUUo2ZA46I3cZex1KCB3m1mfvJ21KtU6c0IjxmMdqWenjT+NKxlGD94aDcBmsg+7KmYZw4fYyO
pNZ8E2UnhmhOVTn3FS9n0Gdgf0mfQ1YLs6AyZlhKm5VaqNnD5mDqBlHwUfmRjMlxgb+0ErzIioBf9nA940JIGZRyDYNZ8Cq4UNL7g97eUXEuEKkBQxYNYF0C
pN8NFTwYLmlJ5RntcnsPc5ZxqhNz9OwlIsODn0VjxJcKTMXbzs+38Ou3oTIQ+4jzyFsH408XAC7By93UtEDYfbOSX47HdihwZ5r1Xt/3QfhwIaQAYWJPryGJ
bo5kcxqglVMYbOixmgffMehMugqZZXO3antcVY4+7yMVfop+/Xlj4+TUp4RGqVi6aaTpwUA6CADkJ+lw4ZTDzux3WGO95jVP38vm1CnValFv5EYIsX8aNd9c
9ZKI9B+cqWgx6MWPfdjxBzSNmYXLDqxcbnuJPJLewq+2Le/KBKpmQ4jUjIQ7yzpNI+LnOTyX280leXEq4//6nwO6+vv03H7aAkXsNsZhvND/tiP3ez7S3KDD
Zks7/G3cegcBdR2kYLoxjF/FQv3f11G2NPqBu7BW/tEqaYOJ6TBWIRmvU0gTQPdfrrD6xONYeK0K6DrA/MSils04W+xRQNbT15bJ6miHYzcqz7nm1WIixEsd
SQ0t6rqxfwddkQY0ZIBOLFUJIuzYFJIOiGIxNSaaXkKb28p7fXx5gKNCQIECWACGAECS8lFABAASc0Lxi3gd2AAAAAABYWATHZXd9TNgdTM6ns0ep+v78JFe
bpOMDcF9vbPEUtI6SkzuDahSSQcR37aDYByPalas2XsVTcFVfNfwnOc3wcYa8W0ittyBQDBVPTyzprMKhGg5qPLKBO+N5W0lJC54L14/inbRgFpAQp8cinSr
utkHjvzSaWa+03EpezgMOJ7jgKB99zrTsem4ADAA0W5Dv6MBYwbL55atDkn7j0QATDyJqY0EiF3KUxC8VVEjERTgXZ58TVYix1s21Pn8ecj6zCmITmOJGAAK
J6w5p3D2qIMCgPf5uTyv68coOFPmEB+0y2Sn+R89E/piIcTEUcrIwgQ53/skHMgSKpt2xXmv+H1ite0HDOeXfXzYkeMknwEilPN2eMl1IdUrsSfe4HL4Htf8
00kP2NmUEi+ph4+OEKX2dJ+dEGB4mXUgQOEYcJfgAHBsctr0xHQznCR2WuALa1A//rLA4uht4vbpD1CW+/YAX/Z9zMZt++WmblC41D+OKSL9FhP8KsSqjvKJ
kFJf7E3M5hRuFry/wPbvb/sXcnNeZG342RtiYflsJpfPsOmAoMSlvmA2OOasLHdMdn/Vt88XlVneqGUCa+sKBXNVe+UhTN6pXhu07i/2LuLvOfwKm7psGlqR
215hPjo4jSynRqBURdmDxgGmH5DTyUeZ38pv9+xu/BqHfjNPc1YDDsBlycfqrmAYc2N2cOoCaKzO6UtGogRD2aXeEHs1v4+IwjPf3tDSAKNFz4EDIACGAMCS
8ZEohAAYf2MFr359NdEs0oAAAAADX2ATHas7W2A+mW0tGpdAlaq7bnsYUOQCDSn/BfAllwcuyoFYAqUYMZDBV3tzoBGjv5w0UoZEqiYN426Qzf2ZZEndco+9
aYxt1mjFLlH5eQHNcaXsbpn0y9pfnEyiZCLMx1P7zEdg9T6RKn0f8V7IldqWPj1HOOnvMzNdcgDRwspb56B+RkHlilE9Lvm5mK0/VWRzmLwwx3Ao9SlSroFc
wzG2a5fpTXRFCYIbFPQuKnRIQ/6TGBq5SvAhfgiNRKJhkjd9EZHIC3BrxjchszUXW+0mIMIsD3M8UcfCECIu/rdILgdsMYaj1EhV8d5KtX57/YmgBd5OCSc4
yMrPyb4xYhrkEbNcoOKLGmkdCMvSlgugkyYqJMgD5yolfE5X1zsJgFyAWfP4/JR8e+6NGzhGUztG/bg2Vk5TXyk+4F3TO6EfLNJzecw1KeCnc9XHNrthktCM
tugm/dmi0AO38qdEGXf9W8+dV883PsJeUca9/NsGf2hZ1Ah3NntqXHj+uDGpHuJUTs3xR/nCiw2WHdnz5tcBnxmhWihqZSicfy1uBlNj8EW+70gAfMv+0T0P
npiKqZt5NpChRJkkKVmjK34PwWgE3vvnmCJYIS+epNdxw2gzVsoDHukXqAAuYW7OlUrEpKjFT+7dsIfOQDp+mdJ4y9+0Mb9yevUzM2m6opgde1OlLEwd/Olx
kBsyou2THnP2WEhE6xXcdfE1N1MGDZ0BwP4yFzQoY9hWDhSTGBWGJ2KoJ2NgGYxuJtSCYWY7P2j6Wo/hdg/yc4FlzVPjoabR9Wt+ExHMD27JMM9TCU3QnP1M
Kjvbo6SYd4OFLQuPeQi8k0nGK58T/Z7WEWCzEDIQAxoGsD3Aefwl/G2ejghgQa5IBZLKQFpDjz8rQqIxpgKEf1iEH6suJRB+b1FB/uh9R8ag9BHFBqe82IDM
SVmW/5Jo2kJHHRw/E15zfVkOUmuoFM1GVrSZ5khiMmV774zqkRZt+zu8kFGncTam5veUqAt6qGkZ4kgnNKMdQ3PZtYneK2iD0UfpySj6shSxp2+PiDPoVkey
kjth8bh0GwBpbS8xF4JmA9l2mhJGAqD/z1vgivPm9hYEanZVIo69syIz3d6y7YP4AU7T3pKcKClmHv6cCQg5pDTFYp3/LeH60LqAX/Z/cdJI+lLlJ55Gv1YC
39L1BCdmWFZMINOGqRPB4BHcAyX38dSIgfpZSeIIKah7puRHLc+i69rDHsDi2EcmuOKTfk2dPXBLWUJaTF2ikMl2f0KMTUsEvnorO3TqaKp+evGdyWpACQh1
Ja/ZTwK4i4PLXCjvnwdn/3SLZ2JPdSqAQPtwYOQFiCCLazmyVnBHZcruRzfoaGWSvDeXw3s/bQes+zN6g+lJWCHsdjN6ISo4QfNZmYpRw83KjQzDxoEygUS4
RkDePImTvDKjgcZwlXeCx8RnFJoMgmOs/ZefSu9IxBz6125ptVM7bS1oiYEIcmCrZpWKtNoIOUvSz4VfaUHt5rBx5H1tCjWvhriXgfdcK9sXrWFUYrhHkXz/
FMXJOFOvZJVe5JI9srjxsFLDu81kmhYRnXtmClfys5/mGm1a1Q+Gx6x1FrX7UMWbnkwF4RC0hrjBvFSlPkJ4BXT+cGHEd3SjvCN0cF2rGASgrA+qbmz0Oco1
wHJyhrAsszV6Nr5aGIhlWtTl8jMh62bPbs+s2DsJssRTUulm4W58T9lYKaiwtuxx4dFCK8/kDjV/8KNUP0DZNkjruaE0i5R2uET/zMbps1R4L2fuECUxOBXF
k/B+kih5xGWdLn7UFd4kyHifgct+jlqExOaDpSNZvwu4++wo5W6dy1/+2DoXKBi9LhGdtanPETN2zA9HIPxuflY+/WJzmC573nV4aBdFViPmWcGBdS7GeQaX
3dlVdhym3PYX2DczqB1YreooKcHWCivwRJYiYRLpCPh3RvNlriOgo0KsgQPoAIYAQJLyIUAEABx/kDM8rGAUF30EVEWAAAAAAYxgVW3ZRahp3Zo3TkAPyjzU
btdIRrhupOfX9xMnNNdIFEGHlTWzu/ymg7pfDevNVehy0lA/AgMX09FopDJLAN8ttLKKMZgI9EcdF5ssOqlH7ByEWtSbzjqTdE+EGN5jwE9RkBbZ9LGMsY1Q
+TU3Mu1YR7LLBoW9p2QLUjqwFcQ49uqVhTRdAsmCRi7ytIvaCTH04It3g8ekOMMJBQ4d3CFZvYwPOc07NJOGUBDlyjADIDg5CD5o+GI2S7yOywuVRhHq9A7T
184VsG2S9kagHhSTiMaJTJZULhRdEEgsWrc/HSv7rt5x2G6W8p5NiadHFDW6UgTyxl2Lq6w26HUiPviqMjdxpQ7W6373lf+PRtk8DYxzvgq1y4JFrhTIfs2/
7uFNOOL/NqPhe4BFml2td33cK/2OjZEkyzXdNQKZ3WI/fBkw67+I7QGMXuNrlwMxa7c9OVjO+7o8tiNhZtfJ8lMSeTkFd8dcYSgevlRQkqRKmfAxFygnQPlS
qEEt/sTLvc5bWjtkS9eGzhZMLTxgMhLsu0R8cVbj7iZ+8xLFZXft0y9Cz93gwczJ5z+ol442n6euXS09+S5408ZE6/ACstVzExsOiyAJsYTN/Z4euHMrHODC
6zH2RcqcEVXMgZcnEYZN4rW1nzEhDMwBsv7DdRFbIhVU7ZQSyUrw2a1uU92iom90+YaGj83VfkeRIVOPxdLpjj8BQStCc+Usd8LLBPDCH9CZD8nk+2HsANTR
3TML3DekI50t3xw8HJQwudVcUO29PYwWmfhfckgCgmZjpLjQztU/EyUPxlM4YvDMOCeSW/Fg9Y6O6w3Q7Bn7hhPbMU+PVvmNKWaB7LDD304sTPz27abq+4kE
fjZgAJ0Ao0eJgQSwAIYAQJLxASiEACx/hjM3CK1fTVWwApnelc8yZaF8CoAAAAAERGAbJC3/WJqdfPjI36EoCtUj817sKEMEaeQpBF98/l/oCavqRlLlr1GW
+2xt/NCqeDHY19jU5xPsOkkOWXz2hHIOjdWFvOs7rqje8720ITCvWAY1BXtu9SngZxRQpZEtkgM6W2DgLbGwHzatuGNZ/HRkylFpw8IEGU36nQu07aGgcEtT
jKNFlsagV1P2g93EJ9Ll2ytkY1MJJLZaG5mIUtOezSFUWUKvAh6zRCDo/LWLk3YRkheOJiMhVkhAIJHPFTmh5ZPiWpNeLs5G1U/K3G67guIh4qiw6Kl6yeot
960Tu8t4K7p90SzLBmDvY++JT1kqGtqoSSuyc83QulxXNb4LNTiLOQW/AWI1gafxyEyS+7CZ6bEwDpA/2Nbzf3Ck+zFXGsNxiieWneJYN0BlFrlz3ILPBB6h
x0BnINKDbp1/QrhG9yZ5LQ0Q88vpf7NJMNFvLw9cwoaCdgDBhwJpBeOSpSDqjLnpfKQlGT3d8Pzdotdk3o7Xbxgo48b3pa+IdOqDrjH4ejd3kV3eByOMOYWh
ZL3Wxcd7jArWIBm+ST4ToUaZmjxT7yxd/2ZdeAlfGoahAODN83aK9IBzpEHGTvunpRHrLpL7xZc9pdUw3fJHuN66XupFN1rI0K7jqva0Phj5WZ9KRhn7Cojx
f0KMKd6jBdhAWdP0wtCcOEhdZqI4/i+pkcnCyPXh7KS281lpby2TbMFqfaH2E3syvfy4m59rbsqOw74Ne+8G90bQqJTH6TZmgjqSH5s01JlBTWP5NcQUiOZu
fr3rivZmOuZfPLBmNDQih+c0xJPry8Nue4NrzzTwptHnrVL2ieGPbi21TkB3u9YHdF88sonx4jOM93abkbuaPh9XS/mDZwn6h9MuOGsnuBEd1aQ9kh0Xizuj
yFdjxCDLftx1q1bQVBAWCmQzAPm+gwJKDvEpCdvK7a22kAAvX3eIDPoYTJZMDxJj5h7wgYBUsntPPejFHCttwAENorqiDahxzFvNiCFFKkJZYdvPu7t4dNrv
CVij/DMGRa4G7XBcZafq/ytRdzr/ETRAOBIumyP82Wrbx9l8vnH1aQZD+uFOaJqbEMKdCSDHaWxeV0avYHrH/MWDAPJtd72Ec8c80BzQNYTnim21elkqGU9B
5m7qV2oz2NuFeHUUFucbhTIFFUvFlVGCyC+ReomL1KeaHMEy1hlFAexrCBPmysymSw6zA4XkNOmA/g7kwjPpWdJRgO8ByyWcxqH7b8+I4/VN6nee8ayq3KBE
b5Z4jlQPzML8cTWZ1aLGbfJvPmXBdz6b2Bpxu785FFIi8GcEm8fwptbCRo4LNAJXSX0k7mgInL0ugr+ABsWmV9HEVShu7xTsZGp7KIK73KYAq8wtwjPAzjsF
2HnDYehPqjfLnw2akx96vhv5VwcVcnntrdFNtRX+fsIAS2V1oSWtXrKFwaBHIIwDFs+I8bXJQzXL5BJnUF/9aKsSVQFHtpAbBX7vLcjDZSzuU7MgJQAsaoY7
5BokSWA48NhiiZd3fhK+Z6zVMB8nmD5GN8KFkJdOQiw2bb7S6GxJW19fyGFznh7FiT/NS/wk/Xq/+t0puNE/9nyy/Xhg9eWGvIbtNG+bgRU0hoM7g91z0vDr
IEjlW2b7QNsZyiNquvloh74pWNUEQxFD1aY8bTSnrWheGXctM0II9PCItDglh3Fl7XDxXm1iCgqSkFENgmODGgpg3fJOcAwc3kXIrcY52h7F09TsTziPRLHu
ojv+9kQ3BA6MBjJDQ15Xe/1RFI50n4sb8T72bulaDoynxho4XMKPvq9uPQ5OrUVFXns3C1N0wqFf15ViXWKgxGJGdOVIlJqg7lOi1f5y8ctkX/BFmlUqHP2k
+MM8tFl66fj+Ofj2YRKvKEWsWSi7yJMLs6JELmmOh+FmfE+mrN5/VCojti2pJV52lh5IygZHI9aD9qk8M0OBD12WXC6L9qjklLmBpWenpgnFbOImdixzKD2h
x61jPZcvSwJuspI/qCdXiYZxI5+UBLHE4GRzzOzw7hh2lyynZcFfHSR8zaSWbYyMxxd19bYTA5gqWL1YSkfgUQ16BRgkjKOmkk1reLGwwt96aObG/J29uFiI
Nm+kHX98YMTGFvyOeu0MHPsOr58W7Q+P7k5kF35AsmbzOjwCPNWuffgfcVnB/I3rpAv+hexIrk1HM4tsGFRwfXp+2ZnR4yllidnqmfY3/gGX2XXosatzp/Gz
5GBYqHCVqrPP7FnVIIl/AyTBtake28TAGxapciLu0AImw3fGwuK4n6ZVjZzPUpjYWC2KRiMuIWv8NuG627DBvZuj6q/suoy1KBHmp5beAacfVQDbveU8WvXo
kjm056/6g21Q6C6oo0s51SVz4QGnOGNeN0OnGmCSxMVqF3hpGhs0HvIzpi7fG/jpXbBboc+Q6LFUVteDmCpXVM1jbAw0Lfrovzh//vamTDp4fA3FI28CUS0+
Sw06jkhpZcxunKE2TZd7FFIrbqPNTb9J3fLb6oNSwMN6R2MMNnSeSHUnDFkl1reAo0R8gQV4AIYAQJLyQUAEABxxitAlLB2DcwA9DVRAAAAAAtRgGyRc99c1
vpu3QVsbMaqGc3i2y/KyZm49iwg2iBhTevMLScTIBculOcAQVmLnGRfKD3cXUUnuUO/sDIvExRT8mYkuqB5Q7qP6RWSpGjChG6iXRNN1+IZnvsRvbkOYd+Oz
i1paiYdg5i08v8QfmI/G4FhXms+2AnjWoijyodSiBP63le6z0Y+8SRd941ZJv2yQawycjhjKQlrwKoauK8Se3pkq/sE4V4VHd4QooT66Tr4QFDB5dgrILqtY
Wc8rhIITKY4LZ+HSAKAxGv87aAzHCIovM2HAafBXxcB/9HahCigRRl5Ay4Z/KGmPP3kPos2cLl2K4JWCuKLPC9LAWgu1f63VfjWH6T6EVVqWizczQyAlkwCN
lBG/nfiVkD+NK7pu8NdLxgLlqyVzr3LrVXzcUz7vn2C/rTcVZrOedPGNule/D9QYR6tp0fyoxmiOA6BtuWDfJsuVoEwINADiH1u3itHBucg77QeA8MpqI0SF
qJc+YvSeG5e7FcZmzTfZcqirjJBomvLtjgWM3XkGkolU5rktify3KTtv6+/eksDQDMRWYfobG1UDfM+9euYYl3ImSYaVjWYSd1AA5vKbOVQYN48RxrCJsNSo
EW7xpYF9T9IG2RBSsa3ey/ACYJ85k4TdAXT0GmHFSFTNWeacpWMgwpYNqtSL+dxd96oq5TSe87OesE3sHNP0llwjJqv0RYQx/zwYe24kFI8HTdmAg2frpuhg
8ikjLCYHUhtvZOfGu8vvx1L7RiIKbXZPsz/2Ei/2VitWJWeHOY045scZ0QVDlGBAJGzSRHyd7LMcts7Qa75kylERV4u61/h67+5uXJXtLZSUJuDkS+XE4boz
pN1tR0X/R0Z/DiJJ4yBKDSy6PpnTlTw0cRmPTiI8IZphVBOSyIjNdxPn9F9o1XmVzY+vXw4UlnBVsZU/mi8dTzCfQbO9JKtpP69dNfv7UTiBYTQaY7QgX/zl
1bVyoA8J7xEz+p32I7ItrAMt+lyRZGJ7sfb+gPByPtfeW1qGSU6r0xdd6xQq0xQOtJBmJf2LNzgze50wjn0NCAAJfYyIZuOgukTJbdYkD+9UJxyt6Zg0dKIs
0+ang0lZXnKUqdLv2JxHY+wum9g957cVZb+mD6F1/1RGtXfIpnZeeL80NOlSCod2EGBDLCA4zxJhmvrnvwzgilVcZuj9A+ipdsKOm1Y2V8eu16mfbRyIDgA/
DFTrR6dvEN4YfZlri2rjbO3tFfsQZ2SpTPbKV0eoQe4fsWROruzpmPf1DhoI8v+eGMNFwrdbPsq/G2ha+uZW0KwS2tjun3xYaEfzrEBSs9VKh4CL4bKf8VZR
yNj9gKkQ7EpRoKQlm06uIDYPQ5yBXvFV8ZXuP5WfspNZS5bOCv9NnWqWbUFMBTEnHhJYByMrJWRRqhyV4843hyKhlItcUeUclYhbKwNj4+OMRJiZRdXr0qYO
xW8OeUNQZeoayhUU/qYevm/DEwEstOLWBTjbiYCjSHeBBkAAhgBAkvEBO4QATHwPdKe3vn3tX8YLL0vCCitlV/gp2aqtfDTX6fIP3es+L0JKSwAAAAAGGmAb
JKEU6uZ8Nk7YRMnJ8PS9nxB1+gpTEmpaYl69uMcix4K5naMb6ZDpgGU/kkjeAhctG04wSkLOd5XknLZSjdeiVJyMybszE40GRMPo6ntx7+bjiJdD0G/08c03
settxOirpcINJpNwbbtgWABphcoMU6b68iHn8nggQad7A3NVtiU099udweycizAfNesA/xF2bxFzbq0cb8QCcR4BToT+1DMCtlzM3iZl57eKMs7JtsgwwTDa
UQjodY5PQQ3ykesqtmK9C7ySLOMBz/OPh85Xq6zvTHp8cHYkdgJE7YvLej765buTO3TZy5cTxy0qtEy7aJDq+jjiV/MwiOUWxQoUUi1xy/JZevvdJKaur0sB
TfbEYIQpibHWiE0VcBcdca06aCMgH5Nrq7qsGISzwO6zjo0mNFQ3MKHI3QB8bpqYHfv38bM45D4Ka/6sgIURaGRHre8zy8mc6Lq3xyQ5kb1SicIafMCzqCbD
S7zHmEuFyspvnutTjidBAdPSFqYlCWZOHK69Hnz0NskdeQ+lbxwjna5Tg2mCMJLEWqNPR14HWos6OxzUPKWg7VMAJ/D5C/s88/kW23h07/4RoobHAx22qWHh
IiELeEtbvKRzx5Yy+vkFL1cN+CMJmyy9579eCaWchHX/dVtsC3fbPp0P0bzsKq/t4SNd/x7Da1otHEQAkopwWfll/bi7j+yNZWWHvPD33TGqKq2+KMx7ylVY
KaqtA9/WSGViOSipmxnGR4e3MPajonmDNMa/0b4n1Ma92BFxB/F4M56NybP6tBtsUZhDF/+F7PqVEBaidgyNAlCPi0aDZRaBSmDqVIqzwUVJJNL1j4iobuwf
YR4mbGnkfZBACHiPPtqdFRzQW7+AvwTaqr7ZfnojFUXIE0afqhtKAZOp+dHJE74ZesLADv8GWQONfz57NALYWCFXJ7zG/tbtqMoe2uwd6lo9Wn6tdZV9Qo9G
uMyJheGomiqADho9+28BvGltuAL/+SCp+RBWdz7DquiijKxKseFCPrqQ6YnFCJQV6VztAH7oom3qNHT2SrZM4/VlzL9UQFYAZ3XaisWrxarayT4xwRIVQeos
z5wmDqHKUgxyuwxG6fgZHrncgmT2NoEtCs3K76cWKamW5k2XXN8lX6IHzNa6yc6Rq0RNJ0al6TKzPNTnEd+o+43BTGWlvBVDgRuhJI+jrhO612IPzHpdNz2O
7SAFinwv90IlmXTWXcTf5h51Vz1Rm02zGgkU6ofeLeTHHAfFmtT+9Mp1FXAxvgXAvbnYrXxr8mCcVf85cDujKji1MKm8eVk0n9iWr4BfoJe8ZtwqeU2af8Ba
oO/Lu2bPXSt6YtXJGoAlkzniugFYrDrpw1a6RUit4s+Qs6rvG8jMxltCFYqvc2ZN5qWTmMbxu1Li/tHtQi0fSceRnjlpX7DUxsIP3QhzSp2rU92r5lru6uvp
qgXmv3DhlfGV208SDttqIaptUqZs7FeWpNhSYwQtNuOlmRQicI7P4XltBM9IlpVH7dft/VOPi2E61AJf29LL1E7jIgDENd6Qm7LvgwXFyROvJEGJXzoEHBAI
DcaBdVnlgmJS8VCsljDQEwKnZYeWU2adqF/r/ZK2EJ4JnxUwFdgRlVfWxeMCA933PVgJvYpc+bCHOpB+K8/uZ1YP4IpyWrHYFOCjOeI/vqC+X4lzyFyR5Ztr
xcLdFk97m3QmSL4pzHxIFl8Dm+xdwYFuyXhK3B6jgR3tBR0l9nLRYJPpn6FI18o+QPr7nauojQjS6l19Kd9Zn5+fEKVAqZQcIG4sstPOdZ95Wza2ZDakdxin
LnWHXfiV1Xrvdwy9DwCQ/45qIk52FVKoJw/1MV8V+q+5v8RTHUae4nXwLaqwrRd72qB14TH7t8AUisfENAB0GcyGlHnhwa+IIOmSMjqo1jnqVSXBYW8yl46q
gnAMwTHNj1CKI8H3fqn4HG5xdeb1u0vC49aaEiD5RkHpgiBJqJ8Z96UYltwWmJthsRyjUdqXx5J6vOjm/pfOOMRHu73k/jmk2ckvWKukV8s9iKyDnOe4ITEf
BgAOaqhekVFEOb/54AqQ+gT5t3/nuiH8eRbnTkqmX/zmUoJ/8tpWfAqf3Ig06pByoammfOpJRiV2gRw4wUVxyc3T0urK/o83KXAJAZ/PLcLdIBUytdBoupZU
L55OOy6oWHdJuTh5EuNXwe+Hdx8WMEYjab2ieI+W5MjPS8j/9tPBkdvyz69tTgabiZ1Ku2k9YjvljNIoX0vm0QlPM0UMWv7H+WtGA6FfIpBNE3ZKuf4dkIxf
FgBl6g1SKsjAYk4UbUYCGqkACPuUAZChfMH790CshkIVybn86qc4duL0KsTIsXlQozpQwCiy9frf7DlGb//wK9e0m1Pv4HC9d+AtZMKEKkH4nimqd0GmE+UP
PGsLNoZYpJewHNyPndIPfg5z0R5ffZp20sQFIMO5oPkKzlPrU6k+H9A+5a9pOpEZNF+dxVIl8ditGvjL9koMYGn8sGihOpiczhvJ+1+G3HSarMIN3kRDd4Lv
+eEMvzUwSU/woirRDK/bKIPfGMonJA7dEe8kdakt/3FQzJn7dMuR1uhcdZFQ8hOnVTwXwQjC1ur2goUbbCzUepbS2dJ41FIfSU+x3brygU0NugtuWMmSzb7I
I2ykFoU1Rx5aXu6MKRPf643DDMN4cfH0XVDgmFuRbyeydYZw6uiv328HlyUprhSrM2xPpUzIE3Nbq1ifd+n1DsgI95Jsz6E+5ZKrKPXowXZu1NIX+ZZ803HB
sWAbc+Zm1DPvn5bC4+sM5HojGUXgmfTbtsbQq6MJ5GDqQfRdwDoAo0dWgQcIAIYAQJLxUUAEABp/RaFvdAAIWyZtMwAAAAAF5GAeGmrLQAJDAFEYW0HiF0UA
rwqfeZViulbAmcoE0Tq81Q8zgz+Y1ppI2VhzO6DeZEABLSBF+c4tKYkvQWd81spotqvHhhOxn0SOHYF4QhZZb5NoxqYwKC7Tz6+EFspKT4AgkfLAsQjvvTeN
0+nuqlzOOI4aquPP4/AzXu51c5/RArXq0PmD9qJjHAqN8tcZvcqpPgZX2/ic17A1yaMzsmZnJPICOREbkGsuH/AHdzOxXM7VA3fpBVmc50n3XnfDi1aupbVO
3HCFTAazVBux+x4RXi/bu8q4V+yLfoGDdOlbr+JAfN671z5V9FgpyxJE+CMlDSij0xeP9QLVZhanEjw9Z0UfVkUBXfRmoBCRN6PzlWWFb12Z5RAorZaAsdlq
K7rYV34yrS1KGQPH88EhuBd61ujz01vgGoWZvKldAeCvOV1Nz8DcBrhxi2L7pwukWEUIChb0siGG0nQWn6EVckQRYhgIaemIjadk6WNV54ccUY4kFWvUiJvW
RFHhxxvk9B45qqEmlpYHirbueV6pijnFkphp7cAJVn/yrxizQ18vngjpbP6VvGz7t9ufxz0X4sBaLsb68MvVy25c6RX+V63S2fksFxoD79CCtepAHbEe7B6W
GphPqejH+7kg6cBzKcUTRTil/Fa0V1AyRdKfsqRx0XmmYZsk4LKpcPFrzX8Mp9G3i+i3jgqlmCJ2qG7yg4rKnZgh151qHMca9u205IRQtMMI9+RJFxCVGPZr
VGbuV3cVPBsJ5xWwDknE6JVL9TMqk4ubvT70v1VKsOxILw+1yV7efFo1s7A/YNHVwvF/muRE/U2CZboIijKEKuqEF1msuOCmwLaNoMl+U9/2wM0g+oEdWbRi
v2YyNEMzuRhak6kXMBlTNoqAGpVIdMww557eqC6hl71jXioWM/aHhDS2AT7Lm88P+7kJzybOWm2EV45HyL962KR/hyHTs36DzwZ4+Nz0u5GxkkyD7RhlynpI
ACURF1h3xfP3dAIhcBN21NqB426QjI1eHvAssilR3pa+AAMvN0bNpLQn8ELsPmdpo3MQPG6QkgqrcY2XS24JwVwMQa4jrkWvzbdxh7ADbRP0zpoqucfL4kN4
aoPRcOPPhV9QBcxMmQ6DroEld/W9QMxOjj+qQIwtpyAvYt18dDxWAM4e17VTG6RRnXBDVRunMnIKBD25EjyimUeTHFJVBySso1iMj5OILZOmUSA0j581J5Fu
jXNjwWgU8+jkdOuovSeqTw3uu2YAcHbEeoelBN6F1x1ionIs9jX0l9zlDyVIibF1RPx+AVAhJLpz/ElQTgGYA/iGZyjNbNcnNSk8iIGXBGOGHfc448ovFTqw
Y+JsmfYHvxYZFpA9P73tN8/GHr6yvukljc42kGNDf6ngBpINcfQlqxz9IZPws+rJRwcpNYKF/H03OefnEVLXUS6O4iMOUeA3t6tzDZHB3R74D77VUYvIZYAm
D2VX6ROqc7jwO7op9ig9qzy4WVp4yovEbLkOo6m8fdYvr0eLLHCNs0fuyHRIzIVUgHvT9pFh/gd52QfeLKtITFUfQb3OnKzgqR63j1EsmYYRSZFnMG11IaW9
bBWNtHXP0rpQIjMVRJ9qzt8wxliPw6KfJm4hhPRzIaQPk660SmiKSCvlU6FeyxbKFa6S5xbFYzbXs9at4Fx95i5qlQ7J+NbKZmVFvdgQAMSYVlj46Cam+vuy
RkzbadP6qJixO5yyciz844QgG+aRQEh8wzS0nBuUGkslLNmwJIqvFbVj94gE+5sTbJ8eT//sSebeA/ARqO8Gm/dqL+Z/RrzmoNAJsdS8BxgKBkPf582yJuO/
QoIE53uiCl0/MASn/o5LGjMJfIymEP+2DblZMc7hoXTJVjncSA2qjvYkgiM2ioSU2FuxEB+Q06rkA8GfmsQOLww+JS5YUDACOqSOp7tSE0EA7f6uZfRazg1K
mZpAvqD8c8LeLirMyRU+dwjfGRqhjZMqyn9Y3eiBxctG1Z5iPyt94d66QRyp6AoHHVwAX/H9/7ZffOE8H3oauBdiK3b8fL5/FUd/AOcA9unwHrF6Y7hOoI3L
Hl4hN5HeG0elhaA0ADrj6wlBqUyRJ4CNHb5MSvl5fODETkun23cXSpvUSteTjcw4ZLL0DcYC6KUTbs9w9veSasAgKkUz/hNDfpQ/e8Emu6yNtAAf3j+EjsTk
Y0QKsaQJ5snDlcOhX+Dy3HAgfFZjRmh94aoUoQmQRUWRNwql6f1dSHYjLxXbOtn8ylyJYningZVfS6L4VbX8AD6UXoveFlcHFMA1hM+UN+QE8wcoVVshfG1W
Uyym7OD7IFxJYO+9C3E9TwYNi+OuIDrvqHVcSJoPOHoYGXiJpz8Xxpc1o4K9K7thqTfaPlrQGC2Q87NrbjGa5ay1IKevp5nRVZREKf6fV5styBSMdtFYHj6s
UWBs7gowSiSYQ+M4JQII98/LWq+RbuBHtmLDhGgAo0jGgQfQAIYAQJLxETUEAEx8rvy4EuqP7B1Yo1uautFaOnh8AwBl9y6zLIsfYvCVaHFsU6xgAAAABtRg
IHbihYa1SydZJlmKSxnBnWfTF5RJRAKYvU7igNeDWLrM90UIUP8KhWBWB1XpxcOfqwqlpF+t6tyho+N5MDE090s9IfYzgWwcerZjxWbm2akCODp3LUGUmQwY
3XCuGPZeYdmBXpwVt8KH+fdcpBSRQjUBHx+AdYranAsXTUYQFTe1GXI55OyJbL2wDsQpD5fWizW0SnmkB7DfDAcNrsJPDNzcRc1saG5MLUlVSce3NmxhSq0O
EaA2Uf6/h4gJxayRrIKA73RLalHQ9hDq/VGiQF5iBmGXTY86DEtyL2T9XLvsU/d5yIe6wKdzmZLLQRnNn9wA3H8bvGO438G26wCnb8hTq+sH2oTbXftRl/kq
1R/BGWUXjWCkxtGkvFx+jCURKMDnN+Bw8pLvjKJnvpNn82KMAljnAnSerTwjavrphaVsq0Iw5BpIOZofxnt0OydV9cpgWNIGzy8lpGHqzPW1Ffhv76z251WD
iSbPoBsLr8NYvE02qpvJZrNg7w1Vb5TtEwpotKBMekt+uArrhV254k91lte25U7OY3Lsxmc5FwTVCpdGxvR71Yn2VTE5Nx1UgpshnoNCFvcNMmOS3CCfaquE
/iPwPbsdeqxdcsurzD7MpW84AoJZVqRygukQYiuD1tl00jbe4+EZS7tUK65GWlGb0au5P5N0b7cQ8U2RI3t3y7FRhGcAVpuMjZSzVi4x0yq57G79NWxQkO6n
nyT5uUwq6NhHp2lJbpxOYQKupohqYVXwfLpRuarcYd/MMnVVuVzYPIbb3u5KKuTaWGhdmLelnoB14gCZ1BXmdxD8TRnhJXmd/kEaWI2pznfuUhWe9U1TNJaF
A6aRbV8JxpB1okdKu+wK2qPQM0wVHtgBvhuVZmK5A6GsHjB9mGVGfNoZ2jfqXYQpTvNcWne+xEw4Ob1YT67BKMYZzexoqKgcVCqi83AqJiRGF3PLDoDblolB
F2CeSZekUtuUCRKVjoFiM9AAlpVxBnSxh5yooeTmogOyzhkxagrv2bYsjozNaFcz8LvkR06pOqrN0xPwg68ykhi5lhKUwYcEijRk7ipo5vIWnhurmtGzhfFe
Ao8CovBcHgc0WWZwLbPhPDgrINoVMEq3LYfB98GZ0dnJueCgTFnwDjZvpxiw+t7tQS7m6qfQODYL7XT1v+yk42OMaAPBwXStkD3Bg5ZRJJHuQ+VjEdjgNHHX
0w7mVFQOkrn78x3JQsXugkfDLoR58QHWWnPnBfKR72Ykhmx/YTIy3EX87GDKHb7Ec4q/IU0FKUEQYVuEOHxs4A9ZxgsYgvHg0PGxnP6aDzm1awzJyO4puJVb
Oj9e0vAt2zUPwj5xslcNiJHsvLsKH17DUSaLPgfWif6eyWweVCEwVoqO1A9DboWY9iGb7ArQhY5kLyQsLNN5Eqpd5AoBaIBbRYZjbBUnNs5kYYpTGr04EqTA
1fwYXxBa6wlnA8639O7QgYirCbMziQiAwjeUB4XsSR5VXdL1vOxWqX3+znxMJzHV5DrOPXn6y4gsdHX916R9TItyzPvOIl99F5dUxXqgUnnazFPwGSO44Sww
dD86Sk2Rbab4i2HVOrcB3a1TvHYYp68J8FMeJSyoeUl1EkcDJUYIr2lz0d8Pdc+B9g1IKXNhy1g6OQ9o7qSyIWVWwp5iYic3FM0ZmnG82CDqCLCR3rvkxThL
TZT8RhbsSMCrb2xQ/sSf8vPBU5ycG2zQEmog9zupFKoxh48QEGuKefn2JHm1iHv5cA9TPLkyhgZBpOIObdVn27lN3WMeqW6PjXGgy8K/rmdNL7dYYDZcIGb2
IF7Q9YXn4JvHdcW+igJsnXCB8CKZVe7M8S/XQcZiGOttkGqRmPe2NaS1d2PdR72uT81JViwG2lC3XYLCP8FJjdyUk1e3J7cdWEpOSlZQkM73wSOI9BY1Mhdf
uh6xq+PHRrISRVS4EE/1zRIryoHY9k3vkpzPzgPVlqqkR5f+wvK75Agx941OVOuztgTG9DMop7PuOqAspP0ICmayh9puPV52qNU9vEwv9gP1s2AfwsJLY7wO
Y93yYNrbL9AklyX3v65+zrInwp6VyD8hC4dSRCeOCLCaBXpw0/Kzt29f7fs8cFQTdmDBvx6pVOJ0lPpZoFq1YjMfh2oYwNb3PVk9JPp0yXkG7m9FzP8VZd5u
q9aLESMzCeZcgOlNOqXQJeJzX+M6dxPiuiXUjQ6hRE1v4aO6SwNVzCUK0xuhPm5jDYHAhE1DU1L745zmKLwKbYDs/89SIPE1g9wY8Cl2LzhrTR5otWrADTNP
KZODR4zFYBfS32AqQu1gxIYpG7TqB0vUC92vPq4CBOMG3Vv2kF/9e7AX6x/d6l6IHAzd90/3GosHP7DJRwlbusL4rJD+KNikNP4ngI8sepSg6C658qmtlbru
pTNF2cV2rArAQctWzr8iZKG9GeAn8FrcNvbVVmDe/tDk8AXhfYUXc6h192JDq+BHlY/IUwAy2+LR4fzXCM3D9qPYdlGwKTDjYc/EdNSsWxsLjbSz5HKqV2k1
USwV5fbAgZqafVwV7z9DPaNiEC6GkSjdNQcCSIs36KyGDiOALbU8pQSKDkLUakpwbSs1wto8gQtAIjYte0bj+C8EkUOI9CCiqZ6h22je126VQJuO0OII+a46
lastpoAWCR9k/6CQQq8NQwBC62tU0Bxu9QUonxQ4uEcEx5yrlCpxtAoKrmZ9wNcRDAWFIqcZmkgjqCGwrylD9wV/XzLCpAKF12VmZtMiDxreCADTbH5NnJq3
UNqwzFArbHhiICr2V6/tAaTBBnCuiNDn86lyLLv1IY5lnQJYVjx/ClxcWxCsILxCMbh+sWWgwMkaUCIfCfuqhv/F5IOi/ubmo/B24/BbuSUz0W81jv6j2NuK
ZpJC/sBkl600x3hc1IzVuBX2WlCpCcj/0/zmUoCjRLOBCJgAhgBAkvHhQAQADHZ3gAAAAAAAA2JgIHb6Qy8vSEingX7V7jbAcWSW1vJPn6FXDIWSwJc/iMLt
6c+HI7vsISnNqODIhGOj6XrcOLvbFaLc6r/zwGCNS8L8zlD15T0BrC8G2TrUIT9tREL9JUE4aeq1oMOUWCwyIHFiKrS1xNOZ94XUuU/ivQl8IcgHBER2YOKn
wkE/9qhqlS8AI8HynW7ivzAjtcYIDjPgDyMMk37hmda//Xu8jTPfk/uLQre2VU3QR7TzvzPQciqjUEi+UNqcbmoESTvQSi9KAHA4w1omOfLq7nTaouUtMafo
EGlzA47CBwgdyk2gskv0YLhG/uz6/dlE56DPWWS1Fq/hM59eBS78ZsPgPF7n27PT9Hla/aVyRs53JAbF5/AoVGlgXWRV4rx4tgWhLwxeHB2Cqh1U+rCe/Cdd
rQWo3kyPUhjuma6sGwZnbOPEQcfXGy7prKGB1g0kveCKNych79FxXB4ER9yGDmquO0zuMhGTcFkF9GPi3z2Oy+TewES73rQTVvIzqDdrk7ztunLTX46cpXwh
/708yY5uG/Tz/TknOCS/LcmDkwptkx+mTt3Kc199RX73fy8oNO5xkZ17sImBqva0dmV5iCOmg5zsmdHDaww8oX5JPvMwDrXXNA1M3VbEFpgipqZt3HHuTrNp
ChFOkSIag7dMVW6UI2WVFXWEbCiciNs1ki9sG/oy69Q4WHt7DJSQI3ucAZI9DVRUsEOrhkKRqiCB2gEalzVq+zrv0TM7H8nlquga5vmph5BHoXWs/Jxnl0Gp
ywtNyK0S0q3EZl26zLnHukhjBUvJUFHlwMEoHXgBRO9fuKHJ2XILwNDTiC/q+PQ01pY2SOzjR5t2rRz/xfx4792oB/NNTcyOCCdnoMDvEnm9K+ICSDzxuX0X
PI3/t1qWi00F5CvT6H6T5WCLIAZVwh2MQfogpYtR5e6OXy2oEuOmvJ0mkMzN/GrbJAfgyKhdbY4ZS++NJevju9PL6KmTeUYYtKeGzwRFhoKaF1jJ17r332nm
LL7HbI2tBxjr9FjjoxP/QtO3PGemrH7c0I202fKx5GMTM+sATk/xNS5/0csAi2fxnW5q+DQ4lqlZX8EpD8HxYe1YRmNUmPMBAnHoHyb4jwuEEWHozrqrzKKn
IZlKatyeOVdbXYj2BnkHRPklkOKU7l/85gczAO1I60+WkYVd+x56M4BALdEcdDf9H/0eSpJ4DXCVfBcBUzmuZ1fKXsJD5Q9usg7/4U2bM1GDsaW1ZqrWQ6lr
ccMniQ7LSGRGaWvkQtRECyPgxs1YyfVvs5qIlJJ57RQjb93wmHlrN5YVd9m4HRi5ruTETLM/wl3v2uoX+PtmnpFeRF+gcyY/fcC4lQCZ/wN0uYNefREneuU6
1+ZD4BnfApOOLz+MfpDGWyWJLXQEhfBzJJ+K4ip/MqFtQzQFfgL2EeARbCX3231mNyEelK8D4xsKOsc2w2HcRNR6bHcQ+60suEwIJcOypubMp4EIVO4XGzDq
BlaxQzzILhjmoXdGQFcpn/aMKqecR6QToJn/7uEn+66CaLxkjkiocI+9JAw5mOPpBq1oOm5U2+WECRKS54aw42yjRGWBCWAAhgBAkvJRO4QACnBhUAAAAAAD
BV5A6oiUh+z3tKf1I9VVAXF4nMHyEvgc/f3q6lx7i0gL4xFRco9ZfTzcOTrxupXTLG6S8DQU35VLHgv4v92/6Yb1MfIc7ilNqAKhWDpnPlcFP9h3lKilxpWg
8LUEPZhPFFCbwmPvkl5lK36fanmkcy2twYDFtlJAz0UM/BYD0YQdd9o52KMr7vBUq0a8deI4Ldk1GSVQHAspM2oQ+XgGJvvGELf0FCUfQFDnl8EimGrHOQrZ
Pl7iJ9mN/EIP3G/6ZZbycJ3wAQl0JPYAIcvkGH7vSwHe07sn77zz1q7u+Gbc+UgNM4EHpsHTqAHB0ulrxTVRsIKLiBwxMHyx/KW6AqaBYVHIvDgiBsra1cz2
rQ647Fo6P0IbZIgjqQuog2zwuwkkC+D37iDkjQOansTmMrnLFLLHlH+6l3MNWFXrnphnsIDhQGx93xBA/BHvGmOYbH7R2ZPlQhuZphBdLxjdLQRuhbT3BBkC
5o2LLa7bGmHH6Us81jBeqkq7C0Q9JEqoJ7zsid7U2+7aAJpNjkRDqmSf2HKGaem7VXn5gaX0iGbSNVEA2IJYzBa1t5W1kO8gdjf7QLQdi+wBJ9dyaF5cElyg
TvPzbDRLFh9nRh2bi8RDRy7CeUPiZMr6DPWWn+QaK1A3tMdpIu+hDCdGyfW8FPZ62QE4bDYfwCtgS4Mb1CiUw0Z7KH0NMW9hDq05DPAtHMZt1ggDxWqHUq+A
UVlqBRxXUCXOGDFvbrakgOLX/luxb1vDofv8YeUAoMvLp0IqIUlKgn4N/lY+xlIjKm3V2tNkm5+2j0Vq31cIJa0Fv0p5FWmiz+HUfkoWC8akNzuJTJjTdrrU
o8UDjP3856ZMsRXG2O2onTihu0ZiugxJRK/uaOQ9t7l/quEPrKE+GK1cdp7CI1ZtNMZfTfQFLswQw0QBKcFJgGkzU6iZAA5AyL7yzEO0+SYlVynIqw/QNYzz
tWl7p+67N6MKAa+RHWkvjLBPM6nmbTJ37ZS6N/4UKNJEmK96UVB6zLiZU2zcvEnvB2bEoqkIXiSfD08ifKYqiODRjE1FfinxeZdFCvJTHc80EzGBlJektJcU
sYnyCAeNfib4jZi2amFFxjQvjO5no1qF+O3dwNMjo1hKEBw8fSPEqxdT5qSOKdiemWOkAQPvi1WPIFF8rr4jX20AGRmhj0cNnrDq2wtrc2z2SFJLRna9pv7x
WTQS+Yp0Kp8d/E0PLSaGWGBpWVki6Qt0sn3qQSgebI3DIpI46lTFAR751ctAJM8+1ip4SGQmIsR88y3BTxgmiGVUqYJQ/OtfmW6IIigYvr2r1r3VRgGm/FYt
e8h6hur/SMRfSoGdxVqTpyLgqrlMFQSaCoFZMavEMYmA6ZMPh1LZfWFyUaF0Ekf03f/wgvP+Z63DsQ7l7fZXk454Q1uCo1vajSo06dD+aTh6ijgnnI0YX8Gp
R0PA9/jDip/fAsiGNyHkWBnsTgpCXHijQt6BCigAhgBAkvJhQAQABnAAAAAAAcFeP7ISl7I2FT0n939QbNGvNlMSQzRAcXxaLPLxCFhlVbxQekIu+8INFQZ/
KQyymy2jWesjBT0wR8GVnvnezQzAXkClPVm8T1ce4t51cD67T3rPfBQ2U69OZPJBn/xWVAGv/uy9CZ8MUux1j8gHgs2xeAG/PU3fCqs4yMNJny9wsUqeLHAY
wpqtvmvoYHhwHwg8XqeD3q2jIsy55pXmqEqMW4mOO3eTOYDUbWEPpWNbjzdsFJccjqxQKG+w+AbIymy6tp0N7TX6Dt4S2DhshfS0EBDXtGrqdTSbxljs5j75
pnmnx+1tLo4Kx9aeuAmVI+CVy0Se3P3cjkxMwpQFbD6iZkifKtOo3t8J7BdESFm7Px5jQNyj6XvFTibwTpC3KgWpEHN3/EcQmsRrHbR8PjviWexxM/qNxqZw
wdW0tsapwRtWPCEVrgJS0g6uAe+B2aysA8u9h6zqqUOAodQi/tNL6V+wgfvFbl72aj/sHwNUHjvRpqLaX1CujmjNSbrWA6/DLzu5wfhhy0jPeyVl/CgFQU6s
fWr/I157S3rv/CHn7zG+uCNq84s9aUgF8UZ/vW4Fbu+5ph+KSGWmGGvfH1bAAF4jp9jm3H/KaAyeqfq2jJchl280fV2hz3CQo2qwC7ZfYCwdum7k4IuTve6M
9iGd8UdSrI52HhgnzY4HWueLv2D2oyekSE9LFQ6HDqSBb0xQ2/JHXHePe9YfdCDgJHtpPSwnjlp8wCL5A4Ewj/ZchVinvi3WtHnVZZ31Wvdsic2iIVmbQZD4
wG+/Dq7dxTWG2Z2eBQ4TjI7fdWJ5/6yREQKSDZrTqdvMNzLh5/U6qg5uXJ4EjmjPJ2FQgBYqt2Os+qKYtS1uLdrZau9im813JBoen6YsrCEaF1n4sAnlH6EL
i4ACBkpd5ptcPTlmGIJmeX624WwmwnqriQ3ke9f+Z5ZQPcdSLbJLjKNCSIEK8ACGAMCS8UEohAAUcM3fp0QNx+3QAAAAATE4HxxaU5au3StgVjCkmjnVg+Cc
JFKcAiiyUUmmzYHAABj1i9FnH1zsbctopNvtPIXyoUZqCNPYwMzRNDbMtQJ/e7BJd+q2dIpmr6fL4o4XYFHNV93D/plfn7XgwL3ss/oJpwR818UBqrDeiLxk
aAHExS778ExGYWY5YBhQcvDZ7SCV7uAeDEiC+aNzFOnZZ/+CGZ1ikdG0Cf5ZiUXDbyu41uSlBnp6BxH5GTH6cF5dZs4982/0SNQ9MXoLFKcj3f+UZgpGUSMy
zXp+fMej8U+9ivqL4I+xalERJ45KGm0zLxUqGqx4bdfbQgmFWtruIlKuBOc1vPk+xwWAC7kjHNUaQ/sf+H7OQhfGf6JXd0adZVLxymd5hdPX4s41/byjeTYd
nlm7CsUfZAc/UPKGQN1U4DfUHA1ExaDGgXvmrXSithfMVcaH5jvIyjvocrZtEPDLcfvKZ5VDCu5Q23a6jJOlgXpLmaCxguQ7yfNCvQqKnxyAizMxqtrpjZ/x
XrKQn1O/ZwioQY3t9Fw7yw9o2RqJaRF2cEwyKTkG2twOAmiHQ3zyu34tP9zxorlDLD3ZOmWxU87ET1RDRHP4htcei5RqlL2ZM5tOmRCp1z9wCtAj/dUy2prd
s2J3xa39XShA7lCs2ZoLp4FcO95QavdUfdmej1qoR1M6c4fur8zeYwf84/Ff2ArVGJOLf/nWfKc0QN+2ws0FlWsR4KEYzD1x7o089wWsfipdcAiBLYWYHFO7
a5G7j7OBALeK94EB8YIBb/CBAw=="></video>
<p>object color solid at 5nm interval; this zonohedron has 81
generators</p>
</div>
<p>In this figure, the black dot is the <em>black point</em> [0,0,0].
The white dot is the <em>white point</em>, i.e.the column sums of the
generating matrix.</p>
<p><br><br></p>
</div>
<div id="future-work" class="section level1">
<h1>Future Work</h1>
<p>Here are a few possible improvements and additions.</p>
<p><strong>export</strong><br />
There should be a way to export a zonohedron as a quadrilateral mesh in
some standard format(s). DONE. Version 0.5-0 adds
<code>as.mesh3d().zonohedron()</code>, which is derived from
<code>rgl::as.mesh3d()</code>.</p>
<p><strong>vignettes</strong><br />
There should be more vignettes. One idea is to show ways to examine
individual hyperplanes and facets of a zonohedron. Another idea is to
display some interesting Minkowski sums of a few classic zonohedra.</p>
<p><br><br></p>
</div>
<div id="references" class="section level1">
<h1>References</h1>
<div id="refs" class="references csl-bib-body">
<div id="ref-Centore2013" class="csl-entry">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">CENTORE, Paul. A zonohedral approach to optimal
colours. <em>Color Research &amp; Application</em> [online]. 2013,
<strong>38</strong>(2), 110119. Available at:doi:<a href="https://doi.org/10.1002/col.20713">10.1002/col.20713</a></div>
</div>
<div id="ref-Chilton1963" class="csl-entry">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">CHILTON, B. L. and COXETER, H. S. M. Polar
zonohedra. <em>The American Mathematical Monthly</em> [online]. 1963,
<strong>70</strong>(9), 946951 [accessed.2022-05-27]. ISSN00029890,
19300972. Available at:<a href="https://doi.org/10.2307/2313051">https://doi.org/10.2307/2313051</a></div>
</div>
<div id="ref-logger" class="csl-entry">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">DARCZI, Gergely. <em>Logger: A lightweight,
modern and flexible logging utility</em> [online]. 2021. Available
at:<a href="https://cran.r-project.org/package=logger">https://cran.r-project.org/package=logger</a></div>
</div>
<div id="ref-rgl" class="csl-entry">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">DUNCAN MURDOCH, et. al. <em>Rgl: 3D
visualization using OpenGL</em> [online]. 2022. Available at:<a href="https://cran.r-project.org/package=rgl">https://cran.r-project.org/package=rgl</a></div>
</div>
<div id="ref-Eppstein" class="csl-entry">
<div class="csl-left-margin">[5] </div><div class="csl-right-inline">EPPSTEIN, David. <em><span class="nocase">Zonohedra and Zonotopes</span></em> [online]. Available
at:<a href="https://www.ics.uci.edu/~eppstein/junkyard/ukraine/ukraine.html">https://www.ics.uci.edu/~eppstein/junkyard/ukraine/ukraine.html</a>.
[Online; accessed 26-May-2023]</div>
</div>
<div id="ref-Heckbert1985" class="csl-entry">
<div class="csl-left-margin">[6] </div><div class="csl-right-inline">HECKBERT, Paul. <span class="nocase">An
Efficient Algorithm for Generating Zonohedra</span>. <em>3-D Technical
Memo 11, Computer Graphics Lab, New York Institute of Technology</em>.
24 February 1985. </div>
</div>
<div id="ref-microbenchmark" class="csl-entry">
<div class="csl-left-margin">[7] </div><div class="csl-right-inline">OLAF MERSMANN, Rainer Hurling, Claudia
Beleites. <em>Microbenchmark: Accurate timing functions</em> [online].
2018. Available at:<a href="https://cran.r-project.org/package=microbenchmark">https://cran.r-project.org/package=microbenchmark</a></div>
</div>
<div id="ref-uniqueAtomMat" class="csl-entry">
<div class="csl-left-margin">[8] </div><div class="csl-right-inline">QU,
Long. <em>uniqueAtomMat: Finding unique or duplicated rows or columns
for atomic matrices</em> [online]. 2019. Available at:<a href="https://github.com/cran/uniqueAtomMat/">https://github.com/cran/uniqueAtomMat/</a></div>
</div>
<div id="ref-wikiZonohedron" class="csl-entry">
<div class="csl-left-margin">[9] </div><div class="csl-right-inline">WIKIPEDIA CONTRIBUTORS. <em>Zonohedron 
<span>Wikipedia</span><span>,</span> the free encyclopedia</em>
[online]. 2022. Available at:<a href="https://en.wikipedia.org/w/index.php?title=Zonohedron&amp;oldid=1081903795">https://en.wikipedia.org/w/index.php?title=Zonohedron&amp;oldid=1081903795</a>.
[Online; accessed 27-May-2022]</div>
</div>
</div>
<p><br><br></p>
<p><br><br></p>
<div id="appendix-a---methods" class="section level2">
<h2>Appendix A - Methods</h2>
<p>The constructor <code>zonohedron()</code> uses the optimizations in
Paul Heckberts memo <span class="citation">[6]</span>. The key step is
sorting points that lie on a great circle on the sphere. This efficient
method is <span class="math inline">\(O(N^2\log(N))\)</span>; whereas
the naive method is <span class="math inline">\(O(N 2^N)\)</span>.</p>
<p>The central symmetry is used whenever possible, and when used this
can speed things up by a factor of 2. To further speed things up, many
of the methods use C/C++.</p>
<p>The function <code>grpDuplicated()</code> was written by Long Qu,
with a small modification of the return value by myself. It is written
in C/C++ and is implemented with <code>std::unordered_map</code>. The
code was taken from the discontinued package
<strong>uniqueAtomMat</strong>, see <span class="citation">[8]</span>.</p>
<p><br><br></p>
</div>
<div id="appendix-b---logging" class="section level2">
<h2>Appendix B - Logging</h2>
<p>Logging is performed using the package <strong>logger</strong>, see
<span class="citation">[3]</span>. This is a powerful package that
allows a separate configuration for logging from within
<strong>zonohedra</strong>, and that is what I have done. During package
loading, the logging threshold is changed from <code>INFO</code> to
<code>WARN</code>. To change it back again, one can execute:<br />
<code>library( logger )</code><br />
<code>log_threshold( INFO, namespace=&quot;zonohedra&quot; )</code></p>
<p>The layout callback functions is customized; it adds the name of the
calling function to the message. To install your own layout function,
you can execute:<br />
<code>log_layout( &lt;your function&gt;, namespace=&quot;zonohedra&quot; )</code></p>
<p>The appender callback functions is also customized; it comes to an
immediate stop if the message level is <code>ERROR</code> or
<code>FATAL</code>. To return to the default behavior, you can
execute:<br />
<code>log_appender( appender_console, namespace=&quot;zonohedra&quot; )</code></p>
<p>The formatter callback function is forced to be
<code>formatter_sprintf()</code>; this should not be changed.</p>
<p><br><br></p>
</div>
</div>
<div id="session-information" class="section level1">
<h1>Session Information</h1>
This document was prepared Wed Aug 27, 2025 with the following
configuration:
<pre>
R version 4.5.1 (2025-06-13 ucrt)
Platform: x86_64-w64-mingw32/x64
Running under: Windows 11 x64 (build 26100)

Matrix products: default
  LAPACK version 3.12.1

locale:
[1] LC_COLLATE=C                          
[2] LC_CTYPE=English_United States.utf8   
[3] LC_MONETARY=English_United States.utf8
[4] LC_NUMERIC=C                          
[5] LC_TIME=English_United States.utf8    

time zone: America/Los_Angeles
tzcode source: internal

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
[1] orientlib_0.10.5 rgl_1.3.18       zonohedra_0.5-0 

loaded via a namespace (and not attached):
 [1] digest_0.6.37        R6_2.6.1             microbenchmark_1.5.0
 [4] base64enc_0.1-3      fastmap_1.2.0        xfun_0.52           
 [7] magrittr_2.0.3       glue_1.8.0           cachem_1.1.0        
[10] knitr_1.50           htmltools_0.5.8.1    logger_0.4.0        
[13] rmarkdown_2.29       lifecycle_1.0.4      cli_3.6.5           
[16] sass_0.4.10          jquerylib_0.1.4      compiler_4.5.1      
[19] av_0.9.4             tools_4.5.1          evaluate_1.0.3      
[22] bslib_0.9.0          yaml_2.3.10          htmlwidgets_1.6.4   
[25] rlang_1.1.6          jsonlite_2.0.0      
</pre>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
